#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass ucthesisLyx
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package babel
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.4]{UniTrier.eps}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	
\backslash
Huge
\end_layout

\begin_layout Plain Layout

	
\backslash
bf
\end_layout

\begin_layout Plain Layout

	Bachelorarbeit
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
small
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
zur Erlangung des akademischen Grades "Bachelor of Science" im Fach Informatik
\end_layout

\begin_layout Plain Layout


\backslash
vspace{1 cm}
\end_layout

\begin_layout Plain Layout


\backslash
Large
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Implementierung eines generischen Clients für iOS
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
zur Analyse von REST-Services
\end_layout

\begin_layout Plain Layout


\backslash
normalsize
\end_layout

\begin_layout Plain Layout


\backslash
vspace{2.3 cm}
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Mario Stief
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
geboren am 23.05.1981 in Trier
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
eingereicht im Dezember 2012
\end_layout

\begin_layout Plain Layout


\backslash
vspace{2.3 cm}
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Betreuer:
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Prof.
 Dr.
 Peter Sturm
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Lehrstuhl für Systemsoftware und Verteilte Systeme
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.4 cm}
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Zweitgutachter:
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Prof.
 Dr.
 Stephan Diehl
\end_layout

\begin_layout Plain Layout

	
\backslash

\backslash
Lehrstuhl für Softwaretechnik
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
large
\end_layout

\begin_layout Plain Layout


\backslash
bf
\end_layout

\begin_layout Plain Layout

	Erklärung zur Bachelorarbeit
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{1 cm}
\end_layout

\begin_layout Plain Layout


\backslash
normalsize
\end_layout

\begin_layout Plain Layout

	Hiermit erkläre ich, dass ich die Bachelorarbeit selbstständig  verfasst
 und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt 
 und die aus fremden Quellen direkt oder indirekt  übernommenen Gedanken
 als  solche kenntlich gemacht habe.
 Die Arbeit habe ich bisher keinem anderen Prüfungsamt in gleicher oder
 vergleichbarer Form vorgelegt.
 Sie wurde bisher nicht veröffentlicht.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
vspace{1.5 cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{lp{2em}l}   
\backslash
hspace{6cm}   && 
\backslash
hspace{6cm}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\backslash
cline{1-1}
\backslash
cline{3-3}   Ort, Datum     && Unterschrift  
\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Inhaltsverzeichnis}
\end_layout

\end_inset


\lang ngerman

\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einleitung
\end_layout

\begin_layout Standard
Im Programmieralltag eines Informatikers an der Universität Trier beschäftigt
 man sich hauptsächlich mit der plattformunabhängigen objektorientierten
 Programmiersprache Java.
 Sie eignet sich aufgrund ihrer Portabilität hervorragend als Einsteigersprache,
 denn die für das Ausführen benötigte Laufzeitumgebung kann man sich für
 nahezu jedes Betriebssystem herunterladen und installieren.
 Eine Ausnahme bildet das mobile Betriebssystem iOS, für welches Apple die
 Entwicklung einer Java Runtime nicht gestattet.
 Maschinennähere Erfahrungen sammelt man in C++, welches auf dem prozeduralen
 ANSI-C basiert, jedoch zahlreiche Erweiterungen in Hinblick auf die objektorien
tierte Programmierung bietet, seien es Möglichkeiten zur Datenkapselung,
 Vererbung oder Polymorphie, um nur einige zu nennen.
 Dazu wurden Sprachkonstrukte von C abgeändert, so dass manche C-Programme
 abgepasst werden müssen, um sich als C++-Programm übersetzen zu lassen.
 Einen etwas anderen Ansatz geht Apple mit der Programmiersprache Objective-C,
 welche ursprünglich als Basis für das Betriebssystem NextStep verwendet
 wurde.
 Mit der Übernahme zu Apple wurde die aus NextStep hervorgehende OpenStep-API
 ebenfalls Grundlage für OS X, womit sich auch die Systemsprache von Pascal
 auf Objective-C änderte.
 Anders als C++ greift Objective-C für die objektorientierte Erweiterung
 auf die Sprache Smalltalk zurück, in der mit Nachrichtenkommunikation gearbeite
t wird und in der es nur drei eingebaute ausführbare Konstrukte gibt: Eine
 Botschaft wird an ein Objekt gesendet, einer Variable wird ein Objekt zugewiese
n oder ein Objekt wird als Rückgabewert einer Methode zurückgeliefert.
 Die Smalltalk-Erweiterung ist von der gewöhnlichen C-Syntax strikt getrennt,
 somit gibt es kein Problem, herkömmlichen C-Code zu übersetzen.
 Dieser andersartige Ansatz macht neugierig, einmal selbst in die Tiefen
 des auf Nachrichten basierenden C-Derivates abzutauchen und einen genaueren
 Blick auf das Konzept hinter den vielen eckigen Klammern zu werfen, mit
 denen sich ein in Objective-C geschriebenes Programm präsentiert.
 Der TIOBE-Index, der seit 2001 ein monatlich aktualisiertes Ranking von
 Programmiersprachen nach ihrer Popularität publiziert, listet Objective-C
 hinter C und Java derzeit auf Platz 3 der am meisten verwendeten Programmierspr
achen.
\begin_inset Foot
status open

\begin_layout Plain Layout
TIOBE Programming Community Index for November 2012, Headline: Objective-C
 on its way to become "language of the year" again
\end_layout

\end_inset

 Die Tendenz: kontinuierlich steigend.
\begin_inset Foot
status open

\begin_layout Plain Layout
TIOBE Programming Community Index Objective-C
\end_layout

\end_inset

 Diese Arbeit bietet eine attraktive Möglichkeit, sich im universitären
 Rahmen in diesen Bereich einzuarbeiten und einen Blick über den Tellerrand
 zu werfen.
 Eine Möglichkeit, die ich hiermit gerne ergreifen möchte.
\end_layout

\begin_layout Standard
Für die Entwicklung auf seinen Systemen stellt Apple mit Xcode eine Entwicklungs
umgebung, die nach eigenen Angaben mächtig genug ist, dass sie von Apple
 selbst zur Entwicklung von Betriebssystemen und Anwendungen eingesetzt
 wird - und in den aktuellen Versionen angeblich eine sehr einfach zu erlernende
 Oberfläche für den Entwurf der GUI mit sich bringt.
 Neben der Entwicklung einer Anwendung für einen Apple Macintosh bietet
 sich mit einer relativ neuen Technologie jedoch noch ein weiteres Stück
 Hardware des Unternehmens aus Kalifornien an: Im Jahr 2010 landete mit
 dem iPad die Sparte der “Post-PC”-Tablets im Mainstream-Bereich, die 2005
 ihren ersten Kandidaten mit dem Nokia 770 Internet-Tablet hatte.
 Diese Post-PCs waren keine herkömmlichen Notebooks mit Tastatur mehr, die
 über für Stift-Bedienung ausgelegte Touchscreen verfügten, sie waren wesentlich
 leichter und dünner, liefen mit eigenen, angepassten Betriebssystem und
 verfügten über eine innovatives Bedienkonzept für Fingerberührungen - auch
 wenn das beim Nokia 770 noch nicht der Fall war.
 Auch heute liegt der Marktanteil von Apples iPad noch bei über 50 %
\begin_inset Foot
status open

\begin_layout Plain Layout
Der Apple-Marktanteil am Tablet-Markt betrug lt.
 einer IDC-Pressemitteilung vom 5.
 November 2012 50,4 %.
\end_layout

\end_inset

, so ist es sicherlich eine lohnende Erfahrung, den “Blick über den Tellerrand”
 zusätzlich auf dieses neuartige Stück Hardware zu richten und eine Anwendung
 zu schreiben, die auf Apples mobilem Betriebssystem iOS läuft.
\end_layout

\begin_layout Standard
Als Anwendungsbeispiel für diese ersten Schritte in einer neuen Umgebung
 wird ein Client implementiert, der die Verbindung mit einem mir ebenfalls
 neuen Bereich herstellt: RESTful Webservices.
 Die Abkürzung REST steht für Representional State Transfer und ist ein
 Programmierparadigma für Webanwendungen, welches im Grunde so alt ist wie
 das Internet selbst.
 Dieser erst 2000 in einer Dissertation eingeführte Standard beschreibt
 die Implementierung eines Webservices, mit dem die bereits im HTTP-Protokoll
 definierten Methoden GET, PUT, POST, DELETE und HEAD auf statischen Inhalten
 arbeiten.
 Diese werden wiederum auf permanente URLs abgebildet.
 Da die Funktionalität REST-konformer Webservices immer auf diese HTTP-Methoden
 abgebildet wird, sollte es möglich sein, einen generischen Client zu entwickeln
, der mit all diesen Webservices irgendwie eine gemeinsame Kommunikationsschnitt
stelle bildet.
 Es sollen Anfragen gesendet und Antworten ausgewertet werden.
 Diese Antworten bekommt man in der Regel im Format XML oder JSON zurückgeliefer
t.
 Der Client sollte in der Lage sein, diese Daten zu analysieren, die potentielle
n Ressourcen darin zu erkennen, sie zu validieren und aufzubereiten und
 dem Anwender eine einfache Möglichkeit bieten, mit diesen zu interagieren.
\end_layout

\begin_layout Standard
Auf dem Weg zum funktionsfähigen Client wird zunächst ein kurzer Einblick
 in die Werkzeugkiste gegeben, mit der hier gearbeitet wird.
 Es wird kurz die Programmiersprache Objective-C vorgestellt und einige
 Eigenheiten aufgezeigt, die man in dieser Form so nicht in der Java- oder
 C++-Welt findet.
 Weiterhin wird die von Apple verwendete API Cocoa Touch vorgestellt und
 die Entwicklungsumgebung Xcode, mit der auf diese zugegriffen wird.
 Im darauffolgenden Kapitel wird auf die Schnittstelle mit der REST-Welt
 eingegangen.
 Es wird erklärt, was im Genauen unter einem REST-kompatiblen Webservice
 zu verstehen ist und wie man mit diesen kommuniziert.
 Den letzten größeren Bereich stellt die Implementierung der fertigen Software,
 deren Funktionalität anhand genereller Abläufe beschrieben wird.
 Weiter wird hier auf die Probleme, die sich während des Entwickelns dieser
 Arbeit ergaben, näher eingegangen.
 Abgerundet wird diese Arbeit durch einen reflektiven Abriss der vorhergegangen
 Kapitel und einen persönlichen Ausblick darauf, ob die herausgearbeiteten
 Erfahrungen den Ausflug in die Welt der Apple-Systeme beenden oder den
 Grundstein bilden für weitere Entwicklungen auf den mobilen Systemen der
 Kalifornier.
 
\end_layout

\begin_layout Chapter
Die Werkzeugkiste
\end_layout

\begin_layout Section
Basissprache: Objective-C
\end_layout

\begin_layout Standard
Das Entwickeln der ersten App für Apple-Hardware bringt die Herausforderung
 mit sich, eine neue Programmiersprache erlernen zu müssen.
 So wie Microsoft für sein .NET-Framework die C#-Sprache entwickelte, welche
 Grundkonzepte der objektorientierten Hochsprachen C++, Java und Delphi
 in sich vereint, so verwendet Apple für seine Systeme die Sprache Objective-C.
 Anders als C# greift das in den frühen 80ern entwickelte Objective-C auf
 das prozedurale ANSI-C zurück.
 Seine objektorientierte Erweiterung ist eine Anlehnung an Smalltalk und
 wird als solche von der C-Syntax strikt getrennt.
 Die syntaktisch wichtigsten Neuerungen sind wie bei anderen Erweiterungskonzept
en hauptsächlich die Verwendung von Klassen und Methodenaufrufen.
 Analog kann dieser Ansatz dazu verwendet werden, aus Pascal und Javascript,
 die beide von Haus aus über kein Klassenkonzept verfügen, die objektorientierte
n Erweiterungssprachen Objective-Pascal und Objective-J zu erzeugen.
\end_layout

\begin_layout Standard
Wie aus der C-Welt bekannt wird in einer Header-Datei mit der Endung .h das
 Interface deklariert, die Implementierungen erfolgt in der dazugehörigen
 .m-Datei, welche Objective-C- oder einfachen C-Code enthalten kann.
 Aus Kompatibilitätsgründen lassen sich Implementierungen mit der Dateiendung
 .mm anlegen, dieser darf explizit C++-Code enthalten, was die Weiterverwendung
 von C++-Bibliotheken erlaubt.
 Statt 
\family typewriter
\size footnotesize
#include
\family default
\size default
 sollte man bei Objective-C auf 
\family typewriter
\size footnotesize
#import
\family default
\size default
 zurückgreifen, da es sicher stellt, dass jede einzubindende Datei auch
 nur höchstens einmal eingebunden wird.
\end_layout

\begin_layout Standard
In Objective-C werden keine Funktionen mehr mit Parametern aufgerufen.
 Statt dessen verwendet man Objekte, die sich untereinander Nachrichten
 senden und so miteinander kommunizieren.
 Diese Nachrichten veranlassen ein Objekt, eine Methode auszuführen.
 Dieses Paradigma wird als Message Passings bezeichnet und unterscheidet
 sich stark von der Art der Methodenaufrufe, die man C++ verwendet.
 Es darf grundsätzlich jedes Objekt jede beliebige Nachricht an jedes Objekt
 senden - oder auch an sich selbst, in dem Fall wird der Bezeichner self
 verwendet - ganz gleich ob die Zielklasse oder eine beerbte Oberklasse
 die passende Methode zu dieser Nachricht implementiert.
 Da Methoden stets erst zur Laufzeit ermittelt werden und nicht bereits
 beim Übersetzen, entscheidet sich erst beim Aufruf, wie ein Objekt auf
 eine Nachricht reagieren wird.
 Dieses Verfahren bezeichnet man daher auch als dynamisches Binden.
 Im Gegensatz dazu werden die verwendeten C-Funktionen bereits beim Übersetzen
 statisch gebunden.
 Konsequenterweise existiert ebenfalls eine Methode, welche auf Nachrichten
 reagiert, für die keine eigene Implementierung durch die Klasse bereitgestellt
 wird.
 Abstrakte Klassen kennt Objective-C übrigens nicht.
 Jede Klasse muss vollständig implementiert werden, damit jederzeit Objekte
 dieser Klasse erzeugt werden können.
 Um dies zu umgehen lassen sich Protokolle deklarieren, in denen notwendige
 Methoden unter dem 
\family typewriter
\size footnotesize
@required
\family default
\size default
-Tag aufgelistet werden.
\end_layout

\begin_layout Standard
Wie in C++ lassen sich aus einer Klasse Objekte erzeugen.
 Darüber hinaus ist aber jede Klasse auch selbst als Objekt ansprechbar.
 Diese enthalten jedoch keine Member-Variablen und sind stets Singletons,
 also Entwurfsmuster, die sicher stellen, dass von einer Klasse genau ein
 Objekt existiert, welches global verfügbar ist.
 Da ein solches Klassenobjekt ebenfalls für beliebige Nachrichten empfänglich
 ist, erfolgt das Binden seiner Methoden auch erst zur Laufzeit.
 Strings werden in Objective-C mit der Notation 
\shape italic
@”…”
\shape default
 erzeugt.
 Ein solcher String ist ein Objekt vom Typ 
\shape italic
NSString
\shape default
 und als solcher ebenfalls in der Lage, Nachrichten zu empfangen.
 Das vorangestellte 
\shape italic
@
\shape default
 ist ein Indikator für ein Objective-C-Objekt.
 Wird es bei der Angabe des String weggelassen, wird der bekannte, nullterminier
te C-String erzeugt.
 Per Vorgabe besitzen die Datentypen in Objective-C die gleiche Typisierung
 wie in C: Sie sind 
\shape italic
schwach
\shape default
, 
\shape italic
statisch
\shape default
 und 
\shape italic
explizit
\shape default
.
 Während eine 
\shape italic
schwache
\shape default
 Typisierung Auskunft darüber gibt, dass Dateitypen ineinander umgewandelt
 werden können, weist das Merkmal 
\shape italic
statisch
\shape default
 darauf hin, dass der Datentyp bereits zur Übersetzungszeit geprüft wird.
 Im Gegensatz dazu werden dynamische Datentypen erst zur Laufzeit getestet.
 
\shape italic
Explizit
\shape default
 letztlich bedeutet, dass die Datentypen nicht erst per Typableitung ermittelt
 werden.Das Konzept der dynamischen Typisierung ist mit dem typlose Datentyp
 
\shape italic
id
\shape default
 umgesetzt, welcher einen Zeiger auf ein Objekt einer beliebigen Klasse
 repräsentiert und an den jede beliebige Nachricht gesendet werden kann.
 Ist für den tatsächlichen Typ dieses Objektes diese Methode jedoch unbekannt
 oder möchte man eine typlose Variable an eine typgebundene Variable zuweisen,
 deren Typen nicht übereinstimmen, so kommt es zu einem Laufzeitfehler.
\end_layout

\begin_layout LyX-Code

\size footnotesize
id stringObject = @"Objective-C is great."; // OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSString *string = stringObject;            // OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSNumber *number = stringObject;            // logischer Fehler
\end_layout

\begin_layout LyX-Code

\size footnotesize
char character = [number charValue];        // Laufzeitfehler
\end_layout

\begin_layout Standard
Instanzobjekte einer Klasse werden durch das Senden einer entsprechenden
 Nachricht an das zugehörige Klassenobjekt erzeugt.
 Für Gewöhnlich geschieht dies beim Programmstart, jedoch können im Gegensatz
 zu C++ bei Objective-C jederzeit auch während der Laufzeit noch neue Objekte
 erstellt werden.
 Überladene Methoden, wie man sie in C++/Java kennt, findet man so in Objective-
C nicht mehr, denn eine Nachricht an eine Methode besteht aus dem Selektor,
 der sich aus dem Methodennamen und den Parametern zusammensetzt.
 Das Laufzeitsystem sucht bei einer eingehenden Nachricht nach einer solchen
 Methode und führt diese im Erfolgsfall aus.
 Wird keine passende Methode lokalisiert, wird ein 
\shape italic
nil
\shape default
 zurückgeliefert.
 Möchte man sich absichern, lässt sich das Objekt im Voraus fragen, ob es
 eine bestimmte Nachricht versteht.
 Diese Fähigkeit der Selbstkenntnis beinhaltet ebenfalls das Ermitteln der
 eigenen Klasse und das Wissen, ob seine Klasse eine Unterklasse einer bestimmte
n anderen Klasse ist.
 Der Begriff Reflexion sollte dem ein oder anderen ebenfalls aus der Java-/C++-W
elt bekannt sein.
\end_layout

\begin_layout LyX-Code

\size footnotesize
if([geometricFigure respondsToSelector:@selector(getShape)]) { ...
 }
\end_layout

\begin_layout Standard
Dem Smalltalk-Erweiterungsanteil verdankt Objective-C die verwendete Notation
 der eckigen Klammern, die ausdrückt, dass an dieser Stelle Nachrichten
 versendet werden.
 An erster Stelle wird das Empfängerobjekt genannt, anschließend folgt der
 Selektor und gegebenenfalls der Parameter.
 Sind Sender und Empfänger der Nachricht das gleiche Objekt, verwendet man
 den Bezeichner 
\shape italic
self
\shape default
.
\end_layout

\begin_layout LyX-Code

\size footnotesize
// somewhere lost in code:
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSInteger age = [self computeAgeFromYear:1981 withMonth:5 andDay:23]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size footnotesize
// method declaration:
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSInteger)computeAgeFromYear:(NSInteger)birthyear
\end_layout

\begin_layout LyX-Code

\size footnotesize
                      withMonth:(NSInteger)month
\end_layout

\begin_layout LyX-Code

\size footnotesize
                         andDay:(NSInteger)day { ...
 }
\end_layout

\begin_layout Standard
Diese Schreibweise ist für Neulinge äußerst gewöhnungsbedürftig, da hier
 jeder Parameter eine explizite Benennung erfordert.
 Methodennamen können in Objective-C durchaus sehr lang werden.
 Hat man sich jedoch einmal daran gewöhnt, mag man diese Notation jedoch
 nur ungern missen, denn sie fördert die Lesbarkeit und Verständlichkeit
 des Codes ungemein.
 Die obige Methode bezeichnet man vollständig als: 
\shape italic
computeAgeFromYear:withMonth:andDay
\shape default
, was auch gleichzeitig der Selektor dieser Methode ist.
\end_layout

\begin_layout Standard
Das Minus-Präfix zu Beginn der oben stehenden Methode gibt an, dass es sich
 hierbei um eine Instanzmethode handelt.
 Das entspricht dem Verständnis einer Methode in C++/Java.
 Da in Objective-C jedoch auch Klassen Objekte sind, können diese eigene
 Methoden haben.
 Solche Klassenmethoden werden durch ein vorangestelltes Plus gekennzeichnet.
 Ein gutes Beispiel ist der zum Initialisieren gebräuchliche verkettete
 Befehl 
\family typewriter
\size footnotesize
[[NSObject alloc] init]
\family default
\size default
, der aus den folgenden Methoden besteht: 
\family typewriter
\size footnotesize
+(id)alloc
\family default
\size default
 ist die Klassenmethode, die Speicher für das Objekt reserviert und einen
 Zeiger darauf zurückliefert.
 Anschließend initialisiert sich das erzeugte Objekt in dem allokierten
 Speicherbereich durch den Aufruf der Instanzmethode 
\family typewriter
\size footnotesize
-(id)init
\family default
\size default
.
 
\end_layout

\begin_layout Subsection
Protokolle: Data Sources und Delegates
\end_layout

\begin_layout Standard
Ein Protokoll ist einem Interface in Java sehr ähnlich: Es deklariert die
 Methoden, die in eine Klasse vorhanden sein müssen, welche es implementiert.
 Eine Protokolldeklaration beginnt mit dem Schlüsselwort 
\family typewriter
\size footnotesize
@protocol
\family default
\size default
, die enthaltenen Methoden befinden sich entweder unter dem Tag 
\family typewriter
\size footnotesize
@required
\family default
\size default
 oder unter dem Tag 
\family typewriter
\size footnotesize
@optional
\family default
\size default
.
 Bei der Deklaration der Klasse wird das Protokoll in spitzen Klammern hinter
 der Oberklasse angegeben, mehrere Protokolle werden durch Kommata voneinander
 getrennt:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@interface ViewController : UIViewController <UITextFieldDelegate,
\end_layout

\begin_layout LyX-Code

\size footnotesize
   UITableViewDelegate, UITableViewDataSource> {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Standard
Ein Konzept, welches so ebenfalls nicht bei Java oder C++ anzutreffen ist,
 sind die so genannten 
\shape italic
Delegates
\shape default
 (vom englischen delegation: Abordnung, Übertragung) und die 
\shape italic
DataSources
\shape default
.
 Mit ihnen ist es möglich, Nachrichten an ein delegiertes Objekt weiterzuleiten,
 die in einen bestimmten Funktionalitätsbereich fallen.
 Ein Textfeld sendet nach dem Betätigen der Eingabetaste die Nachricht 
\shape italic
textFieldShouldReturn:(UITextField *)
\shape default
 an ihre 
\shape italic
Delegate
\shape default
.
 Diese 
\shape italic
Delegate
\shape default
 kann die eigene Instanz sein oder aber ein beliebiges anderes Objekt, welches
 das Protokoll 
\shape italic
UITextFieldDelegate
\shape default
 implementiert.
 Der Methode 
\shape italic
textFieldShouldReturn
\shape default
 spezifiziert, was beim Betätigen der Eingabetaste passieren soll.
 An dieser Stelle bietet es sich beispielsweise an, mittels 
\family typewriter
\size footnotesize
[textField resignFirstResponder]
\family default
\size default
 das On-Screen-Keyboard wieder zurückzuziehen und eine weitere Methode aufzurufe
n, welche auf den im Textfeld enthaltenen Text zugreift.
 Die ordnungsgemäße Durchführung wird mit einem zurückgegebenen 
\shape italic
YES
\shape default
 bestätigt.
 Ein Objekt kann nicht nur als Empfänger von Nachrichten dienen, er kann
 andersrum auch als Datenquelle fungieren.
 Implementiert es das einer Programmstruktur zugehörige 
\shape italic
DataSource
\shape default
-Protokoll, lässt es sich von dieser nutzen, um bei Laufzeit von dieser
 benötigte Daten abzufragen.
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard

\shape italic
Properties
\shape default
 werden in der Headerdatei deklariert und stellen einen einfachen Weg dar,
 Accessoren zu implementieren.
 War in früheren Xcode-Versionen noch das manuelle Synthetisieren mittels
 
\family typewriter
\size footnotesize
@synthesize
\family default
\size default
 notwendig, werden diese durch die Deklaration eines 
\shape italic
Property
\shape default
 automatisch generiert.
 Ein 
\family typewriter
\size footnotesize
@property (UITextField*)name
\family default
\size default
 erzeugt per default den Setter 
\shape italic
setName
\shape default
 sowie den Getter 
\shape italic
name
\shape default
.
 Möchte man die Variable 
\shape italic
name
\shape default
 nun setzen, werden zwei Möglichkeiten angeboten: den C-Weg oder die nachrichten
basierte Objective-C-Notation.
 Ein 
\family typewriter
\size footnotesize
_name.text = string
\family default
\size default
 wird intern in ein 
\family typewriter
\size footnotesize
[_name setText:NSString]
\family default
\size default
 umgewandelt.
 In der Umsetzung dieser Arbeit wurde konsequent die Objective-C-Notation
 verwendet.
 Wenn man es ganz genau nimmt, führt Objective-C intern den folgenden Befehl
 aus: 
\family typewriter
\size footnotesize
[[self name] setText:NSString]
\family default
\size default
.
 Der Unterstrich zeigt, dass es sich um eine Instanzvariable handelt.
 Da Apple vorangestellte Unterstriche für eigene Zwecke einsetzt, sollte
 zur Vermeidung von Verwechslungen auf die eigene Verwendung bei der Namensgebun
g verzichtet werden.
\end_layout

\begin_layout Section
API: Cocoa Touch
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Layers.tiff
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schichtenmodell von iOS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Apples mobiles Betriebssystem iOS lässt sich in vier grundlegende Schichten
 einteilen: Während das Core OS den Mach-Kernel sowie die grundlegenden
 Funktionen beinhaltet, stellen die Core Services die Frameworks bereit,
 welche die Grundlage aller Anwendungen und Dienste sind, die auf dem Gerät
 laufen.
 Die darüber liegende Media-Schicht bündelt die Multimediafunktionen, schlussend
lich folgt an der Spitze die Programmierschnittstelle Cocoa Touch.
 Diese stellt die Schnittstellen zu sämtlichen darunter liegenden Schichten
 bereit.
 Gegenüber Cocoa, der Schnittstelle für OS X-Desktop-Maschinen, greift die
 Touch-Variante der API auf eine angepasste Benutzerschnittstelle zurück.
 Hier bieten spezielle Unterstützung für Bewegungssensoren, Multitouch-Gestenerk
ennung und Animationen, die speziell auf iOS abgestimmt sind, dem Programmierer
 darauf abgestimmte Eingabeelemente und Events an.
 Die Basis von Cocoa Touch bildet zum einen das Foundation Framework.
 Dieses stellt alle Basisklassen zur Verfügung, die für die grundlegende
 Programmierung mit Objective-C unverzichtbar sind.
 Weiter werden in diesem Werkzeuge wie Collections und Dateihandling bereitgeste
llt, ohne die eine moderne Programmierung heute nicht mehr auskommt.
 Seit iOS-Version 2 befindet sich darin bereits XML-Unterstützung, in iOS
 5 wurde diese um Unterstützung für das JSON-Format ergänzt.
 Dies machte es im Rahmen dieser Arbeit sehr einfach, auf externe Frameworks
 zu verzichten.
 Das UIKit als weiterer integraler Bestandteil von Cocoa Touch beinhaltet
 Klassen, die speziell auf die Entwicklung der grafischen Oberfläche ausgerichte
t sind.
 So enthält diese die Infrastruktur für grafische Anwendungen verschiedene
 Ansichten, so genannte Views, und deren Fenster, Menüs und Schaltflächen,
 sowie ein passendes Ereignissystem mit Sprachanbindung und Textsystem.
 Ereignisse durchlaufen eine so genannte “Responder-Chain”, die aus unterschiedl
ichen Klassen besteht.
 Nacheinander werden dieser eingetroffene Ereignisse entnommen und verarbeitet.
 Seit OS X 10.4/iOS 3 wurde diese Sammlung um das Core Data-Framework ergänzt,
 einem schemabasierten Ansatz für die Umsetzung des MVC-Entwurfmusters.
 Der Model-View-Controller ist in Cocoa Touch strikt umgesetzt; Klassen
 lassen sich in der Regel eindeutig zuordnen.
 Bei den Klassennamen selbst ist auffallend, dass die meisten mit NS beginnen,
 wie zum Beispiel 
\shape italic
NSObject
\shape default
, 
\shape italic
NSString
\shape default
 oder 
\shape italic
NSArray
\shape default
.
 Dies hat seinen Ursprung darin, dass Apple im Jahre 1996 das OpenStep-Framework
 NeXTStep aufkaufte und als Basis für Mac OS X verwendete.
 Durch die Verwendung von “Klassen-Clustern” werden viele sichtbare Klassen
 nie instanziiert, sondern es werden statt dessen direkt zur Laufzeit Instanzen
 von passenden Subklassen erzeugt, von denen der Programmierer keine Kenntnis
 hat.
 Beispielsweise verlangt ein Anwendungsprogrammierer nach einer Instanz
 von 
\shape italic
NSArray
\shape default
, erzeugt wird jedoch in Abhängigkeit der Elemente eine Instanz einer Klasse,
 die er nicht kennt.
\end_layout

\begin_layout Section
IDE: Xcode
\end_layout

\begin_layout Standard
Xcode ist Apples integrierte Entwicklungsumgebung und steht aktuell in der
 Version 4.5.2 zur Verfügung.
 Seit der Version 4.1 lässt sich Xcode frei zugänglich im App Store herunterladen.
 In der Version 4.4 sind die SDKs für OS X 10.8 sowie für iOS 5.1 enthalten,
 Version 4.5 bringt die SDK für das neue iOS 6 mit.
 Beide benötigen mindestens OS X in der Version 10.7.4 Lion oder 10.8 Mountain
 Lion.
 Die Implementierung dieser Arbeit wurde mit der Version 4.4 begonnen und
 auf 4.5 gewechselt.
 Jede Funktionalität wurde stets sowohl für iOS 5.1 als auch für iOS 6 getestet
 und gegebenenfalls angepasst.
 Mit Xcode lassen sich sowohl OS X- als auch iOS-Anwendungen entwickeln,
 wobei OS X-Anwendungen auf der Cocoa-API basieren; möchte man eine Anwendung
 für das mobile iOS entwickeln, so nutzt man hierfür das im vorherigen Kapitel
 vorgestellte Cocoa Touch-Framework.
 Xcode kommt mit einer Reihe von Werkzeugen - den Xcode Tools - welche die
 alltägliche Arbeit des Objective-C-Programmierers erleichtern sollen.
 Apples LLVM Compiler bietet eine Echtzeitüberprüfung des eingegebenen Codes
 und meldet auffallende Syntax- oder Schreibfehler umgehend.
 Oft bietet die eingeblendete Fix-it-Funktion gleich eine adäquate Lösung,
 die sich mit einem Klick übernehmen lässt.
 Natürlich darf man hier keine Wunder erwarten, im Rahmen dieser Arbeit
 hat sich deren Vorhandensein jedoch als sehr angenehm erwiesen.
 Mit dem Analysetool Instruments lassen sich diverse Messinstrumente mit
 einem Prozess verbinden und deren Laufzeitverhalten akribisch genau analysieren.
 Um ein Programmverhalten auf einem bestimmten iOS-Gerät zu testen, lässt
 sich auf den integrierten iPhone- und iPad-Simulator zurückgreifen, für
 den verschiedene iOS-Versionen bereitgestellt werden.
 Diese lassen sich aus Xcode heraus mit einem Klick installieren.
 Auf dem Simulator lässt sich die App testen, ohne dass man ein physisches
 Gerät zur Hand haben muss.
 Es lassen sich verschiedene Hardware-Events simulieren, vom Schwenk des
 Orientation-Modus über die Betätigung der Home-Taste bis hin zu einer Speicherw
arnung, mit welcher man die eigene Software testen kann.
 Möchte man jedoch Implementierungen von spezielleren Sensoren überprüfen,
 wie sie in den aktuellen Geräten eingesetzt werden, kommt man an einem
 physikalischen Gerät nicht vorbei.
 Das Interface von Xcode besteht zum einen aus dem Source Editor, welcher
 Komfortmerkmale wie Code Completion, Syntax Highlighting und Code Folding
 bereitstellt, sowie die äußerst angenehme Echtzeitsuche nach Fehlern, Warnungen
 und anderer kontextsensitiven Informationen.
 Diese werden in Nachrichtenblasen am Fehlerort eingeblendet.
 Daneben ermöglicht der Assistant Editor über ein zweigeteiltes Fenster
 den Schnellzugriff auf Dateien, die für gewöhnlich eine hilfreiche Kombination
 mit der geöffneten Datei darstellen, zum Beispiel wird neben dem Interface
 gleich deren Implementierung geöffnet.
 Der Interface Builder, welcher mit Version 4.0 von den externen Xcode Tools
 in die IDE integriert wurde, ermöglicht es, äußerst komfortabel und ohne
 eine Zeile Code, die GUI der App zu designen und die einzelnen Interfacekompone
nten untereinander zu verknüpfen und in den Programmcode einzubinden.
 Der Organizer als weiteres Element ist die zentrale Verwaltung für die
 der Entwicklerlizenz hinzugefügten Geräte, die Versionsverwaltung über
 lokale sowie entfernte Repositorien, Projekte und deren Snapshots und für
 ein App Archiv, von dem aus man seine entwickelten Apps verwaltet und zum
 App Store sendet.
 Am Rand lassen sich weitere Leisten einblenden: Auf der linken Seite wäre
 dies der Navigator, der durch Dateien, Fehler und Logs navigiert; rechts
 lässt uns die Utility Bar einige Einstellungen vornehmen.
 Darüber hinaus befindet sich dort auch eine File Templates- und eine Code
 Snippets-Library im unteren Bereich für Dinge, die man immer mal wieder
 benötigt.
 Im unteren mittleren Bereich lässt sich selbstverständlich die für das
 Debugging unentbehrliche obligatorische Konsole einblenden.
 Da es vor allem auf mobilen Geräten eher zu Ressourcenknappheit kommt als
 auf Desktop-Systemen, sollte man hier einen entsprechend ökonomischen Programmi
erstil pflegen und Ressourcen, die nicht mehr benötigt werden nach der Verwendun
g wieder freigeben.
 In Xcode 4.2 wurde das 
\shape italic
Automatic Reference Counting
\shape default
 eingeführt, um den Entwickler dabei zu unterstützen.
 Die bislang verwendeten retain und release-Nachrichten, mit denen Speicher
 freizugeben war oder diese Freigabe verhindert werden sollte, wurden obsolet,
 wenn das Projekt mit ARC genutzt wird.
 Statt dessen übernimmt nun der Compiler die Referenzzählung und fügt dem
 Code beim Übersetzen die entsprechenden retain und release-Nachrichten
 hinzu.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Xcode.tiff
	lyxscale 21
	scale 21

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Xcode
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Interface Builder: Storyboards
\end_layout

\begin_layout Standard
Ebenfalls neu hinzugekommen seit Xcode 4.2 bilden Storyboards die Grundlage
 des Interface Builders und lösen die vorhergehenden NIBs ab, bei denen
 man darauf beschränkt war, zu jedem Zeitpunkt mit je einer View zu arbeiten.
 Storyboards zeigen im Gegensatz dazu die komplette Szene an, bestehend
 aus einzelnen Views und deren Übergänge untereinander.
 Verbindungen zu anderen Views wie die Möglichkeit, diese als 
\shape italic
Delegates
\shape default
 oder als 
\shape italic
DataSource
\shape default
 zu nutzen, lassen sich realisieren, indem man ein Objekt bei gedrückter
 Steuerungs-Taste auf die gewünschte View zieht.
 Zieht man diese statt dessen in den Programmcode, werden die entsprechenden
 Codefragmente erstellt, in denen man sofort mit der Implementierung beginnen
 kann, ohne sich mit programmatischen Details zum Setzen der einzelnen GUI-Eleme
nte beschäftigen zu müssen.
 Übergänge lassen sich mit ID-Strings versehen, auf die man programmatisch
 zugreifen kann.
 So wird im Falle eines Überganges auf eine andere View die Methode 
\shape italic
prepareForSegue
\shape default
 mit dem entsprechenden String für diesen Übergang aufgerufen.
 In dieser lassen sich Vorbereitungen für die neue Ansicht treffen - wie
 z.
 B.
 Daten und Referenzen übergeben - bevor diese dann geladen wird.
 Im Utility-Bereich kann praktisch jede Eigenschaft bearbeitet werden, mit
 der das Erscheinungsbild beeinflusst werden kann.
 So lässt sich ein Objekt inaktiv darstellen bzw.
 komplett verstecken oder man ändert die Schriftart eines Textfeldes.
 Um ein Objekt einem Container unterzuordnen lässt sich das unkompliziert
 per Drag and Drop realisieren.
 Zieht man beispielsweise eine 
\shape italic
TextView
\shape default
 in einen 
\shape italic
ScrollView
\shape default
-Container erhält man Text, welcher sich mit einer Wischbewegung scrollen
 lässt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Storyboard.png
	lyxscale 45
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GUI-Entwurf im Storyboard
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Entwicklerlizenz: Testen auf echter Hardware
\end_layout

\begin_layout Standard
Grundsätzlich lässt sich eine App auch ohne Lizenz entwickeln und auf dem
 eingebauten iOS Simulator des seit der Version 4.1 für jedermann verfügbaren
 Xcode testen.
 Möchte man jedoch die App auf einem “echten” Gerät zur Ausführung bringen
 oder sie später einmal in den App Store stellen, so benötigt man eine Entwickle
rlizenz von Apple.
 Diese kostet derzeit 99 USD bzw.
 80 EUR und ist für exakt ein Jahr gültig.
 Mit einem Entwickleraccount hat man Zugriff auf iTunes Connect, mit dem
 sich der eigene Account, die verfügbaren iOS-Geräte sowie die eingestellten
 Apps verwalten lassen.
\end_layout

\begin_layout Standard
In einem ersten Schritt werden dort die User angelegt, welche an der Entwicklung
 und Distribution der Software beteiligt sind.
 Es stehen die vordefinierten Rollen 
\shape italic
Admin
\shape default
, 
\shape italic
Technical
\shape default
, 
\shape italic
Finance
\shape default
 sowie 
\shape italic
Sales
\shape default
 zur Verfügung.
 Während der 
\shape italic
Technical
\shape default
 ausschließlich Rechte für die Verwaltung der Apps bekommt, stehen dem 
\shape italic
Finance
\shape default
 weitergehend verschiedene Rechte im Bereich Finanzwesen, Analyse und Vertrieb
 bereit, die der Technican in der Regel nicht benötigt.
 Auf die Verwaltung der Apps hat er hingegen nur lesenden Zugriff, so kommen
 sich die Beiden nicht in die Quere.
 Der Rolle 
\shape italic
Sales
\shape default
 stehen lediglich Verkauf und Verkaufsanalyse offen.
\end_layout

\begin_layout Standard
Abhängig vom Vertriebsmodell müssen in iTunes Connect weitere Angaben gemacht
 werden.
 Für unentgeltliche Apps ist es weder notwendig, einen Vertrag zu akzeptieren,
 noch müssen Bankdaten hinterlegt werden.
 Für weniger selbstlose Anwendungen stehen die Vertragstypen 
\shape italic
iOS Paid Applications
\shape default
 sowie das auf in-App-Werbung spezialisierte 
\shape italic
iAd Network
\shape default
 zur Verfügung.
 Hier sind entsprechend Vertragsbedingungen zu akzeptieren, Kontaktinformationen
 anzugeben, Landesangaben zur Versteuerung zu machen und die Bankdaten für
 den erwarteten Zahlungsverkehr zu hinterlegen.
 Um eine App direkt auf dem Gerät ausführen zu können, wird ein 
\shape italic
Development Certificate
\shape default
 benötigt.
 Das hinzuzufügende Gerät wird an den Mac angeschlossen und im Organizer
 der Entwicklerlizenz zugeordnet.
 Beim ersten Mal meldet Xcode, dass kein 
\shape italic
iOS Development Certificate
\shape default
 vorhanden ist und bietet an, eine solche von Apple anzufordern.
 Anschließend fügt er diesen automatisch der Schlüsselverwaltung hinzu und
 bietet an, das Entwicklerprofil für den Einsatz auf anderen Macs zu exportieren.
 In den 
\shape italic
Build Settings
\shape default
 unserer App stellen wir nun die 
\shape italic
Code Signing Identity
\shape default
 auf das neu erzeugte Zertifikat um und sind nun in der Lage, das angeschlossene
 iOS-Gerät anstelle des Simulators für die Entwicklung zu nutzen.
 
\end_layout

\begin_layout Section
Distributionsalternative: Der Cydia Store
\end_layout

\begin_layout Standard
Zum offiziellen Vertriebsweg über den Apple App Store gibt es eine Alternative,
 über die jedoch nur freigeschaltete “gejailbreakte” Geräte Zugriff haben:
 Der Cydia Store wird in der Regel bei einem Jailbreak gleich mitinstalliert.
 Mit diesem kann man sich, wie unter Linux-Systemen bekannt, mit APT-kompatiblen
 Repositorien verbinden und auf deren Angebot zugreifen.
 Der Cydia Store ist hierbei nicht als Distributionssystem für raubkopierte
 Software zu verstehen, denn auch er verfügt wie der App Store über ein
 Bezahlsystem, mit dem Entwickler ihre Anwendungen entgeltlich anbieten
 können.
 Interessant wird diese Vertriebsmethode, wenn man eine App entwickeln möchte,
 welche die von Apple eingeräumten Rechte überschreitet.
 Ein Beispiel für eine solche Anwendung ist der Fenstermanager Quasar, der
 eine Alternative zu Apples Einzelanwendungsmodus bietet.
 Vor allem auf iPads mit Retina-Auflösung kann es durchaus eine wünschenswerte
 Option sein, zwei oder mehr Fenster nebeneinander betreiben zu können.
 So könnte man beispielsweise auf der einen Seite ein Textverarbeitungsprogramm
 geöffnet haben, während auf der anderen Bildschirmhälfte ein Internetbrowser
 geöffnet ist.
 Um kompilierte Apps in ein DEB-Paket umzuwandeln – wofür nach wie vor eine
 Entwicklerlizenz benötigt wird – benötigt man das Paket dpkg.
 Dieses kann man sich beispielsweise mit dem Programm MacPorts
\begin_inset Foot
status open

\begin_layout Plain Layout
Projektpage: http://www.macports.org
\end_layout

\end_inset

 installieren, welches ähnlich Fink eine Paketverwaltung für freie und quelloffe
ne Software für OS X ist.
\end_layout

\begin_layout Standard
Da sich dieses Programm nach 
\shape italic
/opt/local/bin
\shape default
 installiert, fügen wir dieses Verzeichnis mit 
\family typewriter
\size footnotesize
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
\family default
\size default
 unserem Pfad hinzu.
 Der Befehl 
\family typewriter
\size footnotesize
sudo port selfupdate && sudo port install dpkg
\family default
\size default
 führt ein Paketquellen-Update durch und installiert das gewünschte Paketes
 dpkg.
 Mit diesem sind wir nun in der Lage, aus den fertigen Apps Cydia-Repository-kon
forme DEB-Pakete zu erstellen.
\end_layout

\begin_layout Standard
Zum Konvertieren in ein DEB-Paket besteht dpkg-deb jedoch auf eine Struktur,
 welche sich wie folgt aufbaut:
\end_layout

\begin_layout LyX-Code

\size footnotesize
+- MyProgram
\end_layout

\begin_layout LyX-Code

\size footnotesize
   +- Applications
\end_layout

\begin_layout LyX-Code

\size footnotesize
   |  +- MyProgram.app
\end_layout

\begin_layout LyX-Code

\size footnotesize
   |     +- Info.plist
\end_layout

\begin_layout LyX-Code

\size footnotesize
   |     +- MyProgram
\end_layout

\begin_layout LyX-Code

\size footnotesize
   |     +- icon.png
\end_layout

\begin_layout LyX-Code

\size footnotesize
   +- DEBIAN
\end_layout

\begin_layout LyX-Code

\size footnotesize
   |  +- control
\end_layout

\begin_layout LyX-Code

\size footnotesize
   +- System
\end_layout

\begin_layout LyX-Code

\size footnotesize
      +- Library
\end_layout

\begin_layout LyX-Code

\size footnotesize
         +- LaunchDaemons
\end_layout

\begin_layout LyX-Code

\size footnotesize
            +- com.identifier.MyProgram.plist
\end_layout

\begin_layout Standard
Das Verzeichnis System ist hierbei optional.
\end_layout

\begin_layout Standard
Die Datei control kann folgende Einträge beinhalten: Package, Name, Version,
 Architecture, Description, Homepage, Depiction, Maintainer, Author, Sponsor,
 Section.
 Zwingend vorgeschrieben sind davon jedoch nur Package und Version.
\end_layout

\begin_layout Standard
Darüber hinaus erstellt OS X, wenn TAR-Dateien erzeugt werden – die ein
 Teil der internen Struktur eines Debian-Paketes darstellen – einige Dateien
 mit der Endung _*, welche zusätzliche Informationen enthalten.
 Diese zusätzlichen Dateien würden zusammen mit dem erzeugten Paket installiert
 werden.
 Davon abgesehen, dass diese Dateien sowieso nicht zum Paket gehören, könnten
 Sie auf dem Zielsystem Konflikte mit anderen Paketen erzeugen.
 Um dieses Feature zu deaktivieren werden durch 
\family typewriter
\size footnotesize
export COPYFILE_DISABLE && export COPY_EXTENDED_ATTRIBUTES_DISABLE
\family default
\size default
 die erforderlichen Umgebungsvariablen exportiert.
 Abschließend lässt sich im Verzeichnis 
\shape italic
MyProgramm
\shape default
 durch 
\family typewriter
\size footnotesize
dpkg-deb -b MyProgram
\family default
\size default
 das DEB-Paket erzeugen.
\end_layout

\begin_layout Subsubsection
Vom DEB-Paket aufs Device
\end_layout

\begin_layout Standard
Um die nun fertige DEB-Datei auf das iPad zu bekommen, wird ein Cydia-kompatible
s Repositorium benötigt.
 Hierfür kann zum Beispiel auf das kostenlose Angebot von 
\shape italic
MyRepoSpace
\shape default
 zurückgegriffen werden.
 Über ein Webinterface können die Pakete hochgeladen werden, anschließend
 sind sie in Cydia über das Repositorium 
\shape italic
http://cydia.myrepospace.com/Username/
\shape default
 zugreifbar.
\end_layout

\begin_layout Chapter
Schnittstelle mit der REST-Welt
\end_layout

\begin_layout Section
RESTful Webservices
\end_layout

\begin_layout Subsection
Begriffseinführung
\end_layout

\begin_layout Standard
Wikipedia definiert den Begriff 
\shape italic
Webservice
\shape default
 als 
\begin_inset Quotes eld
\end_inset

eine Methode der Kommunikation zwischen zwei elektronischen Geräten über
 das Internet
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Wikipedia - Webservice"

\end_inset

.
 Man verbindet mit diesem Begriff primär Akronyme wie SOAP (Simple Object
 Access Protocol) - ein Netzwerkprotokoll für den Transfer von Daten und
 RPCs (Remote Procedure Calls) - oder den einfacheren XML-RPC.
 Diese Webservices arbeiten, wie der Name bereits ausdrückt, mit HTTP POST-Reque
sts, um auf einem meist entfernten Computer eine Methode aufzurufen.
 Die Kommunikationssprache ist die XML-basierte 
\shape italic
Webservices Description Language
\shape default
 oder kurz WSDL.
\end_layout

\begin_layout Standard
Im Jahr 2000 führte Roy Fielding, einer der Autoren der HTTP-Spezifikationen
 1.0 und 1.1 und Mitbegründer des Apache HTTP Projektes, in seiner Dissertation
 
\shape italic
Architectural Styles and the Design of Network-based Software Architectures
\shape default
 den Begriff 
\shape italic
REpresentational State Transfer
\shape default
 ein und definierte ihn als einen “Architekturstil für verteilte hypermediale
 Systeme, der die Richtlinien für die Softwareentwicklung spezifiziert,
 welche sowohl REST selbst leiten als auch die Interaktionsvoraussetzungen,
 die so gewählt werden, dass sie diesen Richtlinien entsprechen
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Dissertation Fielding"

\end_inset

.
 Die REST-Architektur ist also ein Modell, das spezifiziert, wie das Internet
 - das im Grunde bereits eine riesige REST-Anwendung darstellt - eigentlich
 funktionieren sollte.
 Fielding bezeichnet REST als eine hybride Architektur, die von vielen verschied
enen Netzwerk basierten Architekturstilen abgeleitet ist und bezeichnet
 Seiten, die mit der Architektur REST kompatibel ist, als 
\shape italic
RESTful
\shape default
.
\end_layout

\begin_layout Standard
Den Kern dieses Architekturmodells bilden so genannte Ressourcen, weswegen
 es auch gerne als Ressource-oriented Architecture bezeichnet wird.
 Alles, was sich eindeutig identifizieren lässt, ist eine Ressource und
 sollte über eine statische Adresse zugreifbar gemacht werden.
 Neben Dateien und Verzeichnissen sind auch ausführbare Methoden, die Datenbanka
nfragen auslösen, gebräuchliche Ressourcen.
 Hervorragende Kandidaten stellen auch die Entitäten in einem Datenmodell:
 Für einen Onlineshop bieten sich die Entitäten Artikel, Kunde und Bestellung
 an, aber auch 
\shape italic
Bestellungen des Kunden mit der ID 42 aus Jahr 2010
\shape default
 kann eine valide Ressource sein und sollte ebenfalls eine möglichst langlebige
 und stabile URL erhalten.
 Ist man sich bei der Wahl der Ressourcen nicht ganz sicher so gilt: Im
 Zweifel besser zu viele Ressourcen als zu wenige.
 
\end_layout

\begin_layout Subsection
Richtlinien
\end_layout

\begin_layout Standard
HTTP bringt bereits ressourcenbezogenes Caching mit sich, wodurch man das
 Gefühl bekommt, mit einer REST-Anwendung im Internet bereits irgendwie
 “zu Hause zu sein”.
 Viele Onlineshops, Suchmaschinen oder Buchungssysteme sind, auch ohne,
 dass sie gezielt darauf abzielen, bereits RESTful.
 Damit eine Anwendung das HTTP jedoch auch tatsächlich REST-konform nutzt,
 hat sie sich an die Richtlinien zu halten, wie sie Fielding in seiner Arbeit
 beschreibt.
 Diese Richtlinien lassen sich wie folgt untergliedern, wobei es den einzelnen
 Diensten obliegt, wie diese implementiert werden.
\end_layout

\begin_layout Subsubsection
Adressierbarkeit
\end_layout

\begin_layout Standard
SOAP Webservices wie auch viele HTML-Seiten bilden ihre Funktionalität auf
 eine einzelne URL ab.
 Das sieht zwar in der Adresszeile sauber aus, bringt jedoch Nachteile mit
 sich.
 Weder lassen sich gezielt Inhalte als Lesezeichen ablegen, noch kann man
 mal eben dem Freund einen Link auf ein Produkt zusenden und auch Suchmaschinen
 haben es hier schwer, denn auch diese benötigen zum direkten Zugriff auf
 Unterbereiche einen konkreten Zugriffspfad.
 RESTful gestaltete Anwendungen bieten die geforderte Adressierbarkeit,
 ohne dass Einschränkungen in Kauf genommen werden müssen.
 Durch die Verwendung einer Firewall beispielsweise ist es ohne Weiteres
 möglich, gezielten Zugriff auf eine Ressource zu unterbinden.
 Natürlich ließe sich das URL-Prinzip ebenfalls auf SOAP anwenden, aber
 sobald diese dereferenziert werden, bewegen wir uns wieder in der REST-Welt.
\end_layout

\begin_layout Subsubsection
Unterschiedliche Repräsentationen
\end_layout

\begin_layout Standard
Von den hinter einer URL bereitgestellten Diensten lassen sich unterschiedliche
 Darstellungen anfordern.
 Diese bezeichnet man als die Repräsentation dieser Ressource.
 Über die im HTTP-Protokoll enthaltenen 
\shape italic
Accept
\shape default
- und 
\shape italic
Content-Type
\shape default
-Header unterstützt das Internet ebenfalls bereits die 
\shape italic
Content Negotiation
\shape default
, mit der sich unterschiedliche Repräsentationen ein- und derselben Ressource
 anzeigen lassen.
 Hierbei dürfen sich die Clients das Format anfordern, welches am ehesten
 ihren Bedürfnissen entspricht: Ein Browser zeigt sich meist mit einer HTML-Repr
äsentation zufrieden, während andere Client - wie der in dieser Arbeit vorgestel
lte - ist eher an der XML- oder an der JSON-Repräsentation interessiert.
 Darüber hinaus lassen sich sogar Versionswünsche über die Content Negotiation
 realisieren und beispielsweise der gewünschte Content nach Belieben in
 XML 1.1 oder in XML 1.2 geliefert werden.
\end_layout

\begin_layout Subsubsection
Zustandslosigkeit
\end_layout

\begin_layout Standard
REST ist konzeptuell ein zustandsloses Protokoll, somit ist auch jeder RESTful
 Webservice zustandslos.
 Weder Server noch der Webservice behalten sich den aktuellen Stand ihres
 Dialoges.
 Jede Nachricht muss stets alle Informationen beinhalten, die erforderlich
 sind, diese Nachricht korrekt zu interpretieren und die Anfrage ordnungsgemäß
 verarbeiten zu können.
 Da sich weder Server noch Client einen Zustand behalten, bezeichnet man
 das Kommunikationsprotokoll einer REST-konformen Architektur als zustandslos.
 Durch die Abgeschlossenheit der einzelnen Nachrichten lassen sich darüber
 hinaus Lasten sehr leicht auf mehrere Maschinen verteilen, was sich positiv
 auf die Skalierbarkeit des Webservice auswirkt.
 In der Praxis wird jedoch auch gerne auf Cookies und andere Techniken zurückgeg
riffen, um über den Request hinaus an Zustandsinformationen gelangen.
\end_layout

\begin_layout Subsubsection
Operationen
\end_layout

\begin_layout Standard
Damit RESTful gestaltete Webservices miteinander kommunizieren können muss
 eine gemeinsame Sprache gesprochen werden.
 Das HTTP-Protokoll kennt unter anderem die Optionen 
\shape italic
GET
\shape default
, 
\shape italic
POST
\shape default
, 
\shape italic
PUT
\shape default
, 
\shape italic
DELETE
\shape default
, 
\shape italic
HEAD
\shape default
 und 
\shape italic
OPTIONS
\shape default
.
 Da auf jede REST-Ressource stets die gleichen Operationen angewandt werden
 sollen, definiert dieser Methodensatz gleichzeitig die vom REST-Architekturstil
 geforderten wohldefinierten Operationen.
 Durch die Verwendung dieser elementaren Webtechniken wird die Integration
 und Interaktion der beteiligten Softwarekomponenten deutlich vereinfacht.
\end_layout

\begin_layout Standard
Die 
\shape italic
GET
\shape default
-Methode hat hierbei sicher zu sein: Es darf nur gelesen werden, so dass
 der Client jederzeit bedenkenlos ein 
\shape italic
GET
\shape default
 auf eine Ressource anwenden darf.
 Weiterhin diktiert die HTTP-Spezifikation die idempotente Implementierung
 von 
\shape italic
GET
\shape default
, 
\shape italic
PUT
\shape default
 und 
\shape italic
DELETE
\shape default
.
 Wird eine dieser Operationen mehrfach ausgeführt, wird stets das gleiche
 Ergebnis erwartet.
 Ist sich der Client unsicher, ob sein Request erfolgreich abgearbeitet
 wurde, sollte er ihn wiederholen dürfen, ohne dass Seiteneffekte erwartet
 werden.
 
\shape italic
HEAD
\shape default
 und 
\shape italic
OPTIONS
\shape default
 finden in REST eher selten Verwendung.
 Die REST-konforme Verwendung der Methoden in einem kurzen Überblick:
\end_layout

\begin_layout Description
GET fordert die Repräsentation der Ressource vom Server an.
\end_layout

\begin_layout Description
POST fügt eine neue Unterressource zur angegebenen Ressource ein.
 Da die Unterressource vorher noch nicht existierte, wird die URL zu dieser
 vom Server erzeugt und dem Clienten in der Response zurückgeliefert.
 Über diese Verwendung hinaus kann POST auch für Operationen verwendet werden,
 die sonst von keiner anderen Methode abgedeckt werden.
\end_layout

\begin_layout Description
PUT legt die ihr enthaltenen Ressource an.
 Existiert sie bereits wird sie wie im Body angegeben abgeändert.
\end_layout

\begin_layout Description
DELETE entfernt die angegebene Ressource.
\end_layout

\begin_layout Description
HEAD fragt die Metadaten einer Ressource ab.
\end_layout

\begin_layout Description
OPTIONS bringt in Erfahrung, welche Methoden auf eine Ressource angewendet
 werden dürfen.
\end_layout

\begin_layout Standard
Clientseitig sollte das folgende Protokoll anwendbar sein:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@protocol Resource
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSURLResponse)get
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSURLResponse)post:(NSURLRequest *)request
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSURLResponse)put:(NSURLRequest *)request
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSURLResponse)delete
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSURLResponse)head
\end_layout

\begin_layout LyX-Code

\size footnotesize
@end
\end_layout

\begin_layout Standard
Die (vereinfachte) Implementierung der Anlage eines Kundenkontos im Server
 kann in etwa wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@interface Customers : NSObject <Resource> {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   NSURL *resource;
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size footnotesize
@implementation Customers {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
   (NSURLResponse)post:(NSURLRequest *)request {
\end_layout

\begin_layout LyX-Code

\size footnotesize
      NSInteger customerId = [self createCustomer:request];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
      return [initWithURL:newResource
\end_layout

\begin_layout LyX-Code

\size footnotesize
               statusCode:201
\end_layout

\begin_layout LyX-Code

\size footnotesize
              HTTPVersion:@
\begin_inset Quotes erd
\end_inset

HTTP/1.1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
             headerFields:headerFields];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   }
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Subsubsection
Hypermedia
\end_layout

\begin_layout Standard
Das Kofferwort 
\shape italic
Hypermedia
\shape default
 ist eine Zusammensetzung aus den Begriffen 
\shape italic
Hypertext
\shape default
 und 
\shape italic
Multimedia
\shape default
 und weist auf die Verwendung von Hypertext mit starkem Akzent auf den multimedi
alen Gesichtspunkt hin.
 Repräsentationen enthalten in der Regel neben Informationen selbst wieder
 Links zu anderen Ressourcen.
 Das macht das Internet zu dem, was es ist: Eine stark vernetzte Verbindungsstru
ktur von identifizierbaren Ressourcen über hypermediale Links auf andere
 identifizierbare Ressourcen.
 Die standardisierte Adressierung sorgt dafür, dass sich die verlinkte Ressource
 in einem anderen Prozess im gleichen System oder auf einem anderen Rechner
 befinden kann, ganz gleich ob sich dieser im lokalen Netzwerk befindet,
 an einem beliebigen anderen Ort dieses Planeten oder auf einer Raumstation.
 Hierfür wird auch gerne der Ausdruck Verbindungshaftigkeit verwendet.
 Im Optimalfall werden dem Clienten in der angeforderten Repräsentation
 gleich die nächsten möglichen Übergänge als hypermediale Links mitgeteilt.
 Der Wert einer Anwendung ist proportional zur Anzahl der Ressourcen, auf
 die sie verlinkt.
 Mit einem Link auf einen REST-konform konzipierten Webservice eines Telekommuni
kationsunternehmens würden mit wenigen Klicks Millionen von Kundendaten
 zugreifbar gemacht werden.
 Diese könnten von der Anwendung selbst ausgewertet oder dem Endanwender
 zur Weiterverarbeitung überlassen werden.
\end_layout

\begin_layout Subsection
Beispiel
\end_layout

\begin_layout Standard
Wie so oft lässt sich das Prinzip von REST am Besten an einem Bespiel zeigen.
 Wir betrachten die Schnittstelle für den fiktiven Onlineshop smartphoneseppel.de.
 Ein Neukunde möchte sich ein Smartphone bestellen und legt sich zu diesem
 Zweck ein Kundenkonto an.
 Er wechselt auf die Seite des Onlineshops mit 
\family typewriter
\size footnotesize
GET http://www.smartphoneseppel.de
\family default
\size default
 und teilt dem Server des Onlineshops mit einem 
\shape italic
POST /customer
\shape default
 seine Registrierungsabsicht mit.
 Im Requestbody stehen seine Daten, die er für die Registrierung angegeben
 hat.
 Der Server bestätigt mit der Response
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 200 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml;
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Length: 44
\end_layout

\begin_layout LyX-Code

\size footnotesize
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
http://www.smartphoneseppel.de/customer/1337
\end_layout

\begin_layout Standard
die erfolgreiche Anlage des Kundenkontos und teilt die vergebene Kundennummer
 mit.
 Die Bestandteile einer HTTP-Response sind stets der Statuscode - an dieser
 Stelle weist der Statuscode 
\shape italic
201 CREATED
\shape default
 darauf hin, dass eine neue Ressource angelegt wurde -, die Art des zurückgelief
erten Contents sowie der Content selbst.
 Nun kann sich der Kunde mit 
\family typewriter
\size footnotesize
GET /customer/1337
\family default
\size default
 sein Kundenkonto anzeigen lassen.
 Eine Änderung ist mit einem 
\family typewriter
\size footnotesize
PUT /customer/1337
\family default
\size default
 möglich.
 Möchte er sich den Artikel Samsung Galaxy S3 anzeigen lassen, kann er das
 per 
\family typewriter
\size footnotesize
GET /article/galaxy_s3
\family default
\size default
.
 Angenommen es gefällt ihm, so packt er es sich mit einem 
\family typewriter
\size footnotesize
PUT /shoppingcart/1337&article=galaxy_s3
\family default
\size default
 in seinen Warenkorb.
 Zur Sicherheit überprüft er nun dessen Inhalt mit 
\family typewriter
\size footnotesize
GET /shoppingcart/1337
\family default
\size default
.
 Die Antwort des Onlineshops könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 200 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml
\end_layout

\begin_layout LyX-Code

\size footnotesize
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0"?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<shoppingcart xmlns:xlink="http://www.w3.org/1999/xlink">
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <customer xlink:href="http://www.smartphoneseppel.de/customer/1337">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1337
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </customer>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <position pos="1" amount="1">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    <article xlink:href="http://www.smartphoneseppel.de/article="galaxy_s3"
\end_layout

\begin_layout LyX-Code

\size footnotesize
       article="galaxy_s3">
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Samsung Galaxy S3</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
    </article>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </position>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</shoppingcart>
\end_layout

\begin_layout Standard
Kunde 1337 ist mit dem Ergebnis einverstanden und sendet mit 
\family typewriter
\size footnotesize
POST /shoppingcart/1337
\family default
\size default
 seine Bestellung ab.
 Der Server quittiert ihm dies mit einem 
\family typewriter
\size footnotesize
/shoppingcart/1337/open
\family default
\size default
, was auf den offenen Bestellstatus hinweist.
 Nun erscheint jedoch unerwartet das iPhone 5 und der Kunde überlegt es
 sich anders.
 Er überprüft mit einem 
\family typewriter
\size footnotesize
GET /customer/1337/orders
\family default
\size default
 seinen Bestellstatus und er hat Glück, denn die Bestellung wurde noch nicht
 versendet.
 Er storniert seine noch offene Bestellung mit 
\family typewriter
\size footnotesize
DELETE /customer/1337/orders/open/2012-09-11_001
\family default
\size default
 und legt sich statt dessen mit 
\family typewriter
\size footnotesize
PUT /shoppingcart/1337&article=iphone_5
\family default
\size default
 den neuen Artikel in seinen Korb.
\end_layout

\begin_layout Standard
Der Onlineshop seinerseits entfernt nach dem Release des iPhone 5 mit 
\family typewriter
\size footnotesize
DELETE /article/iphone_4s
\family default
\size default
 das iPhone 4S aus seinem System und legt mit 
\family typewriter
\size footnotesize
PUT /article
\family default
\size default
 das neue Modell an.
 Der Body könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<articles>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <name>iPhone 5</name>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <description>Das beste iPhone, das es je gab.</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <size>64</size>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <weight>140</weight>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <price>849</price>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</articles>
\end_layout

\begin_layout Standard
Er sendet Kunde 1337 das gewünschte iPhone 5 und verschiebt seine Bestellung
 vom Status offen nach versendet mit 
\family typewriter
\size footnotesize
DELETE /customer/1337/orders/open/2012-09-12_001
\family default
\size default
 und 
\family typewriter
\size footnotesize
POST /customer/1337/orders/shipped/2012-09-12_001
\family default
\size default
.
\end_layout

\begin_layout Section
XML
\end_layout

\begin_layout Standard
Die Codebeispiele im vorhergehenden Kapitel zeigen bereits, dass sich hier
 zur Kommunikation eines Austauschformates bedient wird, welches sowohl
 von Menschen gelesen als auch von Maschinen unabhängig von Plattform und
 Implementierung geparst werden kann.
 XML steht für Extensible Markup Language (zu Deutsch: erweiterbare Auszeichnung
ssprache) und verwendet das - im einfachsten Fall im ASCII-Format kodierte
 - Textformat, um über eine Metasprache strukturiert Informationen verfügbar
 zu machen.
 Diese vom World Wide Web Consortium (W3C) herausgegebene Spezifikation
 ist aktuell in der 5ten Ausgabe verfügbar und ein Derivat des älteren SGML.
 In vielen Punkten ist XML sehr verwandt mit HTML, jedoch folgt XML einer
 konsequenteren Syntax.
 Das führt dazu, dass valide XML-Dokumente zuverlässig von verschiedenen
 Anwendungen gelesen werden können.
 Um die zur Formatierung verwendeten Zeichen <, >, &, " und ' in Texten
 einzubetten, greift man auf die Entitäten &lt;, &gt;, &amp;, &quot; sowie
 &apos; zurück.
 Weitere feste Entitäten gibt es nicht, jedoch lassen sich beliebig weitere
 Entitäten definieren.
\end_layout

\begin_layout Standard
Die Struktur von XML bietet einige Vorteile gegenüber anderen Austauschformaten:
 Die redundante vollständige Wiederholung des Tagnamens beim Schließen erschwert
 Fehler bei der Verschachtelung und die vergleichsweise einfache Syntax
 von XML mit seinen Element- und Attributbezeichnungen macht es Einsteigern
 leicht, gleich zu Beginn ein gutes Gefühl zu bekommen, wie man mit XML
 umzugehen hat.
 Da die volle XML-Spezifikation allerdings über einen Umfang von gut 30
 Seiten verfügt, soll an dieser Stelle nur ein kleiner Überblick über das
 Basiswissen im Umgang mit XML vermittelt werden.
\end_layout

\begin_layout Standard
Ein einfaches, wohlgeformtes XML-Dokument könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<content>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

1
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Einleitung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

2
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Die Entwicklungsumgebung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

3
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>REST</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <!-- at least chapter IMPLEMENTATION still missing -->
\end_layout

\begin_layout LyX-Code

\size footnotesize
</content>
\end_layout

\begin_layout Standard

\shape italic
Wohlgeformt
\shape default
 bedeutet im Kontext eines XML-Dokumentes, dass es sich an die offiziellen
 Regeln des W3C zur Erstellung von XML-Dokumenten hält.
 Es muss exakt ein Wurzelelement vorhanden sein, welches das gesamte Dokument
 umschließt.
 Die einzelnen Elemente sind Informationsträger, ganz gleich welcher Art,
 sie können Texte oder weitere Elemente enthalten oder eine Kombination
 aus beiden.
 Die Elementbezeichnung ist frei wählbar.
 Verfügt ein Element über einen Inhalt, so wird dieser mit einem Start-
 sowie mit einem Endelement versehen: 
\family typewriter
\size footnotesize
<tag>content</tag>
\family default
\size default
.
 Steht ein Element ohne Inhalt, so kann das Element den Ein- und den Auszeichner
 in sich vereinen: 
\family typewriter
\size footnotesize
<no_content/>
\family default
\size default
.
 In einem Einzeichner oder einem leeren Tag können Attribute enthalten sein,
 die aus einem Schlüssel/Werte-Paar bestehen.
 Mehrere gleichlautende Elemente nebeneinander sind kein Problem, mehrere
 gleichlautende Attribute in einem Element sind jedoch nicht zulässig.
 Die Verschachtelung erfolgt ebenentreu, ein Element muss also geschlossen
 werden, bevor ein Geschwisterelement beginnt oder ein Elternelement geschlossen
 wird.
 Über die Wohldefiniertheit hinaus besteht die Möglichkeit, weitere Anforderunge
n an unser Dokument zu stellen, welches sich mit einer Grammatik wie einer
 DTD (Document Type Definition) oder einem XML-Schema realisieren lässt.
 Ein Dokument, welches einen Verweis auf eine solche Grammatik enthält,
 diese auch einhält und darüber hinaus noch wohlgeformt ist, bezeichnet
 man als valid.
\end_layout

\begin_layout Section
JSON
\end_layout

\begin_layout Standard
XML ist nicht immer der ideale Weg seine Daten zu strukturieren.
 Das Tag-System bläht kleine Datenbestände schnell auf und das Ansprechen
 einzelner XML-Nodes ist nicht immer leicht.
 JSON - die Kurzform für Java Script Object Notation - ist XML sehr ähnlich
 und bietet eine leichtgewichtige Alternative.
 JSON ist ein auch vom Menschen gut lesbares Austauschformat, welches so
 konzipiert ist, dass es sich leicht erstellen und leicht parsen lässt.
 Für ein sprachenübergreifendes Austauschformat ist es natürlich sinnig,
 dass man für den Aufbau auf Strukturen zurückgreift, die gängigen Sprachen
 geläufig sind.
 Somit kommen in JSON Key/Value-Records und Arrays zum Tragen - Strukturen,
 von denen es undenkbar ist, dass man sie in einer halbwegs modernen Programmier
sprache nicht in irgendeiner Form wiederfindet.
 Ein Objekt folgt in JSON der Syntax 
\shape italic
{ String : Value }
\shape default
.
 Mehrere solcher Paare werden durch Kommata voneinander getrennt: 
\shape italic
{ String1 : Value1, String2 : Value2, ...
 }
\shape default
.
 Leerzeichen können zwischen den einzelnen JSON-Elementen der Übersichtlichkeit
 wegen beliebig gesetzt werden.
 Wie aus den meisten Programmiersprachen bekannt, kennzeichnet die eckige
 Klammer ein Array: 
\shape italic
[ Value1, Value2, Value3, ...
 ]
\shape default
.
 Ein Wert kann hierbei ein oben genanntes String/Value-Objekt sein, aber
 auch Strings, Zahlen oder die boolschen Werte true und false sind möglich.
 Darüber hinaus sind auch null und weitere Arrays zulässige Werte.
 Zeichenketten, bestehend aus 0 bis n Unicode kompatiblen Zeichen, beginnen
 und enden je mit einem Anführungszeichen und können, ebenfalls wie aus
 C und Java bekannt, Escape-Sequenzen beinhalten, beginnend mit einem Backslash.
 Diese sind im Folgenden: 
\backslash
”, 
\backslash

\backslash
 sowie 
\backslash
/ geben jeweils den Wert hinter dem 
\backslash
 aus, also “, 
\backslash
 und /.
 Hingegen steht 
\backslash
b für ein Backspace, 
\backslash
f für einen Seitenumbruch, 
\backslash
n kennzeichnet eine neue Zeile, 
\backslash
r den Zeilenrücklauf und 
\backslash
u einen horizontalen Tabulator.
 Schließlich kann man noch, beginnend mit 
\backslash
u, einen vierstelligen Zahlencode eingeben, an dessen Stelle wird dann der
 Wert an der entsprechenden Stelle der Unicodetabelle eingefügt.
 Die Zahlensyntax ist ebenfalls aus C und Java bekannt mit der Ausnahme,
 dass JSON weder die Oktal- noch die Hexadezimaldarstellung beherrscht.
 42 ist ebenso zulässig wie 1.35e-4 oder auch -3.7589E+20.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

Ein Beispiel für eine JSON-Datei: 
\end_layout

\begin_layout LyX-Code

\size footnotesize
{
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1337,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

John Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: [
\end_layout

\begin_layout LyX-Code

\size footnotesize
       [ 3456,
\end_layout

\begin_layout LyX-Code

\size footnotesize
         
\begin_inset Quotes eld
\end_inset

123-4567
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
       ], 
\begin_inset Quotes eld
\end_inset

john.doe@example.com
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
     ],
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: true
\end_layout

\begin_layout LyX-Code

\size footnotesize
  },
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1338,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

Jane Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: null,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: false
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Chapter
Implementierung
\end_layout

\begin_layout Section
Ein erster Überblick
\end_layout

\begin_layout Standard
Erstellt man ein neues Projekt, hat man verschiedene vorgefertigte Templates
 zur Auswahl.
 Die App sollte nicht mit Optionsvielfalt erschlagen und alles intuitiv
 aus einer View heraus erreichbar sein.
 Die Wahl viel auf ein einfaches 
\shape italic
Single View Application
\shape default
-Template und gegen einen 
\shape italic
NavigationController
\shape default
, der einen zentralen Navigator bereitstellt, von dem aus man die einzelnen
 Views anwählen kann.
 Erzeugt man ein Projekt, liefert Xcode bereits einige Template-Dateien,
 in denen man sofort losprogrammieren darf, dazu gehören der 
\shape italic
ViewController
\shape default
 und das 
\shape italic
MainStoryboard
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagram.png
	lyxscale 45
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Klassen als UML-Diagramm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der 
\shape italic
ViewController
\shape default
 ist hierbei die Initialisierungs-View und das zentrale Bedieninstrument
 dieser App.
 Jede View gehört in eine eigene Klasse, was somit den Klassen 
\shape italic
HeaderKeysViewController
\shape default
, 
\shape italic
ResourcesTableViewController
\shape default
 sowie 
\shape italic
LogOutputViewController
\shape default
 ihre Existenzberechtigung verleiht.
 Keine eigene View besitzt der 
\shape italic
XMLParser
\shape default
, dessen Funktionalität sich jedoch hervorragend als autonome Klasse ausgliedern
 lies.
 
\shape italic
HistoryElement
\shape default
 ist die Implementierung einer URL-History in Form einer doppelt verketteten
 linearen Liste.
\end_layout

\begin_layout Section
Hauptklasse: ViewController
\end_layout

\begin_layout Standard
Der 
\shape italic
ViewController
\shape default
 als unsere Basisklasse erbt vom Typ 
\shape italic
UIViewController
\shape default
, welche das fundamentelle View-Management-Modell für alle iOS Applikationen
 stellt.
 Seine Oberklasse 
\shape italic
UIResponder
\shape default
 definiert das Interface zum Umgang mit Events und erbt selbst direkt von
 
\shape italic
NSObject
\shape default
, der Wurzelklasse aller Objective-C-Klassen.
 Er wird uns von Xcode zu Projektbeginn bereitgestellt und fügt die Methoden
 
\shape italic
viewDidLoad
\shape default
, 
\shape italic
viewDidUnload
\shape default
 mit je einer kurzen Beschreibung ein sowie die Methode 
\shape italic
shouldAutorotateToInterfaceOrientation
\shape default
, mit der sich der Landscape Orientation-Modus ein- und ausschalten lässt.
 Letztere sorgt dafür, dass sich der Bildschirminhalt mitdreht, wenn die
 Lagesensoren des iPads ein Kippen des Gerätes erkennen.
 Aufgrund des fehlenden NavigationControllers muss jede weitere View ihr
 aus erreichbar sein.
 Die View beinhaltet mehrere Textfelder und implementiert demnach das 
\shape italic
UITextFieldDelegate
\shape default
-Protokoll.
 Dieses Protokoll definiert die darin möglichen Nachrichten, die ein Textfeld
 als Teil der Textverarbeitung an seine 
\shape italic
Delegate
\shape default
-Klasse sendet.
 In der 
\shape italic
ViewController
\shape default
 wird beispielsweise die im Protokoll enthaltene Methode 
\shape italic
textFieldShouldReturn
\shape default
 so implementiert, dass nach dem Druck der Eingabetaste auf der On Screen-Tastat
ur das Keyboard wieder vom Bildschirm ausgeblendet wird.
 Sofern das URL-Feld das gerade aktive Textfeld war wird anschließend die
 Methode go aufgerufen, was den gleichen Effekt hat wie das Berühren des
 Go-Buttons oben rechts am Bildschirm.
 Für das Textfeld, welches diese Methode aufrufen möchte, muss zwingend
 eine Delegate spezifiziert werden.
 Dazu wird im Storyboard bei gedrückter Steuerungstaste eine Verbindung
 vom URL-Textfeld zum Controller gezogen und das Outlet 
\shape italic
delegate
\shape default
 ausgewählt.
 Das Interface des entsprechenden Controllers wird automatisch um die entspreche
nde Deklaration des Protokolls erweitert.
 Der programmatische Weg wäre das manuelle Setzen der Delegate mittels 
\family typewriter
\size footnotesize
[_url setDelegate:self]
\family default
\size default
.
 Noch einmal zur Erinnerung: 
\family typewriter
\size footnotesize
url
\family default
\size default
 wird als 
\shape italic
property
\shape default
 im Interface deklariert und deshalb werden standardmäßig die Accessoren
 generiert.
 Der Zugriff auf 
\family typewriter
\size footnotesize
url
\family default
\size default
 über den Getter erfolgt über die Instanzvariable 
\family typewriter
\size footnotesize
_url
\family default
\size default
.
\end_layout

\begin_layout Standard
Beispielhafte Implementierung der Methode textFieldShouldReturn im ViewControlle
r:
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (BOOL)textFieldShouldReturn:(UITextField *)textField {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   [textField resignFirstResponder];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   if (textField == _url)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [self go:nil];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   else if (textField == _username)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [_password becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   else if (textField == _keyTextField)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [_valueTextField becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   else if (textField == _valueTextField)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [self addKeyValue:nil];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   return YES;
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Standard
Weitere Elemente in dieser View, die eine 
\shape italic
Delegate
\shape default
 benötigen, sind zum einen die 
\shape italic
PickerView
\shape default
 links oben, in der die zu verwendende HTTP-Methode ausgewählt wird sowie
 die 
\shape italic
TableView
\shape default
 auf der rechten Seite, in der sich Schlüssel/Werte-Tupel aufnehmen lassen.
 Diese werden bei einem PUT oder einem POST automatisch als Header hinzugefügt.
 Diese beiden Komponenten benötigen nicht nur ein Objekt, dem sie Nachrichten
 übermitteln können, die im weiteren Programmverlauf etwas anstoßen.
 Beide benötigen darüber hinaus ebenfalls ein Objekt, bei dem sie Daten
 abfragen dürfen, die sie für ihre eigene Funktion benötigen.
 Das 
\shape italic
DataSource
\shape default
-Objekt liefert als Antwort auf die im Protokoll deklarierten Nachrichten,
 die es von der 
\shape italic
PickerView
\shape default
 oder der 
\shape italic
TableView
\shape default
 empfängt, die benötigten Daten zurück.
 Oft handelt es sich dabei bei der 
\shape italic
Delegate
\shape default
 und der 
\shape italic
DataSource
\shape default
 um ein- und dasselbe Objekt, daher implementiert der 
\shape italic
ViewController
\shape default
 sowohl die 
\shape italic
Delegate
\shape default
-Protokolle 
\shape italic
UIPickerViewDelegate
\shape default
 und 
\shape italic
UITableViewDelegate
\shape default
 als auch die 
\shape italic
DataSource
\shape default
-Protokolle 
\shape italic
UIPickerViewDataSource
\shape default
 und 
\shape italic
UITableViewDataSource
\shape default
.
\end_layout

\begin_layout Standard
Auf die Anfrage der 
\shape italic
Picker
\shape default
View nach der Anzahl der Spalten reagiert das 
\shape italic
ViewController
\shape default
-Objekt mit der folgenden Methode:
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {
\end_layout

\begin_layout LyX-Code

\size footnotesize
     return 1;
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ViewController1.tiff
	lyxscale 25
	scale 25
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController nach geparster XML-Response
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ViewController2.tiff
	lyxscale 25
	scale 25
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController im Landscape-Modus
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Senden eines Requests
\end_layout

\begin_layout Standard
Beim Senden eines Requests passiert Folgendes: Im URL-Textfeld ist die Adresse
 einzugeben, zu welcher der Request gesendet werden soll; im linken oberen
 Picker wird die HTTP-Methode ausgewählt.
 Das Textfeld direkt unter dem Picker bietet die Möglichkeit, zusätzliche
 Request-Methoden aufzunehmen wie beispielsweise OPTIONS, das standardmäßig
 nicht enthalten ist.
 Soll ein PUT- oder ein POST-Request versendet werden, so wird der im Body-Berei
ch angezeigte Text des aktuell aktiven Tabs im Output-Fenster (Request/Response/
Parsed) dem Request als Body hinzugefügt.
 Dieser Textbereich ist aus diesem Grund vom Anwender bearbeitbar.
 Es sollte natürlich niemals der Parsed-Tab aktiv sein, da dieser aufbereitete
 Daten enthält und keinen gültigen JSON- oder XML-Code.
 Der angefragte Server wird diesen Text wahrscheinlich nicht interpretieren
 können.
 Nach einem PUT- oder einem POST-Request befindet sich eine Kopie des gesendeten
 Bodys im Body/Request-Tab zur eventuellen weiteren Bearbeitung und auch
 die gesendeten Request-Headers sind im Bereich Headers/Request ersichtlich.
 Der Header 
\shape italic
Content-Length
\shape default
 wurde automatisch mit der Länge der angehangenen Body-Nachricht gesetzt.
 Wurde ein beliebiger Request durchgeführt und die Response erfolgreich
 auf JSON oder XML getestet und ist das Request-Fenster bislang noch leer,
 so wird dem Anwender an dieser Stelle ein einfaches JSON- bzw.
 ein XML-Template generiert, welches er anpassen kann.
 Der Anwender hat darüber hinaus im rechten Bereich die Möglichkeit, diesen
 um weitere Headers zu erweitern.
 An dieser Stelle kann man aus der angebotenen Liste einen gebräuchlichen
 General- oder einen Request-Header auswählen, man darf jedoch auch einen
 beliebiges Header/Werte-Paar eingeben.
 Zwei gleichnamige Headers sind hier verständlicherweise ebenso wenig erlaubt,
 wie ein leeres Schlüssel- oder Wertefeld.
 Wird eine Headerzeile markiert, so wird der neue Header direkt darüber
 eingefügt und die Markierung entfernt.
 Ist keine Headerzeile markiert, so wird das neue Tupel am Ende der Liste
 eingefügt.
 Die an dieser Stelle verwendete Datenstruktur sind die beiden 
\shape italic
NSArrays
\shape default
 
\shape italic
headerKeysArray
\shape default
 sowie 
\shape italic
headerValuesArray
\shape default
, an deren Indexwert x sich der Eintrag der x-ten Reihe der einspaltigen
 Headertabelle befindet.
 Zwar wären die Zellen der 
\shape italic
TableView
\shape default
 theoretisch ebenfalls in der Lage Daten zu speichern, jedoch kommt es dann
 zu folgendem unerwarteten Programmverhalten: Als Container dient eine 
\shape italic
ScrollView
\shape default
, darin befindet sich eine 
\shape italic
TableView
\shape default
.
 Das hat den Vorteil, dass es möglich ist, mehr Daten darzustellen, als
 sichtbar sind, da sich die Tabelle einfach mit dem Finger aus dem sichtbaren
 Bereich wischen lässt.
 Bewegt man nun jedoch eine Zelle aus dem sichtbaren Bereich, existiert
 aktuell keine sichtbare Referenz mehr darauf und das System setzt den Inhalt
 auf seine 
\shape italic
Reusable
\shape default
-Liste.
 Die Daten, die in der Zelle enthalten sind, werden entfernt.
 Kommt die Zelle wieder in den sichtbaren Bereich, so werden nicht die alten
 Daten wiederhergestellt, sondern an die 
\shape italic
DataSource
\shape default
 der 
\shape italic
TableViews
\shape default
 - ein instanziiertes Objekt der Klasse HeaderKeysViewController - wird
 die Nachricht 
\shape italic
tableView:cellForRowAtIndexPath
\shape default
 gesendet, woraufhin dieser eine neue Zelle erzeugt.
 Diese würde sich den Zelleninhalt jedoch aus den aktuellen Inhalten der
 Textfelder für den HTTP Header-Input besorgen, was nicht das ist, was an
 dieser Stelle passieren sollte.
 Da gemäß MVC allerdings unterhalb der GUI die Daten in 
\shape italic
NSArrays
\shape default
 abgelegt sind, deren Index mit der Zellennummer identisch ist, kann die
 Wiederherstellung des Zelleninhaltes auf die entsprechenden Einträge der
 
\shape italic
NSArrays
\shape default
 zugreifen.
\end_layout

\begin_layout Standard
Implementierung der tableView:cellforRowAtIndexPath:
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (UITableViewCell *)tableView:(UITableView *)tableView
\end_layout

\begin_layout LyX-Code

\size footnotesize
  cellForRowAtIndexPath:(NSIndexPath *)indexPath {
\end_layout

\begin_layout LyX-Code

\size footnotesize
      static NSString *CellIdentifier = @"Cell";
\end_layout

\begin_layout LyX-Code

\size footnotesize
      UITableViewCell *cell =
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      if (cell == nil)
\end_layout

\begin_layout LyX-Code

\size footnotesize
          cell = [[UITableViewCell alloc]
\end_layout

\begin_layout LyX-Code

\size footnotesize
            initWithStyle:UITableViewCellStyleValue1
\end_layout

\begin_layout LyX-Code

\size footnotesize
          reuseIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      NSString *cellText; if ([indexPath section] == 0) cellText =
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [_generalHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      else cellText = [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [_requestHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      [[cell textLabel] setText:cellText];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      return cell;
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout Standard
Befindet sich der hinzugefügte Header in der Liste der bekannten General
 Headers, so wird er mit grüner Schrift angezeigt, ist er ein bekannter
 Request Header, erscheint seine Schrift in Blaugrün.
 Befindet sich der hinzugefügte Header weder in der General- noch in der
 Request-Header-Liste, so wird dessen Name rot gefärbt.
 Dies soll der Vermeidung von Tippfehlern dienen.
\end_layout

\begin_layout Standard
Benötigt die Seite eine 
\shape italic
HTTP Basic
\shape default
- oder eine 
\shape italic
HTTP Digest
\shape default
-Authentifizierung, erhält das View-Objekt eine 
\shape italic
Authentication Challenge
\shape default
.
 Die API stellt hierfür den Methodenaufruf 
\shape italic
connection:didReceiveAuthenticationChallenge
\shape default
 bereit, in welcher sich dieser Aufforderung angenommen werden sollte.
 Sind Authentifizierungsinformationen gegeben, so werden diese nun ausgelesen
 und dem angefragten Server übermittelt.
 Die Implementierung dieser Methode sieht wie folgt aus:
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (void)connection:(NSURLConnection *)connection
\end_layout

\begin_layout LyX-Code

\size footnotesize
  didReceiveAuthenticationChallenge:
\end_layout

\begin_layout LyX-Code

\size footnotesize
  (NSURLAuthenticationChallenge *)challenge {
\end_layout

\begin_layout LyX-Code

\size footnotesize
      if ([challenge previousFailureCount] == 0) {
\end_layout

\begin_layout LyX-Code

\size footnotesize
          NSURLCredential *credential =
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [NSURLCredential credentialWithUser:[_username text]
\end_layout

\begin_layout LyX-Code

\size footnotesize
                                     password:[_password text]
\end_layout

\begin_layout LyX-Code

\size footnotesize
                   persistence:NSURLCredentialPersistenceNone];
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [[challenge sender] useCredential:credential
\end_layout

\begin_layout LyX-Code

\size footnotesize
                 forAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size footnotesize
      } else {
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [[challenge sender] cancelAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size footnotesize
          UIAlertView *alert =
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [[UIAlertView alloc] initWithTitle:@"Error"
\end_layout

\begin_layout LyX-Code

\size footnotesize
                                     message:@"Authentication incorrect."
\end_layout

\begin_layout LyX-Code

\size footnotesize
                                    delegate:self
\end_layout

\begin_layout LyX-Code

\size footnotesize
                           cancelButtonTitle:@"Close"
\end_layout

\begin_layout LyX-Code

\size footnotesize
                           otherButtonTitles:nil];
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [alert show];
\end_layout

\begin_layout LyX-Code

\size footnotesize
          [challenge description]);
\end_layout

\begin_layout LyX-Code

\size footnotesize
      }
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Graphics
	filename Flowchart Request.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Senden eines Request
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Empfangen einer Response
\end_layout

\begin_layout Standard
Jede eingehende Response ruft die Methode 
\shape italic
connection:didReceiveResponse
\shape default
 auf.
 Hier werden die Informationstextfelder im oberen Bereich der View gesetzt,
 die Headers in den entsprechenden Bereich im Output-Feld übertragen und
 überprüft, ob der Inhaltstyp als JSON oder XML angegeben wird.
 Liegt der vom Server zurückgelieferte Statuscode unter 400 deutet das darauf
 hin, dass es auf unseren Request hin keinen Fehler gab.
 Es wird nun ein neues Historyelement erzeugt, mit der erfolgreich bearbeiteten
 URL gefüllt und der History-Queue angehangen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Flowchart Response.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eintreffen einer Response
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

Trifft eine Response ein, die neben dem Header einen Body enthält, wird
 mit diesem die Methode 
\shape italic
connection:didReceiveData
\shape default
 aufgerufen.
 Für jede Teilresponse werden die Daten mittels 
\family typewriter
\size footnotesize
[responseBodyData appendData:_bodyData]
\family default
\size default
 der statischen Variable 
\shape italic
responseBodyData
\shape default
 hinzugefügt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Flowchart BodyData.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eingehende Packages
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Die eintreffenden Pakete brachten anfangs leider ein paar Probleme mit sich,
 denn jedes Datenpaket wurde stets gleich an den Parser übergeben.
 Als erster Ansatz wurde die 
\shape italic
Content Length
\shape default
 mit der Länge des eingetroffenen Bodys verglichen und die Daten in einem
 statischen 
\shape italic
NSString
\shape default
 angesammelt, bis die Nachricht vollständig empfangen wurde.
 Leider ist nicht bei jeder Response der 
\shape italic
ContentLength
\shape default
-Header gesetzt, wodurch die vollständige Größe nicht immer im Voraus bekannt
 ist.
 Als Workaround wurde mit einer Response ein 
\shape italic
NSTimer
\shape default
 mit einer provisorischen Dauer von 3 Sekunden gestartet, welcher sich mit
 jeder eingehenden Nachricht wieder zurücksetzte.
 Lief dieser ab, so wurde das vollständige Empfangen der Nachricht angenommen
 und die Analyse der Bodydaten begonnen.
 Hier zeigte sich, dass ein gründlicherer Blick ins Referenzhandbuch einiges
 an Arbeit erspart hätte, denn wie für so vieles stellt Apple durchdachte
 automatische Methodenaufrufe bereit und einige Zeit später stieß ich auf
 die Methode 
\shape italic
connectionDidFinishLoading
\shape default
.
 Da dies natürlich ein wesentlich feinerer Ansatz ist als der Timer, wurde
 die Implementierung entsprechend abgeändert.
\end_layout

\begin_layout Standard
Anhand des ersten Bytes des Bodys wird überprüft, ob es sich um ein Bild
 handelt.
 Ist das der Fall, so wird in die 
\shape italic
ScrollView
\shape default
 programmatisch eine 
\shape italic
ImageView
\shape default
 eingebettet und das Bild darin angezeigt.
 Beim Absenden eines neuen Requests werden alle 
\shape italic
ImageViews
\shape default
 wieder aus der 
\shape italic
ScrollView
\shape default
 entfernt.
 Weist das erste Byte nicht auf ein Bild hin und wurde bereits vorher anhand
 des 
\shape italic
Content Type
\shape default
 erkannt, dass es sich um JSON- oder um XML-Code handelt, wird der Body
 an den entsprechenden Parser übergeben.
 Im Apple Foundation-Framework findet sich bereits seit OS X-Version 10.3
 der 
\shape italic
NSXMLParser
\shape default
, seit iOS 5 wurde dieses um die 
\shape italic
NSJSONSerialization
\shape default
 erweitert, welche ein 
\shape italic
NSData
\shape default
-Objekt parst und ein 
\shape italic
NSDictionary
\shape default
 zurückliefert.
 In beiden Fällen werden sowohl die Schlüssel als auch die Werte in je ein
 veränderliches 
\shape italic
NSMutableArray
\shape default
 geschrieben, da es nötig sein wird, gezielt Felder zu löschen und neue
 hinzuzufügen.
 Wurde das Parsen erfolgreich abgeschlossen, wird die rekursive Methode
 processKeys aufgerufen.
 
\shape italic
Erfolgreich
\shape default
 bedeutet im Fall des XML-Parsers, dass er nach erfolgter Durchführung ein
 
\shape italic
YES
\shape default
 zurückliefert.
 
\shape italic
NSJSONSerialization
\shape default
 definiert einen Durchlauf als 
\shape italic
erfolgreich
\shape default
, wenn das zu füllende Array nach Durchlauf des Parsers nicht leer ist.
 Die einzelnen Schlüssel/Werte-Paare werden daraufhin überprüft, ob es sich
 bei den Werten um eine Ressource handelt.
 Da es durchaus sein kann, dass ein Wert wiederum ein komplettes Array mit
 weiteren Schlüssel/Werte-Paaren beinhaltet, ist 
\shape italic
processKeys
\shape default
 so gestaltet, dass ein rekursiver Aufruf möglich ist.
 Da hierbei Schlüssel/Werte-Paare eingefügt und gelöscht werden, ist das
 Mitführen des statischen Indexes 
\shape italic
staticIndex
\shape default
 erforderlich.
 Eingefügt werden Schlüssel/Werte-Paare, wenn ein Unter-Array gefunden wird
 und deren Inhalt dem eigenen Array am aktuellen Index eingefügt wird.
 Das Schlüssel/Werte-Paar, welches das Array enthielt, hat nach dem rekursiven
 Abarbeiten keine weitere Funktion mehr und es wird entfernt, denn die darin
 enthaltenen Schlüssel/Werte-Paare wurden bereits an dessen Stelle eingefügt.
 Das Array wächst und die enthaltenen Schlüssel/Werte-Paare sind noch in
 der richtigen Reihenfolge.
\end_layout

\begin_layout Standard
Zum Vorbereiten des Validitätstests auf eine valide URL wird der String
 in einem ersten Schritt in den Typ 
\shape italic
NSURL
\shape default
 umgewandelt.
 Hierbei wird bereits intern getestet, ob die Zeichen für eine URL valid
 sind.
 Verläuft dieser Test negativ, wird ein 
\shape italic
nil
\shape default
 zurückliefert.
 Wird kein 
\shape italic
nil
\shape default
 zurückgegeben, wäre folglich der Einsatz als URL denkbar und der Anfang
 wird überprüft.
 Beginnt dieser mit http, wird er unverändert zum Validieren weitergeleitet.
 Beginnt er statt dessen mit einem Schrägstrich, wird er an die Basis-URL
 des zuletzt aufgerufenen Requests angefügt und dann ebenfalls zur Validitätsübe
rprüfung weitergereicht.
 Treffen beide Fälle nicht zu, wird ein Element auf der gleichen Verzeichniseben
e vermutet, auf der diese Response basiert.
 Aus der Request, die hierher führte, wird die höchste Verzeichnisebene
 (der Teil bis inklusive dem letzten Schrägstrich) abgefragt, um diesen
 String erweitert und wie zuvor zur Validierung weitergegeben.
\end_layout

\begin_layout Standard
Um den Test durchzuführen, wechselt die App mit 
\family typewriter
\size footnotesize
[self setValidatingState:YES]
\family default
\size default
 in einen Zustand, welcher ausschließlich der Validierung von Ressourcen
 dient.
 Es wird für jeden Ressourcenkandidaten einen asynchronen HEAD-Request abgesende
t, deren Responses unter einem anderen Gesichtspunkt betrachtet werden.
 Ein nebenbei laufender Counter führt Buch über den aktuellen Fortschritt
 und wird inkrementiert, sobald eine Ressource als valid oder als invalid
 befunden wird.
 Die endgültige Entscheidung über die Validität kann jedoch erst in der
 Methode 
\shape italic
didReceiveResponse
\shape default
 getroffen werden, welche die Antwort des Servers auswerten darf.
 Da die asynchronen Requests die Responses in willkürlicher Reihenfolge
 eintreffen lassen, kann leider nicht ohne Weiteres zugeordnet werden, für
 welchen Wert gerade eine Antwort empfangen wurde.
 Die ID der abgesendeten 
\shape italic
NSURLConnection
\shape default
 wird daher zusammen mit dem Index des zu überprüfenden Wertes in ein 
\shape italic
NSDictionary
\shape default
 gepackt.
 In der 
\shape italic
didReceiveResponse
\shape default
 kann anhand dieser ID der Indexwert aus dem Wörterbuch abgefragt werden
 und es ist wieder klar, welchem Schlüssel/Werte-Paar der empfangene Statuscode
 zuzuordnen ist.
 Ein Statuscode kleiner 400 ist auch hier positiv zu interpretieren und
 weist auf die Existenz der angefragten Resource hin.
 Der angefragte Wert wird in die 
\shape italic
NSMutableArrays
\shape default
 
\shape italic
foundResourceKeys
\shape default
 sowie 
\shape italic
foundResourceValues
\shape default
 geschrieben.
 Da ein asynchroner Request den Nachteil hat, dass die überprüften Ressourcen
 in beliebiger Reihenfolge im Zielarray landen würden, eine synchrone Überprüfun
g jedoch zu viel Zeit in Anspruch nehmen würde, wird wie folgt vorgegangen:
 Die Arrays 
\shape italic
foundResourceKeys
\shape default
 und 
\shape italic
foundResourceValues
\shape default
 werden mit der Größe der Ressourcenkandidaten angelegt und die Felder mit
 einem leeren 
\shape italic
NSString
\shape default
 initialisiert.
 Eine überprüfte Ressource, die sich im Quellarray an einem Feld mit dem
 Index y befindet, wird in das Zielarray ebenfalls an das Feld mit dem Index
 y geschrieben.
 Alle Felder der beiden Arrays, an die keine Einträge geschrieben wurden,
 enthalten weiterhin leere Strings.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Flowchart FinishReceive.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Response wurde vollständig empfangen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Nachdem keine Ressourcenkandidaten mehr auf ihre Validierung warten, lassen
 sich die 
\shape italic
NSMutableArrays
\shape default
, welche über die validen Ressourcen verfügen, bereinigen, in dem die Felder
 mit den leeren Strings kurzerhand aus dem Array entfernt werden.
 Zurück bleiben je ein Array mit Schlüsseln und eines mit den dazugehörigen
 Werten.
 Beide werden beim Berühren der Ressourcenschaltfläche - der Lupe - an die
 gerade erzeugte Instanz der Klasse 
\shape italic
ResourceTableViewController
\shape default
 übergeben.
 Was hier fast beiläufig klingt war, zumindest zeittechnisch - alles andere
 als beiläufig, da die sich öffnende TableView nach ihrer Instanziierung
 und Überreichung der Daten dennoch stets jungfräulich präsentierte.
 Die 
\shape italic
NSMutableArrays
\shape default
 schienen dort nie anzukommen.
 Wie sich herausstellte, erzeugt bereits das Storyboard nach dem Berühren
 der Übergangs-Schaltfläche eine Instanz der gewünschten View.
 Die programmatisch erzeugte Instanz war eine weitere, sich an einem anderen
 Speicherbereich befindliche Instanz, die unsichtbar im Hintergrund abläuft.
 Hier soll jedoch auf die Storyboard-Instanz zugegriffen werden.
 Um das zu bewerkstelligen, müssen die Daten an diese übergeben werden,
 nachdem der Übergang in die neue View eingeleitet wurde.
 Dies muss allerdings auch geschehen, bevor die View auf dem Bildschirm
 erscheint, was ja scheinbar zeitgleich ist.
 Um auf dieses Zeitfenster zuzugreifen, lässt sich auf diese Übergänge,
 die Xcode als 
\shape italic
Segues
\shape default
 bezeichnet, programmatisch zugreifen.
 Bei einem Übergang erhält die Ursprungs-View die Nachricht 
\shape italic
prepareForSegue:sender
\shape default
.
 Um gezielt Übergänge ansprechen zu können, lassen sich im Storyboard 
\shape italic
Identifier
\shape default
 vergeben.
 Der Identifier des gerade aktiven Überganges kann in der Implementierung
 der Methode 
\shape italic
prepareForSegue:sender
\shape default
 mit 
\family typewriter
\size footnotesize
[segue identifier]
\family default
\size default
 abgefragt werden.
\end_layout

\begin_layout LyX-Code

\size footnotesize
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
     if ([[segue identifier] isEqualToString:@"resourcesTableViewPopover"])
\end_layout

\begin_layout LyX-Code

\size footnotesize
     {
\end_layout

\begin_layout LyX-Code

\size footnotesize
        ResourcesTableViewController *resourceTableViewController =
\end_layout

\begin_layout LyX-Code

\size footnotesize
           [segue destinationViewController]; 
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setKeys:foundResourceKeys];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setValues:foundResourceValues];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setReferenceToUrl:_url];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        UIStoryboardPopoverSegue* popoverSegue =
\end_layout

\begin_layout LyX-Code

\size footnotesize
           (UIStoryboardPopoverSegue*)segue;
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setReferenceToPopoverController:
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [popoverSegue popoverController]];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setReferenceToBaseUrl:
\end_layout

\begin_layout LyX-Code

\size footnotesize
           [self urlPart:[_url text] definePart:@"baseUrl"]];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [resourceTableViewController setReferenceToHighestDir:
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [self urlPart:[_url text] definePart:@"highestDir"]];
\end_layout

\begin_layout LyX-Code

\size footnotesize
     }
\end_layout

\begin_layout LyX-Code

\size footnotesize
     else if ([[segue identifier] isEqualToString:@"logOutputViewPopover"])
\end_layout

\begin_layout LyX-Code

\size footnotesize
     {
\end_layout

\begin_layout LyX-Code

\size footnotesize
        LogOutputViewController *logOutputViewController =
\end_layout

\begin_layout LyX-Code

\size footnotesize
        [segue destinationViewController];
\end_layout

\begin_layout LyX-Code

\size footnotesize
        ...
\end_layout

\begin_layout Standard
Ein weiteres Problem war die Tatsache, dass offensichtlich zwischen iOS
 5.1 und 6 das Laden der View an unterschiedlichen Zeitpunkten erfolgt.
 Unter iOS 6 ist es ausreichend, wenn die Initialisierung des übergebenen
 Arrays in der Startmethode 
\shape italic
viewDidLoad
\shape default
 erfolgt.
 Doch während dort bei einem 
\shape italic
prepareForSegue
\shape default
 der Aufbau der View verzögert wird, bis die Methode abgearbeitet wurde,
 ist dies bei iOS 5.1 nicht der Fall.
 Die Initialisierung des übergebenen Arrays darf erst in der Initialisierungsmet
hode 
\shape italic
viewDidAppear
\shape default
 erfolgen, sonst werden alle Zellen mit 
\shape italic
nil
\shape default
 gefüllt.
 Da dieses Programm zu iOS 5.1 vollständig abwärtskompatibel sein soll, erfolgt
 die Initialisierung in der Methode 
\shape italic
viewDi
\shape default
dAppear.
\end_layout

\begin_layout Section
Hilfsklassen
\end_layout

\begin_layout Subsection
ResourceTableViewController
\end_layout

\begin_layout Standard
Die erste Hilfsklasse ist eine View vom Typ 
\shape italic
UITableViewController
\shape default
, einer Unterklasse von 
\shape italic
UIViewController
\shape default
.
 Der 
\shape italic
TableViewController
\shape default
 bietet eine View, bestehend aus einer einzigen Tabelle, deren 
\shape italic
Delegate
\shape default
 und 
\shape italic
DataSource
\shape default
 er selbst ist.
 Ihm stehen die 
\shape italic
NSArrays
\shape default
 
\shape italic
keys
\shape default
 und 
\shape italic
values
\shape default
 zur Verfügung, welche die validierten Ressourcen darstellen, die er von
 der Hauptview unmittelbar vor dem Aufbau erhalten hat und die er in die
 Zellen seiner Tabelle einfüllt.
 Da eine Berührung einer Zelle die Rückkehr zur Hauptview zur Folge haben
 soll, nachdem die Ressource in das dortige URL-Feld eingefügt wurde, benötigt
 er für seine Funktion einige Referenzen.
 Verständlicherweise wird die Referenz des URL-Feldes benötigt, auf deren
 Text er schreibend zugreift.
 Referenzen zu den 
\shape italic
NSStrings
\shape default
 
\shape italic
highestDir
\shape default
 und 
\shape italic
baseUrl
\shape default
 benötigt er, um die URLs zu vervollständigen.
 Eine Ressource 1337, welche auf 
\shape italic
http://www.smartphoneseppel.de/customer/
\shape default
 gefunden wurde, sollte auf 
\shape italic
http://www.smartphoneseppel.de/customer/1337
\shape default
 verweisen.
 Die Ressource wird an den höchsten Verzeichnispfad der Abfrage gehangen,
 welche die Ressource 1337 enthielt.
 Eine mit einem Schrägstrich beginnende Ressource 
\shape italic
/article/galaxy_s3
\shape default
 wird hingegen als absoluter Pfad interpretiert und direkt an die Base-URL
 angehangen: 
\shape italic
http://www.smartphoneseppel.de/article/galaxy_s3
\shape default
.
\end_layout

\begin_layout Standard
Eine View kann sich nicht so einfach selbst wieder schließen.
 Um das dennoch zu realisieren wurde darüber hinaus die Referenz des 
\shape italic
PopoverControllers
\shape default
 hierher übergeben.
 Der Zugriff auf diesen ermöglicht es, die View mit dem Befehl 
\family typewriter
\size footnotesize
[_referenceToPopoverController dismissPopoverAnimated:YES]
\family default
\size default
 wieder sozusagen “von unten” zu verwerfen.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ResourcesTableViewController.tiff
	lyxscale 25
	scale 25
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erkannte Ressourcen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
HeaderKeysViewController
\end_layout

\begin_layout Standard
Wie auch bei der 
\shape italic
ResourceTableViewController
\shape default
 handelt es sich hier um eine Klasse des Typs 
\shape italic
UITableViewController
\shape default
.
 Er beinhaltet eine Auflistung der für einen Request gebräuchlichen Request-Head
ers und der General-Headers und soll dem Anwender eine einfache Möglichkeit
 bieten, seine Anfrage um valide Headers zu erweitern.
 Wie zuvor werden hier die Daten der durch Berührung selektierten Zelle
 in das Header-Feld der Hauptview geschrieben und die View mittels Referenzzugri
ff auf den darunter liegenden 
\shape italic
PopoverController
\shape default
 beendet.
 Als kleines “Extra” wird die Referenz für das dem Header zugehörige Wertefeld
 übergeben, mit dessen Hilfe dieses zum 
\shape italic
FirstResponder
\shape default
 wird - nach dem Verwerfen der View hat es somit den Tastaturfokus und es
 kann sofort nach dem Selektieren des Headers mit der Eingabe des Wertes
 begonnen werden.
\end_layout

\begin_layout Subsection
XMLParser
\end_layout

\begin_layout Standard
Der Inhalt der Klasse 
\shape italic
XMLParser
\shape default
 ist nicht umfangreich, eignete sich jedoch hervorragend, um als abgeschlossene
 Funktionalität in einer eigenen Klasse ausgegliedert zu werden.
 Er wird initialisiert mit zwei leeren 
\shape italic
NSMutableArrays
\shape default
, an die sowohl Attribute als auch Elemente der geparsten XML angefügt werden.
 Attributnamen werden in Klammern gesetzt und erhalten den Elementnamen,
 dem sie zugehörig sind, vorangestellt.
 Die Bezeichnung der Keys setzt sich als Pseudocode vereinfacht wie folgt
 zusammen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
for (int i = 0; i < elementsToParse; i++) do
\end_layout

\begin_layout LyX-Code

\size footnotesize
   if actualObjectType = attribut then
\end_layout

\begin_layout LyX-Code

\size footnotesize
      keyArray[i] ← elementName + 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Quotes eld
\end_inset

 + attributName + 
\begin_inset Quotes eld
\end_inset

)
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout LyX-Code

\size footnotesize
      valueArray[i] ← AttributValue;
\end_layout

\begin_layout LyX-Code

\size footnotesize
   else if actualObjectType = element then
\end_layout

\begin_layout LyX-Code

\size footnotesize
      keyArray[i] ← elementName;
\end_layout

\begin_layout LyX-Code

\size footnotesize
      valueArray[i] ← elementValue;
\end_layout

\begin_layout LyX-Code

\size footnotesize
   fi;
\end_layout

\begin_layout LyX-Code

\size footnotesize
od;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
LogOutputViewController
\end_layout

\begin_layout Standard
Da es sich um ein Entwicklertool handelt, wäre es für den ein oder anderen
 sicherlich interessant zu sehen, was das Programm in der Kommandozeile
 an Log-Ausgabe erzeugen würde.
 Diese 
\shape italic
PopoverView
\shape default
 stellt die Ausgabe von 
\shape italic
NSLog
\shape default
 dar, welche der normale App-Anwender eigentlich gar nicht zu sehen bekäme
 und leitet sie in eine Datei um.
 Um nicht in jeder Zeile das Datum, die Uhrzeit und den Programmnamen aufzuführe
n, wurden diese zu Beginn der Hauptklasse aus der Ausgabe von 
\shape italic
NSLog
\shape default
 herausgeschnitten, indem der reine Ausgabeteil als String in UTF8-Codierung
 mittels 
\shape italic
fprintf
\shape default
 ausgegeben wird:
\end_layout

\begin_layout LyX-Code

\size footnotesize
#ifdef DEBUG
\end_layout

\begin_layout LyX-Code

\size footnotesize
#define NSLog(FORMAT, ...) fprintf(stderr,"%s
\backslash
n",
\end_layout

\begin_layout LyX-Code

\size footnotesize
[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);
\end_layout

\begin_layout LyX-Code

\size footnotesize
#endif
\end_layout

\begin_layout Standard
Weiterhin wird gleich zum Programmstart in der Methode 
\shape italic
viewDidLoad
\shape default
 die Ausgabe in eine Datei umgeleitet.
 Hierbei wird zuerst geschaut, ob bereits eine Ausgabedatei existiert.
 Ist das der Fall, so wird die Logging-Funktion automatisch eingeschaltet;
 ist sie nicht vorhanden, bleibt sie deaktiviert.
 Deaktiviert man sie während der Laufzeit, so wird die Datei ebenfalls entfernt.
 Somit findet man den Logging-Schalter bei einem App-Restart stets so vor,
 wie man ihn verlassen hat.
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSArray *paths = NSSearchPathForDirectoriesInDomains
\end_layout

\begin_layout LyX-Code

\size footnotesize
(NSDocumentDirectory, NSUserDomainMask, YES);
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSString *documentsDirectory = [paths objectAtIndex:0];
\end_layout

\begin_layout LyX-Code

\size footnotesize
logPath = [documentsDirectory stringByAppendingPathComponent:@"console.log"];
\end_layout

\begin_layout LyX-Code

\size footnotesize
NSFileManager *filemgr;
\end_layout

\begin_layout LyX-Code

\size footnotesize
filemgr = [NSFileManager defaultManager];
\end_layout

\begin_layout LyX-Code

\size footnotesize
if ([filemgr fileExistsAtPath:logPath]) {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   freopen([logPath cStringUsingEncoding:NSASCIIStringEncoding],"a+",stderr);
\end_layout

\begin_layout LyX-Code

\size footnotesize
   [_logToFileSwitch setOn:YES];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   [_logFileButton setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   [_verboseLogLabel setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size footnotesize
   [_verboseLogSwitch setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size footnotesize
} else
\end_layout

\begin_layout LyX-Code

\size footnotesize
   NSLog (@"No existing log file found, logging disabled.");
\end_layout

\begin_layout Standard
Mit dem Papierkorb unter dem Ausgabe-Fenster lässt sich die Datei nach dem
 Sichten aufräumen und das Logging dabei eingeschaltet lassen.
 An diesem Icon wurde keine Bildunterschrift angebracht, denn es sollte
 selbsterklärend sein, was hier passiert.
 Werden informationsreichere Mitschnitte gewünscht, lässt sich dieser Wunsch
 über den Verbose-Schalter mitteilen.
 Es werden dann mehr Informationen mitgeschnitten.
 Auch hier ist ein unerwartetes Problem aufgetreten: Da die View nichts
 beinhaltet, was eine 
\shape italic
Delegate
\shape default
 oder eine 
\shape italic
DataSource
\shape default
 benötigt, wollte ich diese recht codezeilenarme Funktionalität in der Hauptview
 unterbringen.
 Jedoch war nach dem Öffnen der View das Ausgabefeld stets leer, so dass
 ein Refresh-Button betätigt werden musste, der die Datei erneut in das
 Textfeld mappte.
 Erst dann wurde der Inhalt sichtbar.
 Abhilfe brachte das Auslagern in eine eigene Klasse mit der Initialisierungsmet
hode 
\shape italic
viewDidAppear
\shape default
, welche nun das Laden der Datei übernimmt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename LogOutputViewController-verbose.tiff
	lyxscale 25
	scale 25
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Logging-Output im Verbose-Modus
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
HistoryElement
\end_layout

\begin_layout Standard

\shape italic
HistoryElement
\shape default
 ist die Implementierung der URL-History in Form einer doppelt verketteten
 Liste.
 Es kennt seinen Vorgänger, seinen Nachfolger als auch die an ihn gebundene
 Ressource.
 
\shape italic
HistoryElement
\shape default
 verfügt über eine Methode 
\shape italic
getPart
\shape default
, die auf Wunsch die Basis-URL - bestehend aus Protokoll und Domain -, den
 höchsten Verzeichnispfad oder den vorherigen zurückliefert.
 Der Unterschied zwischen vorherigem und höchstem Verzeichnis ist folgender:
 Endet eine URL mit einem Schrägstrich, so wird er als Verzeichnis betrachtet
 und ist gleichzeitig das höchste Verzeichnis.
 Endet er nicht mit einem Schrägstrich, wird eine Datei vermutet und statt
 dessen das letzte Verzeichnis zurückgegeben, das mit einem Schrägstrich
 endet.
\end_layout

\begin_layout Standard
Beispiel 1: @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de/customer/1337
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
highestDir = previousDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de/customer/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Beispiel 2: @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/1337/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
highestDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/1337/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
previousDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
...
 und die AppDelegate?
\end_layout

\begin_layout Standard
Erstellt man ein neues Projekt, befindet sich im Projektordner neben den
 Controllern eine weitere Klasse: die 
\shape italic
AppDelegate
\shape default
.
 Konzeptuell sollte der 
\shape italic
ViewController
\shape default
 alles beinhalten, womit sich die aktuelle View beschäftigt.
 Die 
\shape italic
AppDelegate
\shape default
 bleibt dabei erschreckend leer und hinterlässt das Gefühl, scheinbar etwas
 Wichtiges vergessen zu haben.
 Die einzige Methode, die überhaupt etwas macht ist die application 
\shape italic
didFinishLaunchingWithOptions:launchOptions
\shape default
.
 Sie gibt ein 
\shape italic
YES
\shape default
 zurück.
 Immerhin.
\end_layout

\begin_layout Standard
Auch hier läuft wieder alles über das Storyboard.
 Wirft man einen Blick auf die Datei Projektname-Info.plist findet sich ein
 Schlüssel mit der Bezeichnung 
\shape italic
Main storyboard file base name
\shape default
 und dem Wert 
\shape italic
MainStoryboard
\shape default
.
 Die Bedeutung hinter diesem Eintrag ist die Folgende: Ist diese Einstellung
 gesetzt, lädt 
\shape italic
UIApplication
\shape default
 die Datei mit der Bezeichnung 
\shape italic
MainStoryboard.storyboard
\shape default
, instanziiert den ersten 
\shape italic
ViewController
\shape default
 und packt dessen View in ein neues Objekt des Typs 
\shape italic
UIWindow
\shape default
.
 Es ist also völlig in Ordnung, wenn diese Datei bei Benutzung von Storyboards
 leer bleibt.
\end_layout

\begin_layout Chapter
Schlusswort und Ausblick
\end_layout

\begin_layout Standard
Es ist vollbracht - die erste eigene Anwendung, geschrieben in der auf den
 ersten Blick exotisch anmutenden Programmiersprache mit den vielen eckigen
 Klammern, läuft auf dem marktbeherrschenden Tablet-Computer der Firma Apple
 Inc.
 In einem abschließenden Fazit werde ich die einzelnen Schritte auf dem
 Weg hierher als auch den persönlichen Nutzen dieser Arbeit für mich reflektiv
 umreißen und auf die sich für mich ergebende Bereitschaft eingehen, weiterhin
 in dieser Umgebung zu entwickeln.
\end_layout

\begin_layout Standard
Objective-C ist anders.
 Allerdings nicht so anders, dass man sich nicht mit ein wenig Zeit daran
 gewöhnen kann.
 Und möchte.
 Die Namenskonvention bei Objective-C ist gewöhnungsbedürftig, die Verwendung
 von scheinbar möglichst langen Variablennamen oder einer redundanten zusätzlich
en Beschreibung für jeden Parameter in einer Methode ist zu Beginn äußerst
 gewöhnungsbedürftig, steigert aber die Lesbarkeit des Codes ungemein.
 Auch an die Notation mit den eckigen Klammern gewöhnt man sich ziemlich
 schnell - wenngleich das auch nicht wirklich nötig ist, denn die Klammern
 lassen sich in den meisten Fällen mit der alternativ angebotenen Punkt-Schreibw
eise umgehen, die für die meisten Umsteiger sehr vertraut wirkt.
 Ich selbst habe mich nach einiger Eingewöhnungszeit recht schnell schon
 während meines ersten Programmes auf diese Notation umgestellt; sie führte
 mir automatisch das Konzept der Nachrichtenkommunikation vor Augen.
 Die Cocoa-API erleichtert viele programmatische Handgriffe und es lohnt
 sich stets, einen Blick in die Referenz zu werfen.
 Beispielsweise habe ich zuerst anhand der Content-Länge überprüft, wann
 eine Response vollständig eingegangen ist.
 Ein sehr einfacher Weg, leider setzt er voraus, dass die Content-Länge
 in der Response angegeben ist.
 Da dies jedoch nicht immer der Fall ist, implementierte ich einen Workaround,
 der eine eingehende Response einen 
\shape italic
NSTimer
\shape default
 starten lies, welcher sich bei jedem eingehenden Package wieder zurücksetzte.
 So sollte der Client herausfinden, ab wann eine Nachricht unbekannter Länge
 als 
\shape italic
vollständig empfangen
\shape default
 anzusehen ist.
 Ein sorgfältiger Blick in die Referenz hätte mir diesen Umstand abgenommen,
 denn dort wäre ich auf die Methode 
\shape italic
connectionDidFinishLoading
\shape default
 gestoßen, welche eine elegantere Lösung zu genau dieser Problematik bietet,
 denn deren Implementierung wird nach dem Erhalt des finalisierenden Packages
 aufgerufen.
\end_layout

\begin_layout Standard
Auch meine Erfahrungen mit Xcode waren fast durchgängig von sehr angenehmer
 Natur.
 Unter Apples Entwicklungsumgebung lässt es sich sehr angenehm arbeiten.
 Die Live-Prüfung, die eine Autokorrektur für syntaktische Fehler und Tippfehler
 anbietet und auch der Assistenzcontroller, der zur geöffneten Datei immer
 gleich passende Sekundärdateien anbietet, sind Dinge, die ich in künftigen
 Entwicklungsumgebungen nur ungern missen werde.
 Ein kleiner Wermutstropfen ist, dass Xcode nach einiger Zeit kontinuierlich
 immer langsamer wird.
 Das geht so weit, dass es eine Qual ist, den aktiven Quellcode-Tab zu wechseln,
 da man im schlimmsten Fall lange auf das drehende Rad schaut, in welches
 sich der Mauszeiger verwandelt, um den ausgelasteten Zustand der Anwendung
 zu signalisieren.
 Ein wenig Foren-Recherche ergibt schnell, dass der Schuldige die sich ansammeln
den Workspace-Einstellungen sind.
 Lässt man sich die Inhalte des Packages 
\shape italic
Projectname.xcodeproj
\shape default
 anzeigen, so findet man dort eine Datei mit der Bezeichnung 
\shape italic
project.xcworkspace
\shape default
.
 In dieser Datei speichert Xcode die Einstellungen ab.
 Nach einem Löschen dieser Datei und Neustart von Xcode sind zwar alle Workspace
-Einstellungen verschwunden, Xcode im Gegenzug aber um ein Vielfaches performant
er.
 Ein Opfer, dass man an dieser Stelle gerne zu zahlen bereit ist.
 Es könnte natürlich sein, dass es sich um einen versionsspezifischen Bug
 handelt.
 In der aktuellen Version 4.5.2 habe ich dieses Verhalten noch nicht festgestellt,
 allerdings war beim Update auf diese Version die Implementierung des REST
 Analyzer nahezu vollständig.
\end_layout

\begin_layout Standard
Das Storyboard ist eine ungemeine Arbeitserleichterung, wenn es um die Gestaltun
g der GUI geht.
 Hier findet der erste Kontakt mit Xcode statt, die ersten Zeilen Code,
 die bereits ein vollständiges GUI-Grundgerüst bilden, werden hier generiert.
 Es fühlt sich sehr einfach an und schafft es, Berührungsängste schnell
 zu nehmen.
 Mit wenig Zeitaufwand sind Views und Übergänge erstellt, GUI-Elemente eingefügt
, gegebenenfalls deren 
\shape italic
Delegates
\shape default
 und 
\shape italic
DataSources
\shape default
 zugewiesen und in der Seitenleiste die Eigenschaften gesetzt, welche die
 Elemente bei Anwendungsstart besitzen sollten.
 Automatisch werden die Bereiche im Code eingefügt und mit den Storyboard-Elemen
ten verbunden und man beginnt kurze Zeit später bereits mit der eigentlichen
 Implementierung der Funktionalitäten, ohne das Gefühl zu haben, sich vorher
 an notwendigen Nebensächlichkeiten aufhalten zu müssen.
 Selbstverständlich lässt sich auch alles ohne Storyboards entwerfen.
 Durch das Storyboard bereit gestellte Funktionalität sollte man jedoch
 nach Möglichkeit nicht mit dem programmatischen Weg vermischen.
 Es hat mich viel Zeit und Recherche gekostet, festzustellen, dass eine
 im Storyboard erstellte View nicht ohne Weiteres programmatisch zugreifbar
 ist.
 Der Weg, einem Übergang eine eindeutige Bezeichnung zu verpassen und auf
 diese über die in einem solchen Fall automatisch aufgerufene Methode 
\shape italic
prepareForSegue
\shape default
 zuzugreifen, wirkte auf mich ein wenig wie ein Workaround, ist aber wohl
 der Weg, der in einem solchen Fall zu gehen ist.
 Um der Übersichtlichkeit zu genügen bietet das Storyboard 4 Zoomstufen
 an: 12,5 %, 25 %, 50 % und 100 %.
 Warum an dieser Stelle keine manuelle Eingabe der Zoomstufe gegeben ist
 oder zumindest ein Schieberegler angeboten wird, der sich etwas feingranularer
 einstellen lässt, ist mir nicht ganz ersichtlich.
 Bei meiner nicht ungewöhnlichen Auflösung von 1920x1200 wäre oft 75 % die
 Zoomstufe meiner Wahl gewesen.
\end_layout

\begin_layout Standard
In der Wahl der Implementierungsthematik fand ich mit RESTful Webservices
 ein interessantes Umsetzungsgebiet.
 Die Umsetzung eines generischen Clients für verschiedene Webservices, deren
 Schnittstelle die Methoden bilden, die das HTTP-Protokoll schon selbst
 mitbringt, war interessant und erweiterte meine Kenntnisse der Webservices.
 Die diesem Standard zugrunde liegende Idee ist einfach und leicht zu implementi
eren und das Arbeiten mit HTTP-Verben fühlt sich 
\begin_inset Quotes eld
\end_inset

schon irgendwie nahe am Internet” an.
 In einem ersten Implementierungsansatz verwendete ich das externes Framework
 
\shape italic
RestKit
\shape default
, welches ich dafür andachte, mir die Arbeit mit REST-konformen Seiten zu
 erleichtern.
 Es stellte sich jedoch sehr schnell heraus, dass einige der Funktionen
 meine Erwartungen für einen generischen Ansatz nicht erfüllen konnten.
 So bot mir 
\shape italic
RestKit
\shape default
 das Mappen einer JSON-Ressource in ein 
\shape italic
NSDictionary
\shape default
 an, welches jedoch bereits über die Schlüssel verfügen musste, zu welchen
 anschließend die Werte hinzugefügt werden.
 Für einen generischen Clienten, der jedoch noch nicht weiß, welche Schlüssel
 die Zielressource liefern wird, ist das leider nur von eingeschränktem
 Nutzen und die Zuhilfenahme eines Parsers ist unvermeidlich.
 Apple bietet in seinem hauseigenen Framework sowohl einen Parser für XML
 als auch einen Parser für JSON an, welcher bei vergleichbarer Funktionalität
 bereits wegen der offiziellen Unterstützung durch Apple bevorzugt eingesetzt
 werden sollte.
 Auch andere Teile, die das externe Framework bereitstellen würde, waren
 ohne größere Schwierigkeiten durch ein breites Arsenal hilfreicher Funktionen
 zu realisieren, die Cocoa Touch ohnehin bereitstellt.
 Letztendlich erlaubte dies mir die Umsetzung dieser Arbeit, ohne dass ich
 auf externe Frameworks zurückgreifen musste.
\end_layout

\begin_layout Standard
Abschließend kann ich über die vergangenen Wochen, in denen ich mich mit
 dieser Arbeit beschäftigt habe, Folgendes sagen: Mein “Blick über den Tellerran
d“ in Richtung Objective-C fühlt sich befriedigend an.
 Der Exkurs wird hier noch nicht enden, denn ich möchte noch einige weitere
 Anwendungen für Apple-Hardware entwickeln.
 Die Arbeit auf und mit Apples Plattform hat sich für mich als sehr angenehm
 erwiesen und meinen Programmierstil positiv beeinflusst.
 Kurze und unverständliche Variablennamen werde ich zugunsten der Lesbarkeit
 künftig vermeiden, ebenso werde ich beim Entwickeln fernab Objective-C
 die zusätzlichen Parameter-Bezeichner in den Methoden vermissen.
 Einen ersten Kundenauftrag für eine iPhone-App habe ich bereits schon vor
 dem Abschluss dieser Arbeit angenommen.
 Xcode wird also nicht lange geschlossen bleiben und schon bald werde ich
 meinen Ausflug in die Objective-C-Welt an der Stelle weiterführen, wo ich
 ihn mit dem Abschluss dieser Arbeit unterbrochen habe.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Dissertation Fielding"

\end_inset

Fielding, Roy (2000) Dissertation: Architectural Styles and the Design of
 Network-based Software Architectures
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bayer - REST Einführung"

\end_inset

Bayer, Thomas (2002): REST Webservices: Eine Einführung, URL: http://www.oio.de/pu
blic/xml/rest-webservices.htm (letzter Aufruf am 6.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JAXenter"

\end_inset

Tilkov, Stefan (2009): REST - Der bessere Webservice? In: JAXenter, URL:
 http://it-republik.de/jaxenter/artikel/REST---Der-bessere-Web-Service-2158.html
 (letzter Aufruf am 6.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "saurik"

\end_inset

Freeman, Jay: How to Host a Cydia™ Repository, URL: http://www.saurik.com/id/7
 (letzter Aufruf am 16.11.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - Webservice"

\end_inset

Wikipedia: Web service, URL: http://en.wikipedia.org/wiki/Web_service (letzter
 Aufruf am 5.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - REST"

\end_inset

http://de.wikipedia.org/wiki/Representational_State_Transfer (letzter Aufruf
 am 5.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JSON.org - Einführung in JSON"

\end_inset

Introducing JSON, URL: http://json.org/index.html (letzter Aufruf am 15.09.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "W3C - XML Essentials"

\end_inset

XML ESSENTIALS, URL: http://www.w3.org/standards/xml/core (letzter Aufruf
 am 16.09.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "The Objective-C Programming Language"

\end_inset

https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ Objective
C/Introduction/introObjectiveC.html (letzter Aufruf am 10.10.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Learning Objective-C"

\end_inset

http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/ Learning_
Objective-C_A_Primer/_index.html (letzter Aufruf am 10.10.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Galileo Computing"

\end_inset

Rodewig, Klaus M.
 / Wagner, Clemens: Apps entwickeln für iPhone und iPad - Das Praxisbuch,
 Galileo Computing, 2012, URL: http://openbook.galileocomputing.de/apps_entwickeln
_fuer_iphone_und_ ipad/index.html (letzter Aufruf am 12.11.2012)
\end_layout

\end_body
\end_document
