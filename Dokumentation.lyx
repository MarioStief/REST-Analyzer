#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass ucthesisLyx
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Einleitung (2 - 3 Seiten)
\end_layout

\begin_layout Standard
Hier könnte ihr Text stehen...
 :-)
\end_layout

\begin_layout Chapter
Die Werkzeugkiste (8 Seiten)
\end_layout

\begin_layout Section
Basissprache: Objective-C (4 Seiten)
\end_layout

\begin_layout Standard
Möchte man seine erste App für ein Apple-Gerät entwickeln, steht man zuallererst
 vor einer kleinen Herausforderung: So wie Microsoft für sein .NET-Framework
 die C#-Sprache entwickelte, welche Grundkonzepte der objektorientierten
 Hochsprachen C++, Java und Delphi in sich vereint, wird für Apple-Hardware
 grundsätzlich die Sprache Objective-C verwendet.
 Anders als C# greift das in den frühen 80ern entwickelte ObjC auf das prozedual
e ANSI-C zurück, die objektorientierte Erweiterung ist an Smalltalk angelehnt
 und von der C-Syntax strikt getrennt.
 Die syntaktisch wichtigsten Neuerungen sind Klassen und Methodenaufrufe.
 Das gleiche Erweiterungskonzept findet auch auf andere prozeduale Sprachen
 Anwendung, so werden zum Beispiel aus Pascal und JavaScript, welche über
 kein Klassenkonzept verfügen, die um Objektorientiertheit ergänzten Sprachen
 Objective-Pascal und Objective-J.
\end_layout

\begin_layout Standard
Wie aus der C-Welt bekannt deklariert man das Interface im Header (.h) sowie
 deren Implementierungen in den .m-Dateien, welche ObjC- bzw.
 C-Code enthalten können.
 Aus Kompatibilitätsgründen kann man auch Implementierungen als mit der
 Erweiterung mm anlegen, welcher auch explizit C++-Code enthalten darf.
 Auf diese Art kann man C++-Bibliotheken weiterverwenden.
 Statt #include sollte man hier auf #import zurückgreifen, weil es sicher
 stellt, dass die angegebene Datei nie mehr als einmal eingebunden wird.
 Da das ein äußerst sinnvolles Feature ist, wird es auch von allen gängigen
 ObjC-Compilern unterstützt.
\end_layout

\begin_layout Standard
Die größte Umstellung zum Denken in Objective C ist, dass es keine Funktionen
 mehr gibt, die mit Parametern aufgerufen werden.
 Hier verwendet man Objekte, die sich untereinander Nachrichten an Methoden
 senden und so miteinander kommunizieren.
 Dieses Paradigma nennt sich 
\shape italic
Message Passings
\shape default
 und unterscheidet sich stark von der Art der Aufrufe, die C++ nutzt.
 Grundsätzlich darf jedes Objekt jede Nachricht an jedes Objekt senden -
 oder an sich selbst - ganz gleich ob die Zielklasse (oder eine deren Oberklasse
n) die passende Methode zu dieser Nachricht implementiert.
 Da die Methoden immer erst zur Laufzeit (und nicht bereits beim Kompilieren)
 ermittelt werden, entscheidet sich erst beim Aufruf, wie ein Objekt auf
 eine Nachricht reagieren wird.
 Dieses Verfahren bezeichnet man daher auch als 
\shape italic
dynamisches Binden
\shape default
 - im Gegensatz zu verwendeten C-Funktionen, die bei der Kompilierung bereits
 statisch gebunden werden.
 Es lässt sich sogar eine Klassenmethode implementieren, welche auf Nachrichten
 reagiert, für die die Klasse keine eigene Implementierung bereitstellt.
 Abstrakte Klassen kennt ObjC übrigens nicht - jede Klasse muss immer vollständi
g implementiert werden, damit stets Objekte dieser Klasse erzeugt werden
 können.
 Statt dessen können wir jedoch Protokolle deklarieren, in denen wir zwangsweise
 zu implementierende Methoden unter dem 
\family typewriter
\size small
@required
\family default
\size default
-Tag auflisten.
\end_layout

\begin_layout Standard
Ebenso wie in C++ lassen sich aus einer Klasse Objekte erzeugen.
 Darüber hinaus ist aber jede Klasse selbst als Objekt ansprechbar.
 Diese anthalten jedoch keine Member-Variablen und sind stets Singletons
 - Entwurfsmuster, die sicher stellen, dass von einer Klasse genau ein Objekt
 existiert, welches global verfügbar ist.
 So wie ein solches Klassenobjekt in der Lage ist, Nachrichten zu empfangen,
 erfolgt das Binden der entsprechenden Methoden ebenfalls erst zur Laufzeit.
 Strings werden in ObjC in der Notation @
\begin_inset Quotes erd
\end_inset

…
\begin_inset Quotes erd
\end_inset

 erzeugt.
 Dieser String ist ein Objekt vom Typ NSString und als solcher ebenfalls
 in der Lage, Nachrichten zu empfangen.
 Wird das @ weggelassen, wird ein Nullterminierter C-String erzeugt.
 Per Vorgabe besitzen die Datentypen in ObjC die gleiche Typisierung wie
 in C: Sie sind statisch, schwach und explizit.
 Für das Konzept der dynamischen Typisierung existiert der typlose Datentyp
 id, welcher einen Zeiger auf ein Objekt beliebiger Klasse repräsentiert
 und an den jede beliebige Nachricht gesendet werden kann.
 Falls der Typ des Objektes diese Methode jedoch nicht unterstützt, kommt
 es selbstverständlich zu einem Laufzeitfehler.
 Möchte man eine solche typlose Variable einer Variable mit einem Typ zuweisen,
 so müssen diese Typen natürlich übereinstimmen, sonst kommt es zu einem
 Laufzeitfehler.
\end_layout

\begin_layout LyX-Code

\size small
id typelessObject = @"I'm a string."; // OK
\end_layout

\begin_layout LyX-Code

\size small
NSString *string = typelessObject;    // OK
\end_layout

\begin_layout LyX-Code

\size small
NSNumber *integer = typelessObject;   // logischer Fehler
\end_layout

\begin_layout LyX-Code

\size small
char character = [integer charValue]; // Laufzeitfehler
\end_layout

\begin_layout LyX-Code

\size small
NSLog(@"%i",integer);
\end_layout

\begin_layout Standard
Ein Instanzobjekt einer Klasse wird erzeugt, indem eine Nachricht an das
 zugehörige Klassenobjekt gesendet wird.
 Für gewöhnlich passiert dies beim Programmstart, im Gegensatz zu C++ können
 bei ObjC jedoch auch während der Laufzeit noch neue Objekte erstellt werden.
 Aus C++/Java bekannte überladene Methoden findet man so in ObjC nicht mehr;
 eine Nachricht an eine Methode besteht aus einem 
\shape italic
Selektor
\shape default
 - dem Methodennamen - und den Parametern.
 Das Laufzeitsystem sucht bei einer eingehenden Nachricht nach einer solchen
 Methode und führt diese im Erfolgsfall aus.
 Wird keine entsprechende Methode gefunden, wird ein 
\shape italic
nil
\shape default
 zurückgegeben.
 Es besteht natürlich auch die Möglichkeit, ein Objekt vorher zu fragen,
 ob eine bestimmte Nachricht verstanden wird.
 Diese Fähigeit der Selbstkenntnis beinhaltet ebenfalls das Ermitteln der
 eigenen Klasse oder das Wissen, ob seine Klasse eine Unterklasse einer
 bestimmten anderen Klasse ist und nennt sich Reflexion und sollte dem ein
 oder anderen ebenfalls aus der C++/Java-Welt bekannt sein.
\end_layout

\begin_layout LyX-Code

\size small
if([geometricFigure respondsToSelector:@selector(getShape)]) { ...
 }
\end_layout

\begin_layout Standard
Dem Smalltalk-Erweiterungsanteil verdankt ObjC die verwendete Notation mit
 eckigen Klammern, um Nachrichten zu versenden.
 Zuerst wird das Empfängerobjekt genannt, anschließend der Selektor und
 ggfls.
 der Parameter.
 Sind Sender und Empfänger der Nachricht das gleiche Objekt, verwendet man
 den Bezeichner 
\family typewriter
\size small
self
\family default
\size default
.
\end_layout

\begin_layout LyX-Code

\size small
// somewhere lost in code:
\end_layout

\begin_layout LyX-Code

\size small
NSInteger age = [self computeAgeFromYear:1981 withMonth:5 andDay:23]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
// method declaration:
\end_layout

\begin_layout LyX-Code

\size small
- (NSInteger)computeAgeFromYear:(NSInteger)birthyear
\end_layout

\begin_layout LyX-Code

\size small
                      withMonth:(NSInteger)month
\end_layout

\begin_layout LyX-Code

\size small
                         andDay:(NSInteger)day { ...
 }
\end_layout

\begin_layout Standard
Diese Schreibweise ist für jemanden, der aus der C++/Java-Welt kommt äußerst
 gewöhnungsbedürftig, da hier jeder Parameter eine explizite Benennung erfordert
 und Methodennamen können in ObjC durchaus sehr lang werden.
 Hat man sich jedoch einmal daran gewöhnt, möchte man dies jedoch nur schwer
 wieder missen wollen, fördert es die Lesbarkeit und Verständlichkeit des
 Codes ungemein.
 Die angegebene Methode bezeichnet man vollständig in der Form: 
\family typewriter
\size small
computeAgeFromYear:withMonth:andDay
\family default
\size default
.
\end_layout

\begin_layout Standard
Das Minus-Präfix zu Beginn der oben stehenden Methode zeigt auf, dass es
 sich hierbei um eine Instanzmethode handelt.
 Das entspricht unserem Verständnis einer Methode in C++/Java.
 Da jedoch auch Klassen Objekte sind, können diese eigene Methoden haben.
 Solche Klassenmethoden werden durch ein vorangestelltes Plus gekennzeichnet.
 Ein gutes Beispiel ist der zum Initialisieren gebräuchliche verkettete
 Befehl 
\family typewriter
\size small
[[NSObject alloc] init]
\family default
\size default
, der aus den folgenden Methoden besteht: 
\family typewriter
\size small
+(id)alloc
\family default
\size default
 ist die Klassenmethode, welche Speicher für das Objekt reserviert und einen
 Zeiger darauf zurückliefert, anschließend initialisiert sich das erzeugte
 Objekt in dem allokierten Speicher durch den Aufruf von 
\family typewriter
\size small
-(id)init
\family default
\size default
.
\end_layout

\begin_layout Subsection
Protokolle: Data Sources und Delegates
\end_layout

\begin_layout Standard
Wer in Java mit Interfaces umgehen kann, sollte keine Schwierigkeiten haben,
 sich mit der Funktionsweise von Protokollen vertraut zu machen.
 Eine Protokolldeklaration beginnt mit dem Schlüsselwort 
\family typewriter
\size small
@protocol
\family default
\size default
, die enthaltenen Methoden befinden sich entweder unter 
\family typewriter
\size small
@required
\family default
\size default
 oder unter 
\family typewriter
\size small
@optional
\family default
\size default
, was selbsterklärend sein sollte.
 Bei der Deklaration der Klasse wird das Protokoll in spitzen Klammern hinter
 der Oberklasse angegeben, mehrere Protokolle werden mit Kommata voneinander
 getrennt:
\end_layout

\begin_layout LyX-Code

\size small
@interface ViewController : UIViewController <UITextFieldDelegate, UITableViewDe
legate, UITableViewDataSource> {
\end_layout

\begin_layout LyX-Code

\size small
   ...
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Ein Konzept, welches so ebenfalls nicht bei C++ anzutreffen ist, sind Delegates
 (vom englischen 
\shape italic
delegation
\shape default
: Abordnung, Übertragung) und Data Sources.
 Mit ihnen ist es möglich, Nachrichten an einen 
\begin_inset Quotes eld
\end_inset

Deligierten
\begin_inset Quotes erd
\end_inset

 weiterzuleiten, mit denen eine Methode aufgerufen werden soll, die in einen
 bestimmten Funktionalitätsbereich fällt.
 Ein TextField sendet nach dem Betätigen des Enter-Buttons die Nachricht
 
\family typewriter
\size small
textFieldShouldReturn:(UITextField *)
\family default
\size default
 an ihren Deligierten.
 Die kann die eigene Instanz sein - in diesem Fall angesprochen mit 
\shape italic
self
\shape default
 - oder aber ein beliebiges anderes Objekt, welches das Protokoll 
\family typewriter
(BOOL)UITextFieldDelegate
\family default
 implementiert.
 Existiert diese Methode, wird abgefragt, was beim Betätigen der Entertaste
 passieren soll.
 An dieser Stelle bietet es sich an, mittels 
\family typewriter
\size small
[textField resignFirstResponder]
\family default
\size default
 das On-Screen-Keyboard wieder zurückzuziehen und eine Methode aufzurufen,
 welche auf den im Textfeld enthaltenen Text zugreift.
 Da bei diesem Vorgang wenig Komplikationen zu erwarten sind, sollte abschließen
d ein YES zurückgegeben werden, um zu bestätigen, dass die Bearbeitung der
 Entertaste erfolgreich abgeschlossen wurde.
\end_layout

\begin_layout Standard
Ein Objekt kann aber nicht nur als Empfänger von Nachrichten dienen, er
 kann auch als Datenquelle fungieren.
 Implementiert es das einer Programmstruktur zugehörige DataSource-Protokoll,
 lässt es sich von dieser nutzen, um bei Laufzeit von dieser benötigte Daten
 abzufragen.
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
Properties werden in der Headerdatei deklariert und stellen einen einfachen
 Weg dar, Accessoren zu implementieren.
 War in früheren Xcode-Versionen noch das manuelle Anlegen mittels 
\family typewriter
\size small
@synthesize
\family default
\size default
 notwendig, werden diese nun automatisch generiert.
 ein 
\family typewriter
\size small
@property (UITextField*)name
\family default
\size default
 erzeugt somit per default den Setter 
\family typewriter
\size small
setName
\family default
\size default
 sowie den Getter 
\family typewriter
\size small
name
\family default
\size default
.
 Möchte man nun den Namen setzen, hat man hier 2 Möglichkeiten: den C- oder
 den ObjC-Weg.
 Ein 
\family typewriter
\size small
_name.text = string
\family default
\size default
 würde intern in ein 
\family typewriter
\size small
[_name setText:NSString]
\family default
\size default
 umgewandelt werden.
 In meiner Implementation habe ich ausschließlich die ObjC-Variante verwendet.
 Wenn man es ganz genau nimmt, führt ObjC intern den folgenden Befehl aus:
 
\family typewriter
\size small
[[self name] setText:NSString]
\family default
\size default
, wobei der Unterstrich aufzeigt, dass es sich um eine Instanzvariable handelt.
 Da Apple vorangestellte Unterstriche für eigene Zwecke einsetzt, sollte
 somit zur Vermeidung von Verwechslungen auf deren eigene Verwendung verzichtet
 werden.
\end_layout

\begin_layout Section
API: Cocoa Touch (1 Seite)
\end_layout

\begin_layout Standard
iOS lässt sich in vier grundlegende Schichten einteilen: Während sich auf
 dem Core OS der Mach-Kernel sowie die grundlegenden Funktionen beinhaltet,
 stellen die Core Services die Frameworks bereit, die Grundlage aller Anwendunge
n und Dienste sind, die auf dem Gerät laufen.
 Der darüber liegende Media-Layer beinhaltet sämtliche Multimediafunktionen,
 schlussendlich folgt die Programmierschnittstelle Cocoa Touch, welche Schnittst
ellen zu sämtlichen darunter liegenden Schichten bereitstellt.
 Gegenüber Cocoa, der Schnittstelle für OS X-Maschinen, greift die Touch-Variant
e der API auf eine passende Benutzerschnittstelle zurück und beinhaltet
 spezielle Dinge wie Unterstützung der Bewegungssensoren, Multitouch-Gestenerken
nung sowie Animationen, welche speziell auf iOS abgestimmt sind und dem
 Programmierer darauf abgestimmte Eingabeelemente und Events anbietet.
 Die Basis von Cocoa Touch bilden mehrere Frameworks: das Foundation Framework
 liefert alle Basisklassen, die die Grundlage zur Programmierung mit Objective-C
 bilden und Werkzeuge wie Collections und Dateihandling bereitstellen, ohne
 die eine moderne Programmierung heute nicht mehr auskommt.
 Seit der iOS-Version 2 befindet sich darin bereits XML-Unterstützung, welche
 in iOS 5 um JSON-Unterstützung ergänzt wurde, was es im Rahmen dieser Arbeit
 sehr einfach macht, auf externe Frameworks zu verzichten.
 Das UIKit beinhaltet Klassen, welche speziell auf die Entwicklung der grafische
n Oberfläche ausgerichtet sind.
 So enthält die Infrastruktur für grafische Anwendungen verschiedene Ansichten,
 so genannte Views, und deren Fenster, Menüs und Schaltflächen, sowie einen
 Ereignisbetrieb mit Sprachanbindung und Textsystem.
 Eeignisse durchlaufen eine so genannte 
\begin_inset Quotes eld
\end_inset

Responder-Chain
\begin_inset Quotes erd
\end_inset

, die aus unterschiedlichen Klassen besteht und ein eingetroffenes Ereignis
 entnehmen und verarbeiten.
 Seit OS X 10.4/iOS 3 wurde diese Sammlung um das Core Data Framework ergänzt,
 welches für die Erstellung von Objektgraphen kümmert und dem schnellen
 Entwurf von Modellen im Model-View-Controller-System dienlich ist.
 Das MVC-Muster ist in Cocoa strikt umgesetzt; Klassen lassen sich in der
 Regel eindeutig zuordnen.
 Bei den Klassennamen selbst ist auffallend, dass die meisten mit NS beginnen,
 wie z.
 B.
 NSObject, NSString oder NSArray.
 Dies hat seinen Ursprung darin, dass Apple im Jahre 1996 das OpenStep-Framework
 NeXTStep aufkaufte und als Basis für Mac OS X verwendete.
 Durch die Verwendung von 
\begin_inset Quotes eld
\end_inset

Klassen-Clustern
\begin_inset Quotes erd
\end_inset

 werden viele sichtbare Klassen nie instanziert, sondern es werden direkt
 zur Laufzeit statt dessen Instanzen von passenden Subklassen erzeugt, von
 denen der Programmierer keine Kenntnis hat.
 Beispielsweise verlangt ein Anwendungsprogrammierer nach einer Instanz
 von NSArray, erzeugt wird jedoch in Abhängigkeit der Elemente eine Instanz
 eine Klasse, die er nicht kennt.
\end_layout

\begin_layout Section
IDE: Xcode (1,5 Seiten)
\end_layout

\begin_layout Standard
Xcode ist Apples integrierte Entwicklungsumgebung und steht aktuell in der
 Version 4.5 zur Verfügung.
 Seit der Version 4.1 lässt sich Xcode für jedermann zugänglich kostenlos
 im App Store herunterladen.
 In der Version 4.4 sind die SDKs für OS X 10.8 sowie für iOS 5.1 enthalten,
 Xcode 4.5 bringt die SDK für das neue iOS 6 mit.
 Beide benötigen mindestens OS X in der Version 10.7.4 Lion oder 10.8 Mountain
 Lion.
 Mit Hilfe von Xcode lassen sich OS X- oder iOS-Anwendungen entwickeln,
 wobei OS X-Anwendungen auf der 
\shape italic
Cocoa
\shape default
-API basieren; möchte man eine iOS-Anwendung entwickeln, stellt Apple das
 im vorherigen Kapitel vorgestellte Cocoa Touch-Framework bereit.
\end_layout

\begin_layout Standard
Xcode kommt mit einer Reihe von Werkzeugen - den 
\shape italic
Xcode Tools
\shape default
 - die die alltägliche Arbeit des Programmierers ein wenig erleichtern soll.
 Apples LLVM Compiler bietet eine angenehme Echtzeitüberprüfung des eingegebenen
 Codes und meldet auffallende Syntax- oder Schreibfehler umgehend.
 Oft bietet die eingeblendete 
\shape italic
Fix-it
\shape default
-Funktion gleich eine adäquate Lösung, die sich mit einem Click darauf übernehme
n lässt.
 Natürlich darf man hier keine Wunder erwarten, in der Praxis hat sich deren
 Vorhandensein jedoch als sehr angenehm erwiesen.
 Mit dem Analysetool 
\shape italic
Instruments
\shape default
 lassen sich diverse Messinstrumente an einen Prozess hängen und deren Laufzeitv
erhalten akribisch genau analysieren.
 Möchte man ein Programmverhalten auf einem bestimmten iOS-Gerät testen,
 kann man auf den integrierten iPhone- und iPad-Simulator zurückgreifen,
 für den verschiedene iOS-Versionen zum Download bereit gestellt werden.
 Auf diesem lässt sich die App testen, ohne dass man ein physisches Gerät
 zur Hand haben muss.
 Hierbei lassen sich verschiedene Hardware-Events simulieren, vom Schwenk
 des Orientation-Modus über die Betätigung der Home-Taste bis hin zu einer
 Speicherwarnung, mit welcher man die eigene Implementation überprüfen kann.
 Möchte man jedoch Implementation der in den aktuellen Geräten verbauten
 Sensoren überprüfen, kommt man an einem echten Stück Apple-Hardware nicht
 vorbei.
\end_layout

\begin_layout Standard
Das Interface von Xcode besteht zum einen aus dem 
\shape italic
Source Editor
\shape default
, welcher Komfortmerkmale 
\shape italic
Code Completion
\shape default
, 
\shape italic
Syntax Highlighting
\shape default
 und 
\shape italic
Code Folding
\shape default
 bereitstellt sowie die äußerst angenehme Echtzeitanzeige von Fehlern, Warnungen
 und anderer kontextsensitiven Informationen in Nachrichtenblasen.
 Darüber hinaus ermöglicht der 
\shape italic
Assistant Editor
\shape default
 über ein zweigeteiltes Fenster den Schnellzugriff auf die Dateien, die
 für gewöhnlich die hilfreichste Kombiation mit der geöffneten Datei darstellt
 (zum Beispiel wird neben dem Interface deren Implementation geöffnet).
 Der 
\shape italic
Interface Builder
\shape default
 - mit Version 4.0 von den 
\shape italic
Xcode Tools
\shape default
 in die 
\shape italic
IDE
\shape default
 gewandert - ermöglicht es, äußerst komfortabel und ohne eine Zeile Code,
 die GUI der App zu designen und die einzelnen Interfacekomponenten untereinande
r zu verknüpfen und in den Programmcode einzubinden.
 Der Organizer bietet eine zentrale Verwaltung für die der Entwicklerlizenz
 hinzugefügten Geräte, Versionsverwaltung über lokale sowie entfernte Repositori
es, Projekte und deren Snapshots und ein App Archiv, von dem aus man seine
 entwickelten Apps verwaltet und zum App Store sendet.
\end_layout

\begin_layout Standard
Am Rand lassen sich weitere Leisten einblenden; auf der linken Seite wäre
 dies der Navigator, der uns Dateien, Fehler und Logs führt, rechts lässt
 uns die Utility Bar einige Einstellungen vornehmen.
 Darüber hinaus befindet sich dort auch eine File Templates- und eine Code
 Snippets-Library im unteren Bereich für Dinge, die man einfach immer mal
 wieder benötigt.
 Im unteren Bereich lässt sich selbstverständlich die für das Debugging
 unentbehrliche obligatorische Konsole einblenden.
\end_layout

\begin_layout Standard
Da es vor allem auf mobilen Geräten eher zu Resourcenknappheit kommt als
 auf Desktop-Systemen, sollte man hier einen entsprechend ökonimischen Programie
rstil pflegen und Ressourcen, die nicht mehr benötigt werden, nach der Verwendun
g wieder freigeben.
 In Xcode 4.2 wurde das Automatic Reference Counting eingeführt, um sich
 dieses Problemes anzunehmen.
 Die bislang verwendeten 
\family typewriter
\size small
retain
\family default
\size default
 und 
\family typewriter
\size small
release
\family default
\size default
-Nachrichten, die bisher vom Programmierer verwendet wurden um Speicher
 freizugeben oder eben diese Freigabe zu verhindern, sind somit obsolet.
 Statt dessen übernimmt nun der Compiler die Referenzzählung und fügt dem
 Code beim Übersetzen die entsprechenden 
\family typewriter
\size small
retain
\family default
\size default
 und 
\family typewriter
\size small
release
\family default
\size default
-Nachrichten hinzu.
\end_layout

\begin_layout Section
Interface Builder: Storyboards (0,5 Seiten)
\end_layout

\begin_layout Standard
Neu eingeführt in Xcode 4.2 bilden Storyboards die Grundlage die Grundlage
 des Interface Builders und lösen die vorhergehenden NIBs, bei denen man
 darauf beschränkt war, zu jedem Zeitpunkt mit je einer View zu arbeiten.
 Storyboards gestalten dies nun etwas einfacher und zeigen eine komplette
 Szene an, also die einzelnen Views und deren Übergänge untereinander.
 Verbindungen zu anderen Views wie die Möglichkeit, diese als Datenquelle
 oder Deligierte zu nutzen, lassen sich mit realisieren, indem man ein Objekt
 bei gedrückter ctrl-Taste auf die gewünschte View zieht.
 Zieht man diese statt dessen in den Interfaceteil des Programmcodes, werden
 die entsprechenden Codefragteile erstellt, in denen man mit der Implementation
 beginnen kann, ohne sich mit programmatischen Details zum Setzen der einzelnen
 GUI-Elemente beschäftigen zu müssen.
 Es lassen sich sogar solche Verbindungslinien mit ID-Strings versehen und
 auf die man programmatisch zugreifen.
 So wird im Falle eines Überganges auf eine andere View die Methode 
\shape italic
prepareForSegue
\shape default
 mit dem entsprechenden String für diesen Übergang aufgerufen.
 In dieser lassen sich Vorbereitungen für die neue Ansicht treffen - wie
 z.
 B.
 Daten und Referenzen übergeben - bevor diese dann geladen wird.
\end_layout

\begin_layout Standard
Im Utility-Bereich kann praktisch jede Eigenschaft bearbeitet werden, mit
 der das Erscheinungsbild beeinflusst werden kann, so lässt sich ein Objekt
 inaktiv oder gleich komplett versteckt darstellen oder man ändert die Schriftar
t eines Textfeldes.
 Möchte man ein Objekt einem Container unterordnen, lässt sich das unkompliziert
 per Drag and Drop realisieren.
 Zieht man beispielsweise eine Text View in einen Scroll View-Container
 erhält man Text, welcher sich mit einer Wischbewegung scrollen lässt.
 
\end_layout

\begin_layout Section
Entwicklerlizenz: Testen auf echter Hardware (1 Seite)
\end_layout

\begin_layout Standard
Grundsätzlich lässt sich eine App auch ohne Lizenz entwickeln und auf dem
 eingebauten 
\shape italic
iOS Simulator
\shape default
 des seit der Version 4.1 für jedermann verfügbaren Xcode testen.
 Möchte man jedoch die App auf einem 
\begin_inset Quotes eld
\end_inset

echten
\begin_inset Quotes erd
\end_inset

 Gerät zur Ausführung bringen und später einmal in den App Store stellen,
 benötigt man eine Entwicklerlizenz von Apple.
 Diese kostet derzeit 99 USD bzw.
 80 EUR und ist für genau ein Jahr gültig.
 Mit einem Entwickleraccount hat man Zugriff auf 
\shape italic
itunes Connect
\shape default
, mit dem sich der eigene Account, die verfügbaren iOS-Geräte sowie die
 eingestellten Apps verwalten lassen.
\end_layout

\begin_layout Standard
Der erste Schritt ist es, die User anzulegen, welche an der Entwicklung
 und Distribution der Software beteiligt sind.
 Hier stehen die vordefinierten Rollen 
\shape italic
Admin
\shape default
, 
\shape italic
Technical
\shape default
, 
\shape italic
Finance
\shape default
 sowie 
\shape italic
Sales
\shape default
 zur Verfügung.
 Während der 
\shape italic
Technical
\shape default
 Rechte für die Verwaltung der Apps bekommt, stehen dem 
\shape italic
Finance
\shape default
 weitergehend verschiedene Rechte im Bereich Finanzwesen, Analyse und Vertrieb
 bereit, die der 
\shape italic
Technican
\shape default
 eher nicht benötigt.
 Auf die Verwaltung der Apps hat er nur lesenden Zugriff, so kommen sich
 die Beiden nicht in die Quere.
 Der Rolle 
\shape italic
Sales
\shape default
 letztendlich steht nur der Verkaufs und die Verkaufsanalyse offen.
\end_layout

\begin_layout Standard
Abhängig vom Vertriebsmodell müssen wir in 
\shape italic
iTunes Connect
\shape default
 nun weitere Angaben machen.
 Für unentgeltliche Apps ist es weder notwendig, einen Vertrag zu akzeptieren,
 noch müssen wir Bankdaten hinterlegen.
 Mochten wir jedoch mit unseren Apps Geld verdienen, stehen uns die Vertragstype
n 
\shape italic
iOS Paid Applications
\shape default
 sowie für in-App-Werbung 
\shape italic
iAd Network
\shape default
 zur Verfügung.
 Hier sind die ensprechenden Vertragsbedingungen zu akzeptieren, Kontaktinformat
ionen anzugeben, Landesangaben zur Versteuerung zu machen und natürlich
 die Bankdaten für den zu erwartenden, eingehenden Zahlungsverkehr zu hinterlege
n.
\end_layout

\begin_layout Standard
Um eine App direkt auf unserem Gerät ausführen zu können, benötigen wir
 ein Development Certificate.
 Hierzu schließen wir das Gerät, das wir hinzufügen möchten, an den Mac
 an und wechseln in Xcode in den Organizer.
 Hier können wir das angeschlossene Gerät unserem Entwickleraccount zuordnen.
 Beim ersten Mal wird uns Xcode mitteilen, dass kein 
\shape italic
iOS Development Certificate
\shape default
 vorhanden ist und bietet an, einen solchen von Apple anzufordern.
 Anschließend fügt er diesen automatisch der Schlüsselverwaltung hinzu und
 bietet an, das Entwicklerprofil für den Einsatz auf anderen Macs zu exportieren.
 In den 
\shape italic
Build Settings
\shape default
 unserer App stellen wir nun die 
\shape italic
Code Signing Identity
\shape default
 auf das neu erzeugte Zertifikat um und sind nun in der Lage, das angeschlossene
 iOS-Gerät statt des Simulators für die Entwicklung zu benutzen.
\end_layout

\begin_layout Chapter
Schnittstelle mit der REST-Welt (8 Seiten)
\end_layout

\begin_layout Section
RESTful Webservices (5,5 Seiten)
\end_layout

\begin_layout Subsection
Begriffseinführung
\end_layout

\begin_layout Standard
Wikipedia definiert den Begriff 
\shape italic
Webservice
\shape default
 als 
\begin_inset Quotes eld
\end_inset

eine Methode der Kommunikation zwischen zwei elektronischen Geräten über
 das Internet
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Wikipedia - Webservice"

\end_inset

.
 Man verbindet damit primär Akronyme wie SOAP (Simple Object Access Protocol)
 - ein Netzwerkprotokoll für den Transfer von Daten und RPCs (Remote Procedure
 Calls) - oder den einfacheren XML-RPC.
 Diese Webservices arbeiten, wie der Name bereits ausdrückt, mit HTTP POST-Reque
sts, um auf einem meist entfernten Computer eine Methode aufzurufen.
 Unterhalten wird sich hierbei in der XML-basierten Webservices Description
 Language (WSDL).
\end_layout

\begin_layout Standard
Im Jahr 2000 führte Roy Fielding, einer der Authoren der HTTP-Spezifikationen
 1.0 und 1.1 und Mitbegründer des Apache HTTP Projektes, in seiner Dissertation
 
\begin_inset Quotes eld
\end_inset

Architectural Styles and the Design of Network-based Software Architectures
\begin_inset Quotes erd
\end_inset

 den Begriff 
\shape italic
REpresentational State Transfer
\shape default
 ein und definiert ihn als einen 
\begin_inset Quotes eld
\end_inset

Architekturstil für verteilte hypermediale Systeme, der die Richtlinien
 für die Softwareentwicklung spezifiziert, welche sowohl REST selbst leiten
 als auch die Interaktionsvoraussetzungen, die so gewählt werden, dass sie
 diesen Richtlinien entsprechen
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Dissertation Fielding"

\end_inset

.
 Die REST-Architektur ist also ein Modell, das spezifiziert, wie das Internet
 - das im Grunde bereits eine riesige REST-Anwendung darstellt - eigentlich
 funktionieren sollte.
 Er nennt REST eine hybride Architektur, die von vielen verschiedenen Netzwerk
 basierten Architekturstilen abgeleitet ist und bezeichnet Seiten, die mit
 der Architektur REST kompatibel ist, als RESTful.
\end_layout

\begin_layout Standard
Den Kern dieses Architekturmodells bilden so genannte Ressourcen, weswegen
 es auch gerne als Ressource-oriented Architecture - oder kurz ROA - bezeichnet
 wird.
 Alles, was sich eindeutig identifizieren lässt, ist eine Ressource und
 bekommt eine Adresse zugewiesen.
 Jede Datei oder jedes Verzeihnis kann eine Ressource sein, aber auch eine
 ausführbare Methode, die beispielsweise eine Anfrage in einer Datenbank
 auslöst, ist eine denkbare Ressource.
 Hervorragende Kanditaten stellen die Entitäten in einem Datenmodell: 
\shape italic
Artikel
\shape default
, 
\shape italic
Kunde
\shape default
, 
\shape italic
Bestellung
\shape default
 bieten sich hier an, aber auch 
\shape italic
Bestellungen von Kunde X aus Jahr Y
\shape default
 kann eine valide Ressource sein und dann ebenfalls eine möglichst langlebige
 und stabile URL erhalten.
 Bei der Wahl der Ressourcen gilt: Im Zweifel sind eher zu viele Ressourcen
 zu identifizieren als zu wenige.
\end_layout

\begin_layout Subsection
Richtlinien
\end_layout

\begin_layout Standard
Die Tatsache, dass HTTP bereits ein ressourenbezogenes Caching mit sich
 bringt, gibt einem das Gefühl, mit einer REST-Anwendung im Internet bereits
 
\begin_inset Quotes eld
\end_inset

zu Hause zu sein
\begin_inset Quotes erd
\end_inset

.
 Viele Onlineshops, Suchmaschinen oder Buchungssysteme auch ohne, dass sie
 gezielt darauf abzielen, bereits RESTful.
 Damit eine Anwendung das HTTP jedoch auch tatsächlich REST-konform nutzt,
 muss sie sich an die von Fielding diktierten Richtlinien halten.
 Diese Richtlinien lassen sich wie folgt untergliedern, wobei es den einzelnen
 Diensten obliegt, wie diese implementiert werden:
\end_layout

\begin_layout Subsubsection
Adressierbarkeit
\end_layout

\begin_layout Standard
SOAP Webservices, aber auch viele HTML-Seiten, bilden ihre Funktionalität
 auf eine einzelne URL ab.
 Das sieht zwar in der Adresszeile durchaus 
\begin_inset Quotes eld
\end_inset

sauber
\begin_inset Quotes erd
\end_inset

 aus, bringt jedoch Nachteile mit sich: sie lassen sich weder als Lesezeichen
 ablegen, noch kann man mal eben dem Freund/Kommilitonen einen Link auf
 ein Produkt zusenden und auch Suchmaschinen haben es hier schwerer, denn
 auch diese benötiogen zum direkten Zugriff auch Unterbereiche einen konkreten
 Zugriffspfad.
 RESTful gestaltete Anwendungen bieten diese geforderte Addressierbarkeit,
 und zwar genau in dem Maße, in dem die Anwendung es möchte.
 Es ist ohne Weiteres möglich, gezielten Zugriff auf eine Ressource zu unterbind
en, zum Beispiel durch die Verwendung einer Firewall.
 Natürlich ließe sich das URL-Prinzip ebenfalls auf SOAP anwenden, aber
 sobald diese dereferenziert werden, bewegen wir uns wieder in der REST-Welt.
\end_layout

\begin_layout Subsubsection
Unterschiedliche Repräsentationen
\end_layout

\begin_layout Standard
Von den hinter einer URL bereitgestellten Diensten lassen sich unterschiedliche
 Darstellungen anfordern, diese bezeichnet man als Repräsentation dieser
 Ressource.
 Über die im HTTP-Protokoll enthaltenen Accept- und Content-Type-Header
 unterstützt das Internet ebenfalls bereits 
\begin_inset Quotes eld
\end_inset

von Haus aus
\begin_inset Quotes erd
\end_inset

 die Content Negotiation, mit der sich unterschiedliche Repräsentationen
 ein- und derselben Ressource anzeigen lassen.
 Hierbei dürfen sich die Clients das Format anfordern, welches am ehesten
 ihren Bedürfnissen entspricht: Ein Browser zeigt sich meist mit einer HTML-Repr
äsentation zufrieden, während andere Client - wie der in dieser Arbeit vorgestel
lte - ist eher an der XML- oder an der JSON-Repräsentation interessiert.
 Darüber hinaus lassen sich sogar Versionswünsche über die Content Negotiation
 realisieren und beispielsweise der gewünschte Content nach Belieben in
 XML 1.1 oder in XML 1.2 geliefert werden.
\end_layout

\begin_layout Subsubsection
Zustandslosigkeit
\end_layout

\begin_layout Standard
REST ist konzeptual ein zustandsloses Protokoll, somit ist auch jeder RESTful
 Webservice zustandslos.
 Weder Server noch der Webservice behalten sich den aktuellen Stand ihres
 Dialoges, demnach muss jede Nachricht stets alle Informationen beinhalten,
 die erforderlich sind, diese Nachricht korrekt zu interpretieren und die
 Anfrage ordnungsgemäß verarbeiten zu können.
 Da sich weder Server noch Client einen Zustand behalten muss, bezeichnet
 man das Kommunikationsprotokoll einer REST-konformen Architektur als 
\shape italic
zustandslos
\shape default
.
 Durch die Abgeschlossenheit der einzelnen Nachrichten lassen darüber hinaus
 Lasten sehr leicht auf mehrere Maschinen verteilen, was sich positiv auf
 die Skalierbarkeit des Webservice auswirkt.
 In der Praxis wird jedoch auch gerne auf Cookies und andere Techniken zurückgeg
riffen, um über den Request hinaus an Zustandsinformationen gelangen.
\end_layout

\begin_layout Subsubsection
Operationen
\end_layout

\begin_layout Standard
Damit die RESTful gestaltete Webservices untereinander kommunizieren können,
 muss eine gemeinsame Sprache gesprochen werden.
 Das HTTP-Protokoll kennt unter anderem die Optionen GET, POST, PUT, DELETE,
 HEAD und OPTIONS.
 Da jede REST-Ressource die gleichen Operationen nutzen muss, definiert
 dieser Methodensatz die vom REST-Architekturstil geforderten 
\shape italic
wohldefinierten Operationen
\shape default
.
 Durch die Verwendung dieser elementarer Webtechniken wird die Integration
 und Interaktion der beteiligten Softwarekomponenten deutlich vereinfacht.
\end_layout

\begin_layout Standard
Die GET-Methode hat hierbei 
\begin_inset Quotes eld
\end_inset

sicher
\begin_inset Quotes erd
\end_inset

 zu sein, das bedeutet, in diesem Fall wird nur etwas gelesen, der Client
 darf jederzeit bedenkenlos ein GET auf eine Ressource anwenden.
 Weiterhin diktiert die HTTP-Spezifikation die idempotente Implementation
 von GET, PUT und DELETE.
 Wird eine dieser Operationen mehrfach ausgeführt, wird stets das gleiche
 Ergebnis erwartet.
 Ist sich der Client unsicher, ob sein Request erfolgreich abgearbeitet
 wurde, sollte er ihn ohne Seiteneffekte wiederholen dürfen.
 HEAD und OPTIONS finden in REST eher selten Verwendung.
 Die REST-konforme Verwendung der Methoden in einem kurzen Überblick:
\end_layout

\begin_layout Description
GET: Mit GET wird die Repräsentation der Ressource vom Server angefordert.
\end_layout

\begin_layout Description
POST: POST fügt eine neue Unterressource zur angegebenen Ressource ein.
 Da die Unterressource vorher noch nicht existierte, wird die URL zu dieser
 nun vom Server erzeugt und dem Clienten in der Response zurückgegeben.
 Über diese Verwendung hinaus kann POST auch für Operationen verwendet werden,
 die sonst von keiner anderen Methode abgedeckt werden.
\end_layout

\begin_layout Description
PUT: Die in PUT enthaltene Ressource wird angelegt.
 Existiert sie bereits, wird sie, wie im Body angegeben, abgeändert.
\end_layout

\begin_layout Description
DELETE: DELETE entfernt die Ressource komplett.
\end_layout

\begin_layout Description
HEAD: Die Metadaten einer Ressoure lassen sich mit HEAD abfragen.
\end_layout

\begin_layout Description
OPTIONS: Weiß man nicht, welche Methoden auf einer Ressource angewendet
 werden dürfen, lässt sich dies mit OPTIONS in Erfahrung bringen.
\end_layout

\begin_layout Standard
Clientseitig sollte demnach das folgende Protokoll anwendbar sein:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@protocol Resource
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Resource(URI u)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response get()
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response post(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response put(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response delete()
\end_layout

\begin_layout LyX-Code

\size footnotesize
@end
\end_layout

\begin_layout Standard
Die (vereinfachte) Implementation der Anlage eines Kundenkontis im Server
 kann wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
class Customers : Resource {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
   Response post(Request r){
\end_layout

\begin_layout LyX-Code

\size footnotesize
      id = createCustomer(r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      return new Response(201, r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   }
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Subsubsection
Hypermedia
\end_layout

\begin_layout Standard
Das Kofferwort Hypermedia ist eine Zusammensetzung aus den Begriffen 
\begin_inset Quotes eld
\end_inset

Hypertext
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

Multimedia
\begin_inset Quotes erd
\end_inset

 und weist auf die Verwendung von Hypertext mit explizitem Akzent auf den
 multimedialen Gesichtspunkt hin.
 Repräsentationen enthalten in der Regel neben Informationen selbst wieder
 Links zu anderen Ressourcen.
 Das macht das Internet zu dem, was es ist: Eine stark vernetzte Verbindungsstru
ktur von identifizierbaren Ressourcen über hypermediale Links auf andere
 identifizierbare Ressourcen.
 Die standartisierte Adressierung sorgt hierbei dafür, dass sich die verlinkte
 Ressource in einem anderen Prozess im gleichen System oder auf einem anderen
 Rechner befinden kann, ganz gleich ob sich dieser im lokalen Netzwerk befindet,
 an einem beliebigen anderen Ort dieses Planeten oder seit Januar 2010 sogar
 auf der Raumstation ISS.
 Hierfür wird auch gerne der Ausdruck 
\shape italic
Verbindungshaftigkeit
\shape default
 verwendet.
 Im Optimalfall wird dem Clienten in der angeforderten Repräsentation gleich
 die nächsten möglichen Übergänge als hypermediale Links mitteilen.
 Der Wert einer Anwendung ist proportional zur Anzahl der Ressourcen, auf
 die sie verlinkt.
 Mit einem Link auf einen REST-konform konzipierten Webservice eines Telekommuni
kationsunternehmen würden mit wenigen Klicks Millionen von Kundendaten zugreifba
r gemacht werden.
 Diese könnten von der Anwendung selbst ausgewertet oder dem Endanwender
 zur Weiterverarbeitung überlassen werden.
\end_layout

\begin_layout Subsection
Beispiel
\end_layout

\begin_layout Standard
Wie so oft lässt sich das Prinzip von REST am Besten an einem Bespiel zeigen.
 Wir betrachten die Schnittstelle für den fiktiven Onlineshop smartphoneseppel.de.
 Ein Neukunde möchte sich ein Smartphone bestellen und legt sich zu diesem
 Zweck ein Kundenkonto an.
 Er wechselt auf die Seite des Onlineshops (
\shape italic
GET http://www.smartphoneseppel.de
\shape default
) und teilt dem Server des Onlineshops mit einem 
\shape italic
POST /customer
\shape default
, in dessen Body die Daten stehen, die er für die Registrierung angegeben
 hat, seine Registrierungsabsicht mit.
 Der Server bestätigt der Response
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 201 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml;
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Length: 44
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
http://www.smartphoneseppel.de/customer/1337
\end_layout

\begin_layout Standard
die erfolgreiche Anlage des des Kundenkontos mit der Kundennummer.
 Die Bestandteile einer HTTP-Resonse sind stets der Statuscode - an dieser
 Stelle weist der Statuscode 201 
\shape italic
CREATED
\shape default
 darauf hin, dass eine neue Ressource angelegt wurde - , die Art des zurückgelie
ferten Contents sowie natürlich den Content selbst.
 Nun kann er mit 
\shape italic
GET /customer/1337
\shape default
 sein Kundenkonto anzeigen lassen.
 Eine Änderung ist mit einem 
\shape italic
PUT /customer/1337
\shape default
 möglich.
 Möchte er sich nun den Artikel 
\shape italic
Samsung Galaxy S3
\shape default
 anzeigen lassen kann er das per 
\shape italic
GET /article/galaxy_s3
\shape default
.
 Es gefällt ihm und so packt er es sich mit einem 
\shape italic
PUT /shoppingcart/1337&article=galaxy_s3
\shape default
 in seinen Warenkorb.
 Zur Sicherheit überprüft er nun dessen Inhalt mit 
\shape italic
GET /shoppingcart/1337
\shape default
.
 Die Antwort des Onlineshops könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 200 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0"?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<shoppingcart xmlns:xlink="http://www.w3.org/1999/xlink">
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <customer xlink:href="http://www.smartphoneseppel.de/customer/1337">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1337
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </customer>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <position pos="1" amount="1">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    <article xlink:href="http://www.smartphoneseppel.de/article="galaxy_s3"
\end_layout

\begin_layout LyX-Code

\size footnotesize
       article="galaxy_s3">
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Samsung Galaxy S3</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
    </article>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </position>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</shoppingcart>
\end_layout

\begin_layout Standard
Kunde 1337 ist mit dem Ergebnis einverstanden und sendet mit 
\shape italic
POST /shoppingcart/1337
\shape default
 seine Bestellung ab, der Server quittiert ihm dies mit einem 
\shape italic
/shoppingcart/1337/open
\shape default
.
 Nun erscheint jedoch unerwartet das iPhone 5 und der Kunde überlegt es
 sich anders.
 Er überprüft, mit einem
\shape italic
 GET /customer/1337/orders
\shape default
 seinen Bestellstatus und hat Glück, die Bestellung wurde noch nicht versendet.
 Er storniert die offene Bestellung mit 
\shape italic
DELETE /customer/1337/orders/open/2012-09-11_001
\shape default
 und legt sich statt dessen mit 
\shape italic
PUT /shoppingcart/1337&article=iphone_5
\shape default
 den neuen Artikel in seinen Korb.
\end_layout

\begin_layout Standard
Der Onlineshop seinerseite entfernt nach dem Release des iPhone 5 mit 
\shape italic
DELETE /article/iphone_4s
\shape default
 das iPhone 4S aus deinem System und legt mit 
\shape italic
PUT /article
\shape default
 das neue Modell an.
 Der Body könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<articles>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <name>iPhone 5</name>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <description>Das beste iPhone, das es je gab.</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <size>64</size>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <weight>140</weight>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <price>849</price>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</articles>
\end_layout

\begin_layout Standard
Er sendet Kunde 1337 das gewünschte iPhone 5 und verschiebt seine Bestellung
 vom Status offen nach versendet mit: 
\shape italic
DELETE /customer/1337/orders/open/2012-09-12_001
\shape default
 und 
\shape italic
POST /customer/1337/orders/shipped/2012-09-12_001
\shape default
.
\end_layout

\begin_layout Section
XML (1,5 Seiten)
\end_layout

\begin_layout Standard
Die Codebeispiele im vorhergehenden Kapitel zeigen bereits, dass sich hier
 zur Kommunikation eines Austauschformates bedient wird, welches sowohl
 von Menschen gelesen als auch von Maschinen unabhängig von Plattform und
 Implementation geparst werden kann.
 XML steht für Extensible Markup Language (zu Deutsch: erweiterbare Auszeichnung
ssprache) und verwendet das - im einfachsten Fall im ASCII-Format kodierte
 - Textformat, um über eine Metasprache strukuriert Informationen verfügbar
 zu machen.
 Diese vom World Wide Web Consortium (W3C) herausgegebene Spezifikation
 ist aktuell in der 5ten Ausgabe verfügbar und ein Derivat des älteren SGML.
 In vielen Punkten ist XML sehr verwandt mit HTML, jedoch folgt XML einer
 konsequenteren Syntax.
 Dies führt dazu, dass valide XML-Dokumente zuverlässig von verschiedenster
 Software gelesen werden kann.
 Um die zur Formatierung verwenden Zeichen <, >, &, " und ' in Texten zu
 verwenden, greift man auf die Entitäten &lt;, &gt;, &amp;, &quot; sowie
 &apos zurück.
 Weitere feste Entitäten gibt es nicht, jedoch lassen sich beliebig weitere
 Entitäten definieren.
\end_layout

\begin_layout Standard
Die Struktur von XML bietet einige Vorteile gegenüber anderen Austauschformaten:
 Die redundante vollständige Wiederholung des Tagnamens beim Schließen erschwert
 Fehler bei der Verschachtelung und die einfache Syntax von XML, inklusive
 der Element- und Attributbezeichnungen, erleichtern es ungemein, gleich
 zu Beginn ein gutes Gefühl zu bekommen, wie man mit XML umzugehen hat.
 Da die volle XML-Spezifikation allerdings über einen Umfang von gut 30
 Seiten verfügt, soll hier nur ein kleiner Überblick über das Basiswissen
 im Umgang mit XML vermittelt werden.
\end_layout

\begin_layout Standard
Ein einfaches, wohlgeformtes XML-Dokument könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<content>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

1
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Einleitung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

2
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Die Entwicklungsumgebung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

3
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>REST</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <!-- at least chapter IMPLEMENTATION still missing -->
\end_layout

\begin_layout LyX-Code

\size footnotesize
</content>
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Wohlgeformt
\begin_inset Quotes erd
\end_inset

 bedeutet im Kontext eines XML-Dokumentes, dass exakt ein Wurzelelement
 vorhanden ist.
 Elemente sind Informationsträger gleich welcher Art, sie können Texte oder
 weitere Elemente enthalten, auch in Kombination; die Elementbezeichnung
 ist frei wählbar.
 Verfügt ein Element über Inhalt, so wird dieser mit einem Start- sowie
 mit einem Endelement versehen, beispielsweise <tag>content</tag>.
 Steht ein Element ohne Inhalt, so kann das Element den Ein- und den Auszeichner
 in sich vereinen: <no_content />.
 Ein einem Einzeichner oder einem leeren Tag können Attribute enthalten
 sein, die aus einem Name/Wert-Paar bestehen.
 Mehrere gleichlautende Elemente nebeneinander sind kein Problem, mehrere
 gleichlautende Attribute in einem Element sind jedoch nicht zulässig.
 Die Verschachtelung erfolgt 
\shape italic
ebenentreu
\shape default
, ein Element muss also geschlossen werden, bevor ein Geschwisterelement
 beginnt oder ein Elternelement geschlossen wird.
\end_layout

\begin_layout Standard
Über die Wohldefiniertheit hinaus besteht die Möglichkeit, weitere Anforderungen
 an unser Dokument zu stellen, welches sich mit einer Grammatik wie einer
 DTD (Document Type Definition) oder einem XML-Schema realisieren lässt.
 Ein Dokument, welches einen Verweis auf eine solche Grammatik enthält,
 diese auch einhält und darüber hinaus noch vohlgeformt ist, bezeichnet
 man als valid.
 Da das Programm, auf dem diese Arbeit beruht, keine solche Validität betrachtet
, soll an dieser Stelle auch nicht weiter darauf eingegangen werden.
\end_layout

\begin_layout Section
JSON (1 Seite)
\end_layout

\begin_layout Standard
XML ist nicht immer der ideale Weg, um seine Daten zu strukturieren.
 Das Tag-System bläht kleine Datenbestände schnell auf und das Ansprechen
 einzelner XML-Nodes ist nicht immer leicht.
 
\shape italic
JSON
\shape default
 - die Kurzform für 
\shape italic
Java Script Object Notation
\shape default
 - ist XML sehr ähnlich und bietet hier eine leichtgewichtige Alternative.
 Sie ist ein auch vom Menschen gut lesbares Austauschformat, welches darauf
 ausgelegt ist, von einer Anwendung leicht erstellt zu werden und sich anschließ
end - gegebenfalls von einer anderen - auch wieder leicht parsen zu lassen.
 Für ein sprachenübergreifendes Austauschformat ist es natürlich sinnig,
 dass man für den Aufbau auf Strukturen zurückgreift, die gängigen Sprachen
 geläufig sind.
 Somit kommen in JSON Key/Value-Records und Arrays zum Tragen, Strukturen,
 von denen es undenkbar ist, dass man sie in einer halbwegs modernen Programmier
sprache nicht in irgendeiner Form wiederfindet.
 Ein Objekt folgt in JSON 
\shape italic
der Syntax { String : Value }
\shape default
.
 Mehrerer Solcher Paare werden durch Kommata voneinander getrennt: 
\shape italic
{ String1 : Value1, String2 : Value2, ...
 }
\shape default
.
 Leerzeichen können zwischen den einzelnen JSON-Elementen der Übersichtlichkeit
 wegen beliebig gesetzt werden.
 Wie aus den meisten Programmiersprachen bekannt, kennzeichnet die eckige
 Klammer ein Array: 
\shape italic
[ Value1, Value2, Value3, ...
 ]
\shape default
.
 Ein Wert kann hierbei ein oben genanntes String/Value-Objekt sein, aber
 auch Strings, Zahlen oder die boolschen Werte 
\shape italic
true
\shape default
 und 
\shape italic
false
\shape default
 sind möglich.
 Darüber hinaus sind ist auch 
\shape italic
null
\shape default
 und auch weitere Arrays zulässige Werte.
 Zeichenketten, bestehend aus 0 bis n Unicode kompatiblen Zeichen, beginnen
 und enden je mit einem Anführungszeichen und können, ebenfalls wie aus
 C und Java bekannt, Escape-Sequenzen beinhalten, beginnend mit einem Backslash.
 Diese sind im Folgenden: 
\backslash

\shape italic

\begin_inset Quotes erd
\end_inset


\shape default
, 
\backslash

\backslash
 sowie 
\backslash

\shape italic
/
\shape default
 geben jeweils den Wert hinter 
\backslash
 wieder - also 
\shape italic

\begin_inset Quotes eld
\end_inset


\shape default
, 
\backslash
 und 
\shape italic
/
\shape default
 - hingegen steht 
\backslash

\shape italic
b
\shape default
 für ein Backspace, 
\backslash

\shape italic
f
\shape default
 für einen Seitenumbruch, 
\backslash

\shape italic
n
\shape default
 kennzeichnet eine neue Zeile, 
\backslash

\shape italic
r
\shape default
 den Zeilenrücklauf und 
\backslash

\shape italic
u
\shape default
 einen horizontalen Tabulator.
 Schließlich kann man noch, beginnend mit 
\backslash

\shape italic
u
\shape default
, einen vierstelligen Zahlencode eingeben, an dessen Stelle wird dann der
 Wert an der entsprechenden Stelle der Unicodetabelle zurückgegeben.
 Die Zahlensyntax ist ebenfalls aus der C-/Java-Welt bekannt mit der Ausnahme,
 dass JSON weder die Oktal- noch die Hexadezialdarstellung beherrscht.
 42 ist ebenso zulässig wie 1.35e-4 oder auch -3.7589E+20.
\end_layout

\begin_layout Standard
Ein Beispiel für eine JSON-Datei:
\end_layout

\begin_layout LyX-Code

\size footnotesize
{
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1337,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

John Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: [
\end_layout

\begin_layout LyX-Code

\size footnotesize
       [ 3456,
\end_layout

\begin_layout LyX-Code

\size footnotesize
         
\begin_inset Quotes eld
\end_inset

123-4567
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
       ], 
\begin_inset Quotes eld
\end_inset

john.doe@example.com
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
     ],
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: true
\end_layout

\begin_layout LyX-Code

\size footnotesize
  },
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1338,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

Jane Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: null,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: false
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Chapter
Implementation (11 - 12 Seiten, vielleicht mehr)
\end_layout

\begin_layout Section
Ein erster Überblick
\end_layout

\begin_layout Standard
Da es sich um eine iOS-App handelt und daher nicht mit Optionsvielfalt erschlage
n sollten, habe ich mich für ein einfaches 
\shape italic
Single View Application
\shape default
-Template und gegen einen 
\shape italic
NavigationController
\shape default
 entschieden.
 Erzeugt man ein Projekt, liefert Xcode bereits einige Template-Dateien,
 in denen man sofort loslegen darf, dazu gehören der 
\shape italic
ViewController
\shape default
 und das 
\shape italic
MainStoryboard
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagram.png
	lyxscale 45
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Verwendete Klassen in UML-Notation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
ViewController
\shape default
 ist hierbei die Initialisierungs-View und das zentrale Bedieninstrument
 dieser App.
 Die Implementation jeder View gehört in eine eigene Datei, was den Klassen
 
\shape italic
HeaderKeysViewController
\shape default
, 
\shape italic
ResourcesTableViewController
\shape default
 sowie 
\shape italic
LogOutputViewController
\shape default
 ihre Existenzberechtigung verleiht.
 Keine View besitzt der 
\shape italic
XMLParser
\shape default
, welcher sich jedoch hervorragend als autonome Klasse auszugliedern lies.
 
\shape italic
HistoryElement
\shape default
 ist die Implementation einer URL-History in Form einer doppelt verketteten
 linearen Liste.
\end_layout

\begin_layout Section
Hauptklasse: ViewController
\end_layout

\begin_layout Standard
Der ViewController ist unsere Basisklasse und wird uns von XCode zu Projektbegin
n bereitgestellt und stellt die Methoden 
\shape italic
viewDidLoad
\shape default
, 
\shape italic
viewDidUnload
\shape default
 (mit je einer kurzen Beschreibung) und die 
\shape italic
shouldAutorotateToInterfaceOrientation
\shape default
, mit welcher sich der Landscape Orientation-Modus ein- und ausschalten
 lässt.
 Aufgrund des fehlenden 
\shape italic
NavigationControllers
\shape default
 muss jede weitere View ihr aus erreichbar sein.
 Oberklasse von 
\shape italic
ViewController
\shape default
 ist die 
\shape italic
UIViewController
\shape default
, welche das fundamentelle View-Management-Modell für alle iOS Apps stellt.
 Die View beinhaltet mehrere Textfelder und implementiert demnach das 
\shape italic
UITextFieldDelegate
\shape default
-Protokoll.
 Dieses Protokoll definiert die darin möglichen Nachrichten, die ein Textfeld
 an seine Delegate-Klasse sendet, als Teil der Textbearbeitung.
 In der ViewController wird beispielsweise die im Protokoll enthaltene Methode
 textFieldShouldReturn so implementiert, dass nach dem Druck der Return-Taste
 auf der On Screen-Tastatur das Keyboard wieder vom Bildschirm ausgeblendet
 wird und - sofern das aktive Textfeld eben gerade das URL-Feld war - anschließe
nd die Methode 
\shape italic
go
\shape default
 aufgerufen wird, was den gleichen Effekt hat wie der Druck auf den Go-Button
 oben rechts am Bildschirm.
 Für das Textfeld, welches diese Methode aufrufen möchte, muss zwingend
 eine 
\shape italic
Delegate
\shape default
 spezifiziert werden.
 Dazu wird im Storyboard bei gedrückter Strg-Taste eine Verbindung vom Textfeld
 (hier: dem 
\shape italic
UITextField *url
\shape default
) zum Controller gezogen und das Outlet 
\shape italic
delegate
\shape default
 ausgewählt.
 Das Interface des entsprechenden Controllers wird automatisch um die entspreche
nde Deklaration des Protokolls erweitert.
 Der programmatische Weg wäre das manuelle Setzen der 
\shape italic
Delegate
\shape default
 mittels 
\family typewriter
\size small
[_url setDelegate:self];
\family default
\size default
.
 (Zur Erinnerung: 
\shape italic
url
\shape default
 wird als 
\shape italic
property
\shape default
 im Interface angegeben und es werden standardmäßig die Accessoren generiert.
 Der Zugriff auf 
\shape italic
url
\shape default
 über den Getter erfolgt über die Instanzvariable 
\shape italic
_url
\shape default
.)
\end_layout

\begin_layout Standard
Beispielhafte Implementation der Methode 
\shape italic
textFieldShouldReturn
\shape default
 im 
\shape italic
ViewController
\shape default
:
\end_layout

\begin_layout LyX-Code

\size small
- (BOOL)textFieldShouldReturn:(UITextField *)textField {
\end_layout

\begin_layout LyX-Code

\size small
   [textField resignFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   if (textField == _url)
\end_layout

\begin_layout LyX-Code

\size small
      [self go:nil];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _username)
\end_layout

\begin_layout LyX-Code

\size small
      [_password becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _keyTextField)
\end_layout

\begin_layout LyX-Code

\size small
      [_valueTextField becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _valueTextField)
\end_layout

\begin_layout LyX-Code

\size small
      [self addKeyValue:nil];
\end_layout

\begin_layout LyX-Code

\size small
   return YES;
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Weitere Elemente in dieser View, welche eine Delegate benötigen, sind zum
 einen die 
\shape italic
PickerView
\shape default
 links oben, in der man die zu verwendende HTTP-Methode selektiert sowie
 die 
\shape italic
TableView
\shape default
 auf der rechten Seite, in welcher sich Key/Value-Tupel aufnehmen lassen,
 welche sich bei einem PUT oder POST als Header hinzufügen lassen.
 Diese beiden Komponenten benötigen nicht nur ein Objekt, dem sie Nachrichten
 übermitteln können, die im weiteren Programmverlauf etwas anstoßen; sie
 benötigen darüber hinaus ebenfalls ein Objekt, bei dem sie Daten abfragen
 dürfen, die sie für ihre eigene Funktion benötigen.
 Das 
\shape italic
DataSource
\shape default
-Objekt liefert als Antwort auf die im Protokoll spezifizierten Nachrichten,
 die es von der 
\shape italic
PickerView
\shape default
 oder der 
\shape italic
TableView
\shape default
 empfängt, die benötigten Daten zurück.
 Oft handelt es sich dabei bei der 
\shape italic
Delegate
\shape default
 und der 
\shape italic
DataSource
\shape default
 um ein- und dasselbe Objekt, daher implementiert der 
\shape italic
ViewController
\shape default
 sowohl die Protokolle 
\shape italic
UIPickerViewDelegate
\shape default
 und 
\shape italic
UITableViewDelegate
\shape default
 als auch die Protokolle 
\shape italic
UIPickerViewDataSource
\shape default
 und 
\shape italic
UITableViewDataSource
\shape default
.
\end_layout

\begin_layout Standard
Auf die Anfrage der PickerView nach der Anzahl der Spalten reagiert das
 ViewController-Objekt mit der folgenden Methode:
\end_layout

\begin_layout LyX-Code

\size small
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {
\end_layout

\begin_layout LyX-Code

\size small
     return 1;
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ViewController1.tiff
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController nach geparster XML-Response.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ViewController2.tiff
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController im Landscape-Modus.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Senden einer Request
\end_layout

\begin_layout Standard
Die Grundstruktur ist die Folgende: Im URL-Textfeld ist die Adresse einzugeben,
 zu welcher der Request gesendet werden soll; im Picker links oben wird
 die auszuführende HTTP-Methode ausgewählt.
 Das Feld darunter bietet die Möglichkeit, zusätzliche Methoden in den Picker
 aufzunehmen, beispielsweise ein OPTIONS.
 Ist der Request ein PUT oder ein POST, so wird der im Body-Bereich des
 aktuell aktiven Tabs im Output-Fenster (Request/Response/Parsed) angezeigte
 Text dem Request als Body hinzugefügt.
 Dieser Textbereich ist somit bearbeitbar.
 Es sollte dabei niemals der Parsed-Tab aktiv sein, da dieser keinen gültigen
 JSON-/XML-Code enthält.
 Nach einem PUT oder einem POST befindet sich eine Kopie des gesendeten
 Bodys im Request-Tab zur eventuellen weiteren Bearbeitung.
 Wurde ein beliebiger Request durchgeführt und die Response erfolgreich
 auf JSON oder XML getestet und ist das Request-Fenster bislang noch leer,
 so wird dem Anwender an dieser Stelle ein JSON- bzw.
 ein XML-Template eingeblendet, welches er anpassen kann.
\end_layout

\begin_layout Standard
Möchte der Anwender einen PUT oder einen POST-Request absenden, so hat er
 im rechten Bereich die Möglichkeit, diesen um beliebige Header zu erweitern.
 Der Header Content-Length wird hierbei automatisch mit der tatsächlichen
 Länge der angehangenen Body-Nachricht gesetzt.
 An dieser Stelle kann man aus der angebotenen Liste einen gebräuchlichen
 General- oder einen Request-Header auswählen, man darf jedoch auch einen
 beliebiges Header/Werte-Paar eingeben.
 Zwei gleichnamige Header sind hier verständlicherweise ebenso wenig erlaubt,
 wie ein leeres Header- bzw.
 Wertefeld.
 Wird eine Headerzeile markiert, so wird der neue Header direkt darüber
 eingefügt und die Markierung entfernt; ist keine Headerzeile markiert,
 so wird das neue Tupel am Ende der Liste eingefügt.
 Die hier verwendete Datenstruktur sind die beiden Arrays headerKeysArray
 sowie headerValuesArray, an deren Indexwert x sich der Eintrag der x-ten
 Reihe des Headerfeldes findet.
 Zwar sind die Zellen ebenfalls in der Lage, Daten zu speichern, aufgrund
 der verwendeten ScrollView kommt es hierbei jedoch zu einem anormalen Programmv
erhalten: Als Container wurde eine ScrollView verwendet, darin wurde eine
 TableView plaziert.
 Das hat den Vorteil, dass es möglich ist, mehr Daten aufzunehmen, aus sichtbar
 sind - man kann sie einfach mit dem Finger scrollen.
 Scrollt man nun jedoch eine Zelle aus dem sichtbaren Bereich, existiert
 aktuell keine (sichtbare) Referenz mehr darauf und iOS setzt den Inhalt
 auf eine Reusable-Liste.
 Die Daten, die in der Zelle enthalten sind, werden entfernt.
 Kommt die Zelle nun wieder in den sichtbaren Bereich, so werden eben nicht
 die ensprechenden Daten wieder angefragt, sondern die DataSource des TableViews
 - der HeaderKeysViewController - wird die Methode tableView:cellForRowAtIndexPa
th aufgerufen, welche eine neue Zelle erzeugt.
 Diese würde sich in diesem Fall den Zelleninhalt aus den aktuellen Inhalten
 der Textfelder für den HTTP Header-Input besorgen, was nicht das ist, was
 an dieser Stelle passieren sollte.
 Da jedoch fernab der GUI die beiden Arrays existieren, deren Index mit
 der Reihenzahl äquivalent ist, kann die (Wieder-)Erzeugung der Zelle auf
 die entsprechenden Einträge der Arrays zugreifen:
\end_layout

\begin_layout LyX-Code

\size small
- (UITableViewCell *)tableView:(UITableView *)tableView
\end_layout

\begin_layout LyX-Code

\size small
  cellForRowAtIndexPath:(NSIndexPath *)indexPath {
\end_layout

\begin_layout LyX-Code

\size small
      static NSString *CellIdentifier = @"Cell";
\end_layout

\begin_layout LyX-Code

\size small
      UITableViewCell *cell =
\end_layout

\begin_layout LyX-Code

\size small
      [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size small
      if (cell == nil)
\end_layout

\begin_layout LyX-Code

\size small
          cell = [[UITableViewCell alloc]
\end_layout

\begin_layout LyX-Code

\size small
            initWithStyle:UITableViewCellStyleValue1
\end_layout

\begin_layout LyX-Code

\size small
          reuseIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size small
      NSString *cellText; if ([indexPath section] == 0) cellText =
\end_layout

\begin_layout LyX-Code

\size small
      [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size small
      [_generalHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size small
      else cellText = [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size small
      [_requestHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size small
      [[cell textLabel] setText:cellText];
\end_layout

\begin_layout LyX-Code

\size small
      return cell;
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout Standard
Befindet sich der hinzugefügte Header in der Liste der bekannten General
 Headers, so wird er mit grüner Schrift angezeigt, ist er ein bekannter
 Request Header, erscheint seine Schrift in Blaugrün.
 Befindet sich der hinzugefügte Header weder in der General- noch in der
 Request-Header-Liste, so wird dessen Name rot gefärbt.
 Dies soll der Vermeidung von Tippfehlern dienen.
\end_layout

\begin_layout Standard
Benötigt die Seite eine HTTP Basic Authentication oder eine HTTP Digest
 Authentication, so wird dieses App darüber benachrichtigt.
 Apple stellt hierfür den Methodenaufruf connection:didReceiveAuthenticationChal
lenge bereit, in welcher man auf diesen Umstand reagieren kann.
 Sind Authentifizierungsinformationen gegeben, so werden diese nun ausgelesen
 und dem angefragten Server übermittelt.
 Die Implementation dieser Methode sieht wie folgt aus:
\end_layout

\begin_layout LyX-Code

\size small
- (void)connection:(NSURLConnection *)connection
\end_layout

\begin_layout LyX-Code

\size small
  didReceiveAuthenticationChallenge:
\end_layout

\begin_layout LyX-Code

\size small
  (NSURLAuthenticationChallenge *)challenge {
\end_layout

\begin_layout LyX-Code

\size small
      [_authentication setText:@"required"];
\end_layout

\begin_layout LyX-Code

\size small
      NSLog(@"%@ received.",[challenge description]);
\end_layout

\begin_layout LyX-Code

\size small
      if ([challenge previousFailureCount] == 0) {
\end_layout

\begin_layout LyX-Code

\size small
          NSURLCredential *credential =
\end_layout

\begin_layout LyX-Code

\size small
          [NSURLCredential credentialWithUser:[_username text]         
                                                                    password:[_p
assword text]                                                          
     persistence:NSURLCredentialPersistenceNone];
\end_layout

\begin_layout LyX-Code

\size small
          [[challenge sender] useCredential:credential
\end_layout

\begin_layout LyX-Code

\size small
                 forAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size small
      } else {
\end_layout

\begin_layout LyX-Code

\size small
          [[challenge sender] cancelAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size small
          UIAlertView *alert =
\end_layout

\begin_layout LyX-Code

\size small
          [[UIAlertView alloc] initWithTitle:@"Error"
\end_layout

\begin_layout LyX-Code

\size small
                             message:@"Authentication incorrect."
\end_layout

\begin_layout LyX-Code

\size small
                            delegate:self
\end_layout

\begin_layout LyX-Code

\size small
                   cancelButtonTitle:@"Close"
\end_layout

\begin_layout LyX-Code

\size small
                   otherButtonTitles:nil];
\end_layout

\begin_layout LyX-Code

\size small
          [alert show];
\end_layout

\begin_layout LyX-Code

\size small
          [_authentication setBackgroundColor:
\end_layout

\begin_layout LyX-Code

\size small
              [[UIColor alloc] initWithRed:1 green:0 blue:0 alpha:0.1]];
\end_layout

\begin_layout LyX-Code

\size small
          [_authentication setText:@"failed"];
\end_layout

\begin_layout LyX-Code

\size small
          NSLog(@"%@ failed: Authentication incorrect.",
\end_layout

\begin_layout LyX-Code

\size small
          [challenge description]);
\end_layout

\begin_layout LyX-Code

\size small
      }
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout Subsection
Empfangen einer Response
\end_layout

\begin_layout Standard
Jede eingehende Response ruft die Methode 
\shape italic
connection:didReceiveResponse
\shape default
 auf.
 Hier werden die Informationsfelder gesetzt, die Header ausgelesen und auf
 das Header-Feld übertragen und überprüft, ob der Inhaltstyp als JSON oder
 XML angegeben wird.
 Liegt der vom Server zurückgelieferte Statuscode unter 400 deutet dies
 auf eine positive Antwort auf unsere Request hin.
 Es wird nun ein neues Historyelement erzeugt und mit der erfolgreich bearbeitet
en URL gefüllt.
\end_layout

\begin_layout Standard
Trifft eine Response ein, die neben der Response einen Body enthält, wird
 mit diesem die Methode connection:didReceiveData aufgerufen.
 Werden noch weitere Teilresponses erwartet, bis die Nachricht vollständig
 eingegangen ist, werden die Daten mittels 
\family typewriter
\size small
[responseBodyData appendData:_bodyData]
\family default
\size default
 der statischen Variable 
\shape italic
responseBodyData
\shape default
 hinzugefügt.
 Ist die Response vollständig, so wird die Methode connectionDidFinishLoading
 aufgerufen, in der vollständige Body abgearbeitet wird.
 Anhand des ersten Bytes wird überprüft, ob es sich um ein Bild handelt.
 Ist das der Fall, so wird eine ImageView in die ScrollView eingebettet,
 welche das Bild anzeigt.
 Ist dies nicht der Fall und es wurde bereits vorher erkannt, dass es sich
 um JSON- oder um XML-Code handelt, wird der Body an den entsprechenden
 Parser übergeben.
 Im Apple Foundation-Framework findet sich schon seit geraumer Zeit der
 NSXMLParser, seit iOS 5 wurde es nun auch um die NSJSONSerialization erweitert,
 welches ein NSData-Objekt parst und ein NSDictionary zurückliefert.
 In beiden Fällen werden die Keys als auch die Values in je ein eigenes
 MutableArray gepackt.
 Wurde das Parsen erfolgreich abgeschlossen (im Falle des XML-Parsers bedeutet
 das, dass er nach erfolgter Durchführung ein YES zurückliefert, im Falle
 des NSJSONSerializers bedeutet erfolgreich einfach, dass das Array nicht
 leer ist), wird die rekursive Methode processKeys aufgerufen.
 Die einzelnen Key/Value-Paare werden nun schrittweise überprüft, ob es
 sich hierbei um eine Ressource handelt.
 Da es durchaus sein kann, dass als Value ein komplettes Array mit weiteren
 Key/Value-Paaren auftritt, ist es in hohem Maße erwünscht, dass diese Methode
 rekursiv aufrufbar ist.
 Da hier durchaus Key/Value-Paare gelöscht werden (im Falle eines Arrays
 als Value, welcher abgearbeitet wurde und somit keine weitere Funktion
 mehr erfüllt) oder eingeschoben werden (anstelle des Subarrays), ist das
 Mitführen eines statischen Indexes staticIndex erforderlich.
\end_layout

\begin_layout Standard
Zum Vorbereiten des Tests auf eine valide URL wird der String in einem ersten
 Schritt in eine Variable des Typs NSURL umgewandelt.
 Hier wir intern getestet, ob die Zeichen für eine URL valid sind.
 Ist dem nicht der Fall, wird nil zurückgegeben.
 Wird kein nil zurückgegeben, wird der Stringanfang überprüft.
 Beginnt dieser mit http, wird er unverändert als URL interpretiert.
 Beginnt er statt dessen mit einem Schrägstrich, wird er an die Basis URL
 des zuletzt aufgerufenen Requests gehangen und dann zur Überprüfung auf
 eine valide URL weitergegeben.
 Treffen beide Anfänge nicht zu, so wird das höchste Verzeichnis, welches
 sich im letzten Aufruf finden lässt, um diesen String erweitert und ebenfalls
 getestet, ob es sich um eine valide URL handelt.
\end_layout

\begin_layout Standard
Um den Test anschließend durchzuführen, wechselt die App mittels 
\family typewriter
\size small
[self setValidatingState:YES]
\family default
\size default
 in einen zweiten Zustand, in dem Responses erwartet werden.
 Es werden für jeden Resourcenkandidaten ein asynchroner HEAD-Request abgesendet
, mit dessen Antworten anders umgegangen wird, als es mit normalen Responses
 der Fall wäre.
 Ein nebenbei laufender Counter führt Buch über den aktuellen Fortschritt.
 Da die Methode, die mit der Überprüfung beauftragt wurde, wissen muss,
 um welches Key/Value-Paar es sich handelt und die Methode didReceiveResponse
 eben nur die Nachricht kennt, die sie empfängt, wird die ID der abgesendeten
 NSURLConnection zusammen mit dem Index des zu überprüfenden Wertes in ein
 NSDictionary gepackt.
 In der empfangenden Methode kann anhand der ID der Response der Indexwert
 aus dem Wörterbuch gefischt werden und es ist wieder klar, welchem Key/Value-Pa
ar der empfangene Statuscode zugeordnet werden kann.
 Auch hier weist ein Statuscode von unter 400 auf die Existenz der angefragten
 Resource hin und der angefragte Wert wird in die MutableArrays foundResourceKey
s sowie foundResourceValues geschrieben.
 Da eine synchrone Überprüfung zu viel Zeit in Anspruch nehmen würde, ein
 asynchroner Request jedoch den Nachteil hat, dass die überprüften Resourcen
 nun in beliebiger Reihenfolge im Zielarray landen würden, habe ich mir
 mit einem kleinen Trick beholfen: Die Arrays foundResourceKeys und foundResourc
eValues werden mit der Größe der Resourcenkandidaten angelegt und mit einem
 leeren Stringobjekt initialisiert.
 Eine überprüfte Resource, die sich im Quellarray an Index y befindet, wird
 in das Zielarray ebenfalls an den Index y geschrieben, so dass später alle
 Felder, die keine Validen Resourcen enthalten, weiterhin leere Strings
 beinhalten.
 Da es sich um ein MutableArray handelt, lassen sich, nachdem alle Kandidaten
 abgearbeitet wurden, die Arrays bereinigen, in dem man die Felder mit den
 leeren Strings aus dem Array entfernt.
\end_layout

\begin_layout Section
Hilfsklassen
\end_layout

\begin_layout Subsection
ResourceTableViewController
\end_layout

\begin_layout Subsection
HeaderKeysViewController
\end_layout

\begin_layout Subsection
XMLParser
\end_layout

\begin_layout Subsection
LogOutputViewController
\end_layout

\begin_layout Subsection
HistoryElement
\end_layout

\begin_layout Subsection
ViewController
\end_layout

\begin_layout Subsection
...
 und die AppDelegate?
\end_layout

\begin_layout Standard
Erstellt man ein neues Projekt, bekommt man zwei Dateien vor die Nase gesetzt:
 eine AppDelegate und den ViewController.
 Konzeptuell sollte der ViewController alles beinhalten, womit sich die
 aktuelle View beschäftigt.
 Die AppDelegate bleibt dabei erschreckend leer und hinterlässt das Gefühl,
 dass man doch etwas Wichtiges vergessen hat.
 Die einzige Methode, die überhaupt etwas macht ist die application didFinishLau
nchingWithOptions:launchOptions: Sie gibt ein YES zurück.
 Immerhin.
\end_layout

\begin_layout Standard
Auch hier läuft wieder alles über das Storyboard.
 Wirft man einen Blick auf die Datei 
\shape italic
REST Analyzer-Info.plist
\shape default
 findet sich ein Schlüssel mit der Bezeichnung 
\shape italic
Main storyboard file base name
\shape default
 und dem Wert 
\shape italic
MainStoryboard
\shape default
.
 Die Bedeutung hinter diesem Eintrag ist Folgende: Ist diese Einstellung
 gesetzt, lädt UIApplication die Datei mit der Bezeichnung MainStoryboard.storybo
ard, instantiiert den ersten ViewController und packt dessen View in ein
 neues Objekt des Typs UIWindow.
 Kein Programmieraufwand nötig.
\end_layout

\begin_layout Section
GUI (3 - 4 Seiten)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Storyboard.png
	lyxscale 45
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GUI im Storyboard
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verwendete Grafiken:
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34203/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34206/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34224/256/browser_earth_internet_world_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34211/128/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34212/128/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49232/256/arrow_left_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49243/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49243/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34229/256/find_magnifier_search_zoom_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/54479/128/code_folder_icon
\end_layout

\begin_layout Section
Schwierigkeiten (ca.
 3 Seiten)
\end_layout

\begin_layout Description
Problem: Der RKObjectManager mappt die Werte zu den Keys, die er in seiner
 Delegierten angegeben hat.
 In einem generischen Clienten kann man die Schlüssel schlecht bereits vordefini
eren.
\end_layout

\begin_layout Description
Lösung: Selbst parsen und mappen.
 Parser aus dem Apple-Framework verwenden.
\end_layout

\begin_layout Description
Problem: RKClient kann kein HEAD.
\end_layout

\begin_layout Description
Lösung: Selbst eine Verbindung aufbauen.
 Framework obsolet.
\end_layout

\begin_layout Description
Problem: In Storyboard erzeugter Table View Controller erzeugt eigene Instanz
 der View, Inizialisierung programatisch im Code erzeugt wieder eine eigene.
\end_layout

\begin_layout Description
Lösung: Der Storyboard-Segue einen Identifier zuweisen und mit der Methode
 prepareForSegue der Zielinstanz die Variable übergeben.
\end_layout

\begin_layout Description
Problem: URL soll zur 
\begin_inset Quotes eld
\end_inset

darunterliegenden
\begin_inset Quotes erd
\end_inset

 View übergeben werden und die View geschlossen.
\end_layout

\begin_layout Description
Lösung: Referenzen weiterreichen.
 Zum Schließen der View die Referenz des PopoverControllers weiterleiten,
 dann kann die View 
\begin_inset Quotes eld
\end_inset

von oben
\begin_inset Quotes erd
\end_inset

 geschlossen werden.
\end_layout

\begin_layout Description
Problem: Nachdem das Programm auf iOS 6 problemlos läuft, stürzt es unter
 5.1.1 ab.
\end_layout

\begin_layout Description
Ursache: Unter iOS 6 wird, wenn ein 
\begin_inset Quotes eld
\end_inset

prepareForSegue
\begin_inset Quotes erd
\end_inset

 erkannt wird, der Aufbau der View verzögert, bis die Methode abgearbeitet
 wurde.
 Unter iOS 5.1.1 ist das nicht der Fall, die View wird sofort angelegt.
 Das Dictionary, das in der viewDidLoad in ein Array gefüllt wird, ist noch
 nicht vorhanden, alle Zellen werden (null).
 
\end_layout

\begin_layout Description
Lösung: die Initialisierung des Arrays verschieben von viewDidLoad nach
 viewDidAppear.
\end_layout

\begin_layout Description
Problem: Parsen von großen Inhalten schlägt fehl und die Anzeige im Body
 ist defekt.
\end_layout

\begin_layout Description
Ursache: Jeder Body wurde einzeln abgearbeitet und versucht, zu parsen.
 Fragmente, die demnach falsch anfingen, verursachten einen Fehler.
\end_layout

\begin_layout Description
Lösung: Auslesen der Content Length und abwarten, bis alle Responses eingetroffe
n sind.
 Erst dann parsen.
\end_layout

\begin_layout Description
Problem: Beim Öffnen der Logging View muss erst ein Refresh-Button betätigt
 werden, damit der Log angezeigt wird.
\end_layout

\begin_layout Description
Ursache: Nach dem Anzeigen der View muss das Textfeld aktualisiert werden,
 mit einer Segue lässt sich das so nicht realisieren, das Textfeld müsste
 in einer viewDidAppear ausgeführt werden.
\end_layout

\begin_layout Description
Lösung: Die Output View in eine eigene Klasse auslagern, die eine Methode
 ViewDidAppear besitzt.
\end_layout

\begin_layout Description
Problem: Füllt man ein Table View mit Zellen und packt diese in einen Scroll
 View-Container, so verschwinden die Zellen beim 
\begin_inset Quotes eld
\end_inset

Wischen
\begin_inset Quotes erd
\end_inset

 aus dem sichtbaren Bereich.
\end_layout

\begin_layout Description
Ursache: ARC greift an dieser Stelle und setzt nicht sichtbare Elemente
 auf die Reusable-List.
 Kommen die Zellen wieder in den sichtbaren Bereich, wird die Methode ...
 wieder durchlaufen und erzeugt neue Zellen.
\end_layout

\begin_layout Description
Lösung: Die Daten waren hier in der GUI angelegt, welches einen Verstoß
 gegen den Model View Controller (MVC) darstellt.
 Vor der Zellenerzeugung werden 2 MutableArrays angelegt, deren Inhalt sich
 stets am gleichen Indexwert befindet, wie es bei den Zellen der Fall ist.
 Die Zellenerzeugung greift dann auf den entsprechenden Index im Array zu,
 welcher nicht dereferenziert wird.
\end_layout

\begin_layout Chapter
Distribution (2 Seiten)
\end_layout

\begin_layout Section
Der offizielle Weg: Apple's App Store
\end_layout

\begin_layout Section
Die Alternative: Cydia Store
\end_layout

\begin_layout Standard
Zum offiziellen Vertriebsweg über den Apple App Store gibt es eine Alternative,
 über die man jedoch nur freigeschaltete 
\begin_inset Quotes eld
\end_inset

gejailbreakte
\begin_inset Quotes erd
\end_inset

 Geräte Zugriff haben: Mit dem 
\shape italic
Cydia Store
\shape default
, der standardmäßig bei jedem Jailbreak gleich mitinstalliert wird.
 Mit diesem kann man sich, wie unter Linuxsystemen bekannt, mit verschiedenen
 Repositories verbinden und auf deren Angebot zugreifen.
 Hierbei ist der 
\shape italic
Cydia Store
\shape default
 nicht als ein Distributionssystem für raubkopierte Software zu verstehen,
 denn er implementiert ebenfalls ein Bezahlsystem, mit dem Entwickler in
 der Lage sind, ihre Anwendungen entgeltlich anzubieten.
 Interessant wird diese Vertriebsmethode, wenn man eine App entwickeln möchte,
 die die Rechte, die Apple einer solchen Anwendung zugesteht, bei weitem
 überschreitet.
 Ein sehr schönes Beispiel für eine solche Anwendung ist der Windowmanager
 
\shape italic
Quasar
\shape default
, der eine Alternative bietet zu Apples Zwangvorschrift, jede Anwendung
 im Vollbild betreiben zu müssen.
 Vor allem auf dem iPad der dritten Generation kann es durchaus eine wünschenswe
rte Option sein, zwei oder mehr Fenster nebeneinander betreiben zu können.
 So könnte man beispielsweise auf der einen Seite ein Textverarbeitungsprogramm
 laufen haben, während auf der anderen Bildschirmhälfte ein Internetbrowser
 geöffnet ist.
\end_layout

\begin_layout Standard
Um unsere mittels unserer Entwicklerlizenz kompilierten Apps in ein DEB-Paket
 umzuwandeln, bedienen uns bequem des Programmes MacPorts, welches – ähnlich
 Fink – eine Paketverwaltung für freie und quelloffene Software für OS X
 ist.
\end_layout

\begin_layout Description
Quelle: http://www.macports.org/
\end_layout

\begin_layout Standard
Da sich dieses Programm nach /opt/local/bin installiert, fügen wir dieses
 Verzeichnis unserem Pfad hinzu:
\end_layout

\begin_layout LyX-Code

\size small
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
\end_layout

\begin_layout Standard
Nun folgt ein Update dessen Paketquellen:
\end_layout

\begin_layout LyX-Code

\size small
sudo port selfupdate
\end_layout

\begin_layout Standard
und die Installation des gewünschten Paketes dpkg:
\end_layout

\begin_layout LyX-Code

\size small
sudo port install dpkg
\end_layout

\begin_layout Standard
welche den gewünschten Befehl dkgp-deb bereitstellt.
 Mit diesem sind wir nun in der Lage, aus den fertigen Apps Cydia-Repo-konforme
 DEB-Pakete zu erstellen.
\end_layout

\begin_layout Standard
Zum Konvertieren in ein DEB-Paket besteht dpkg-deb jedoch auf eine Struktur,
 welche sich wie folgt aufbaut:
\end_layout

\begin_layout LyX-Code

\size small
+- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   +- Applications
\end_layout

\begin_layout LyX-Code

\size small
   |  +- MyProgram.app
\end_layout

\begin_layout LyX-Code

\size small
   |     +- Info.plist
\end_layout

\begin_layout LyX-Code

\size small
   |     +- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   |     +- icon.png
\end_layout

\begin_layout LyX-Code

\size small
   +- DEBIAN
\end_layout

\begin_layout LyX-Code

\size small
   |  +- control
\end_layout

\begin_layout LyX-Code

\size small
   +- System
\end_layout

\begin_layout LyX-Code

\size small
      +- Library
\end_layout

\begin_layout LyX-Code

\size small
         +- LaunchDaemons
\end_layout

\begin_layout LyX-Code

\size small
            +- com.identifier.MyProgram.plist
\end_layout

\begin_layout Standard
Das Verzeichnis System ist hierbei optional.
\end_layout

\begin_layout Standard
Die Datei control kann folgende Einträge beinhalten: Package, Name, Version,
 Architecture, Description, Homepage, Depiction, Maintainer, Author, Sponsor,
 Section.
 Zwingend vorgeschrieben sind davon jedoch nur Package und Version.
\end_layout

\begin_layout Standard
Darüber hinaus erstellt OS X, wenn TAR-Dateien erzeugt werden – die ein
 Teil der internen Struktur eines Debian-Paketes darstellen – einige ._*-Dateien,
 welche zusätzliche Informationen enthalten.
 Diese zusätzlichen Dateien würden zusammen mit dem Paket installiert werden
 und Konflikte mit anderen Paketen erzeugen (abgesehen davon, dass diese
 Dateien einfach nicht in unser Paket gehören).
 Um dieses Feature zu deaktivieren werden folgende Umgebungsvariablen exportiert
:
\end_layout

\begin_layout LyX-Code

\size small
export COPYFILE_DISABLE
\end_layout

\begin_layout LyX-Code

\size small
export COPY_EXTENDED_ATTRIBUTES_DISABLE
\end_layout

\begin_layout Standard
Sind wir nun soweit wechseln im Terminal ins Verzeichnis 
\begin_inset Quotes eld
\end_inset

MyProgramm
\begin_inset Quotes erd
\end_inset

 und erzeuen unser DEB-Paket mittels:
\end_layout

\begin_layout LyX-Code

\size small
dpkg-deb -b MyProgram
\end_layout

\begin_layout Description
Quelle: http://www.saURLk.com/id/7
\end_layout

\begin_layout Subsubsection
Vom DEB-Paket aufs Device
\end_layout

\begin_layout Standard
Um die nun fertige DEB-Datei auf das iPad zu bekommen, benötigen wir ein
 Cydia-kompatible Repository.
 Hierfür habe ich auf das kostenlose Angebot von MyRepoSpace zurückgegriffen,
 in dem man die fertigen Pakete komfortabel über ein Webinterface in die
 Source lädt.
 Die im Cydia Store eingebundene Paketquelle lautet:
\end_layout

\begin_layout LyX-Code

\size small
http://cydia.myrepospace.com/RaveAngel/
\end_layout

\begin_layout Chapter
Schlusswort (1 Seite?)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Dissertation Fielding"

\end_inset

Fielding, Roy (2000) Dissertation: Architectural Styles and the Design of
 Network-based Software Architectures
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bayer - REST Einführung"

\end_inset

Bayer, Thomas (2002): REST Webservices: Eine Einführung
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JAXenter"

\end_inset

Tilkov, Stefan (2009): REST - Der bessere Webservice? In: JAXenter, URL:
 http://it-republik.de/jaxenter/artikel/REST---Der-bessere-Web-Service-2158.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - Webservice"

\end_inset

Wikipedia: Web service, URL: http://en.wikipedia.org/wiki/Web_service (letzter
 Aufruf am 5.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - REST"

\end_inset

http://de.wikipedia.org/wiki/Representational_State_Transfer
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JSON.org - Einführung in JSON"

\end_inset

Introducing JSON, URL: http://json.org/index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "W3C - XML Essentials"

\end_inset

XML ESSENTIALS, URL: http://www.w3.org/standards/xml/core
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "The Objective-C Programming Language"

\end_inset

https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjectiveC
/Introduction/introObjectiveC.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Learning Objective-C"

\end_inset

http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/Learning_O
bjective-C_A_Primer/_index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Galileo Computing"

\end_inset

Rodewig, Klaus M.
 / Wagner, Clemens: Apps entwickeln für iPhone und iPad - Das Praxisbuch,
 Galileo Computing, 2012, URL: http://openbook.galileocomputing.de/apps_entwickeln
_fuer_iphone_und_ipad/index.html
\end_layout

\end_body
\end_document
