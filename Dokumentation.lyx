#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass ucthesisLyx
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Einleitung
\end_layout

\begin_layout Standard
Im Programmieralltag eines Informatikers an der Universität Trier beschäftigt
 man sich hauptsächlich mit der plattformunabhängigen objektorientierten
 Programmiersprache Java.
 Sie eignet sich aufgrund ihrer Portabilität hervorragend als Einsteigersprache,
 denn die für das Ausführen benötigte Laufzeitumgebung kann man sich für
 nahezu jedes Betriebssystem herunterladen und installieren.
 Eine Ausnahme bildet das mobile Betriebssystem iOS, für welches Apple die
 Entwicklung einer Java Runtime nicht gestattet.
 Maschinennähere Erfahrungen sammelt man in C++, welches auf dem prozeduralen
 ANSI-C basiert, jedoch zahlreiche Erweiterungen in Hinblick auf die objektorien
tierte Programmierung bietet, seien es Möglichkeiten zur Datenkapselung,
 Vererbung oder Polymorphie, um nur einige zu nennen.
 Dazu wurden Sprachkonstrukte von C abgeändert, so dass manche C-Programme
 abgepasst werden müssen, um sich als C++-Programm übersetzen zu lassen.
 Einen etwas anderen Ansatz geht Apple mit der Programmiersprache Objective-C,
 welche ursprünglich als Basis für das Betriebssystem NextStep verwendet
 wurde.
 Mit der Übernahme zu Apple wurde die aus NextStep hervorgehende OpenStep-API
 ebenfalls Grundlage für OS X, womit sich auch die zu Systemsprache von
 Pascal auf Objective-C änderte.
 Anders als C+ greift Objective-C für die objektorientierte Erweiterung
 auf die Sprache Smalltalk zurück, in der mit Nachrichtenkommunikation gearbeite
t wird und in der es nur drei eingebaute ausführbare Konstrukte gibt: Eine
 Botschaft wird an ein Objekt gesendet, einer Variable wird ein Objekt zugewiese
n oder ein Objekt wird als Rückgabewert einer Methode zurückgeliefert.
 Die Smalltalk-Erweiterung ist von der gewöhnlichen C-Syntax strikt getrennt,
 somit gibt es kein Problem, herkömmlichen C-Code zu übersetzen.
 Dieser andersartige Ansatz macht neugierig, einmal selbst in die Tiefen
 des auf Nachrichten basierenden C-Derivates abzutauchen und einen genaueren
 Blick auf das Konzept hinter den vielen eckigen Klammern zu werfen, mit
 denen sich ein in Objective-C geschriebenes Programm präsentiert.
 Der TIOBE-Index, der seit 2001 ein monatlich aktualisiertes Ranking von
 Programmiersprachen nach ihrer Popularität publiziert, listet Objective-C
 hinter C und Java derzeit auf Platz 3 der am meisten verwendeten Programmierspr
achen.
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: TIOBE Programming Community Index for November 2012, Headline: Objective
-C on its way to become "language of the year" again
\end_layout

\end_inset

 Die Tendenz: kontinuierlich steigend.
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: TIOBE Programming Community Index Objective-C
\end_layout

\end_inset

 Diese Arbeit bietet eine attraktive Möglichkeit, sich im universitären
 Rahmen in diesen Bereich einzuarbeiten und einen Blick über den Tellerrand
 zu werfen.
 Eine Möglichkeit, die ich hiermit gerne ergreifen möchte.
\end_layout

\begin_layout Standard
Für die Entwicklung auf seinen Systemen stellt Apple mit Xcode eine Entwicklungs
umgebung, die nach eigenen Angaben mächtig genug ist, dass sie von Apple
 selbst zur Entwicklung von Betriebssystemen und Anwendungen eingesetzt
 wird - und in den aktuellen Versionen angeblich eine sehr einfach zu erlernende
 Oberfläche für den Entwurf der GUI mit sich bringt.
 Neben der Entwicklung einer Anwendung für einen Apple Macintosh bietet
 sich mit einer relativ neuen Technologie jedoch noch ein weiteres Stück
 Hardware des Unternehmens aus Kalifornien an: Im Jahr 2010 landete mit
 dem iPad die Sparte der “Post-PC”-Tablets im Mainstream-Bereich, die 2005
 ihren ersten Kandidaten mit dem Nokia 770 Internet-Tablet hatte.
 Diese Post-PCs waren keine herkömmlichen Notebooks mit Tastatur mehr, die
 über für Stift-Bedienung ausgelegte Touchscreen verfügten, sie waren wesentlich
 leichter und dünner, liefen mit eigenen, angepassten Betriebssystem und
 verfügten über eine innovatives Bedienkonzept für Fingerberührungen - auch
 wenn das beim Nokia 770 noch nicht der Fall war.
 Auch heute liegt der Marktanteil von Apples iPad noch bei über 50 %
\begin_inset Foot
status open

\begin_layout Plain Layout
Der Apple-Marktanteil am Tablet-Markt betrug lt.
 einer IDC-Pressemitteilung vom 5.
 November 2012 50,4 %.
\end_layout

\end_inset

, so ist es sicherlich eine lohnende Erfahrung, den “Blick über den Tellerrand”
 zusätzlich auf dieses neuartige Stück Hardware zu richten und eine Anwendung
 zu schreiben, die auf Apples mobilem Betriebssystem iOS läuft.
\end_layout

\begin_layout Standard
Als Anwendungsbeispiel für diese ersten Schritte in einer neuen Umgebung
 wird ein Client implementiert, der die Verbindung mit einem mir ebenfalls
 neuen Bereich herstellt: RESTful Webservices.
 Die Abkürzung REST steht für Representional State Transfer und ist ein
 Programmierparadigma für Webanwendungen, welches im Grunde so alt ist wie
 das Internet selbst.
 Dieser erst 2000 in einer Dissertation eingeführte Standard beschreibt
 die Implementation eines Webservices, mit dem die bereits im HTTP-Protokoll
 definierten Methoden GET, PUT, POST, DELETE und HEAD auf statistischen
 Inhalten arbeiten.
 Diese werden wiederum auf permanente URLs abgebildet.
 Da die Funktionalität REST-konformer Webservices immer auf diese HTTP-Methoden
 abgebildet wird, sollte es möglich sein, einen generischen Client zu entwickeln
, der mit all diesen Webservices irgendwie eine gemeinsame Kommunikationsschnitt
stelle bildet.
 Es sollen Anfragen gesendet und Antworten ausgewertet werden.
 Diese Antworten bekommt man in der Regel im Format XML oder JSON zurückgeliefer
t.
 Der Client sollte in der Lage sein, diese Daten zu analysieren, die potentielle
n Ressourcen darin zu erkennen, sie zu validieren und aufzubereiten und
 dem Anwender eine einfache Möglichkeit bieten, mit diesen zu interagieren.
\end_layout

\begin_layout Standard
Auf dem Weg zum funktionsfähigen Client wird zunächst ein kurzer Einblick
 in die Werkzeugkiste gegeben, mit der hier gearbeitet wird.
 Es wird kurz die Programmiersprache Objective-C vorgestellt und einige
 Eigenheiten aufgezeigt, die man in dieser Form so nicht in der Java- oder
 C++-Welt findet.
 Weiterhin wird die von Apple verwendete API Cocoa Touch vorgestellt und
 die Entwicklungsumgebung Xcode, mit der auf diese zugegriffen wird.
 Im darauffolgenden Kapitel wird auf die Schnittstelle mit der REST-Welt
 eingegangen.
 Es wird erklärt, was im Genauen unter einem REST-kompatiblen Webservice
 zu verstehen ist und wie man mit diesen kommuniziert.
 Den letzten größeren Bereich stellt die Implementation der fertigen Software,
 deren Funktionalität anhand genereller Abläufe beschrieben wird.
 Weiter wird hier auf die Probleme, die sich während des Entwickelns dieser
 Arbeit ergaben, näher eingegangen.
 Abgerundet wird diese Arbeit durch einen reflektiven Abriss der vorhergegangen
 Kapitel und einen persönlichen Ausblick darauf, ob die herausgearbeiteten
 Erfahrungen den Ausflug in die Welt der Apple-Systeme beenden oder den
 Grundstein bilden für weitere Entwicklungen auf den mobilen Systemen der
 Kalifornier.
 
\end_layout

\begin_layout Chapter
Die Werkzeugkiste
\end_layout

\begin_layout Section
Basissprache: Objective-C
\end_layout

\begin_layout Standard
Das Entwickeln der ersten App für Apple-Hardware bringt die Herausforderung
 mit sich, eine neue Programmiersprache erlernen zu müssen.
 So wie Microsoft für sein .NET-Framework die C#-Sprache entwickelte, welche
 Grundkonzepte der objektorientierten Hochsprachen C++, Java und Delphi
 in sich vereint, so verwendet Apple für seine Systeme die Sprache Objective-C.
 Anders als C# greift das in den frühen 80ern entwickelte Objective-C auf
 das prozedurale ANSI-C zurück.
 Seine objektorientierte Erweiterung ist eine Anlehnung an Smalltalk und
 wird als solche von der C-Syntax strikt getrennt.
 Die syntaktisch wichtigsten Neuerungen sind wie bei anderen Erweiterungskonzept
en hauptsächlich die Verwendung von Klassen und Methodenaufrufen.
 Analog kann dieser Ansatz dazu verwendet werden, aus Pascal und Javascript,
 die beide von Haus aus über kein Klassenkonzept verfügen, die objektorientierte
n Erweiterungssprachen Objective-Pascal und Objective-J zu erzeugen.
\end_layout

\begin_layout Standard
Wie aus der C-Welt bekannt, wird in einer Header-Datei mit der Endung .h
 das Interface deklariert, die Implementierungen erfolgt in der dazugehörigen
 .m-Datei, welche Objective-C- oder einfachen C-Code enthalten kann.
 Aus Kompatibilitätsgründen lassen sich Implementierungen mit der Dateiendung
 .mm anlegen, dieser darf expliziten C++-Code enthalten, was die Weiterverwendung
 von C++-Bibliotheken erlaubt.
 Statt #include sollte man bei Objective-C auf #import zurückgreifen, da
 es sicher stellt, dass jede einzubindende Datei auch nur höchstens einmal
 eingebunden wird.
\end_layout

\begin_layout Standard
In Objective-C werden keine Funktionen mehr mit Parametern aufgerufen.
 Statt dessen verwendet man Objekte, die sich untereinander Nachrichten
 senden und so miteinander kommunizieren.
 Diese Nachrichten veranlassen ein Objekt, eine Methode auszuführen.
 Dieses Paradigma wird als Message Passings bezeichnet und unterscheidet
 sich stark von der Art der Methodenaufrufe, die man C++ verwendet.
 Es darf grundsätzlich jedes Objekt jede beliebige Nachricht an jedes Objekt
 senden - oder auch an sich selbst, in dem Fall wird der Bezeichner self
 verwendet - ganz gleich ob die Zielklasse oder eine beerbte Oberklasse
 die passende Methode zu dieser Nachricht implementiert.
 Da Methoden stets erst zur Laufzeit ermittelt werden und nicht bereits
 beim Übersetzen, entscheidet sich erst beim Aufruf, wie ein Objekt auf
 eine Nachricht reagieren wird.
 Dieses Verfahren bezeichnet man daher auch als dynamisches Binden.
 Im Gegensatz dazu werden die verwendeten C-Funktionen bereits beim Übersetzen
 statisch gebunden.
 Konsequenterweise existiert ebenfalls eine Methode, welche auf Nachrichten
 reagiert, für die keine eigene Implementierung durch die Klasse bereitgestellt
 wird.
 Abstrakte Klassen kennt Objective-C übrigens nicht.
 Jede Klasse muss vollständig implementiert werden, damit jederzeit Objekte
 dieser Klasse erzeugt werden können.
 Um dies zu umgehen lassen sich Protokolle deklarieren, in denen notwendige
 Methoden unter dem @required-Tag aufgelistet werden.
\end_layout

\begin_layout Standard
Wie in C++ lassen sich aus einer Klasse Objekte erzeugen.
 Darüber hinaus ist aber jede Klasse auch selbst als Objekt ansprechbar.
 Diese enthalten jedoch keine Member-Variablen und sind stets Singletons,
 also Entwurfsmuster, die sicher stellen, dass von einer Klasse genau ein
 Objekt existiert, welches global verfügbar ist.
 Da ein solches Klassenobjekt ebenfalls für beliebige Nachrichten empfänglich
 ist, erfolgt das Binden seiner Methoden auch erst zur Laufzeit.
 Strings werden in Objective-C mit der Notation @”…” erzeugt.
 Ein solcher String ist ein Objekt vom Typ NSString und als solcher ebenfalls
 in der Lage, Nachrichten zu empfangen.
 Das vorangestellte @ ist ein Indikator für ein Objective-C-Objekt.
 Wird es bei der Angabe des String weggelassen, wird der bekannte, nullterminier
te C-String erzeugt.
 Per Vorgabe besitzen die Datentypen in Objective-C die gleiche Typisierung
 wie in C: Sie sind statisch, schwach und explizit.
 Das Konzept der dynamischen Typisierung ist mit dem typlose Datentyp id
 umgesetzt, welcher einen Zeiger auf ein Objekt einer beliebigen Klasse
 repräsentiert und an den jede beliebige Nachricht gesendet werden kann.
 Ist für den tatsächlichen Typ dieses Objektes diese Methode jedoch unbekannt
 oder möchte man eine typlose Variable an eine typgebundene Variable zuweisen,
 deren Typen nicht übereinstimmen, so kommt es zu einem Laufzeitfehler.
\end_layout

\begin_layout LyX-Code

\size small
id stringObject = @"Objective-C is great."; // OK
\end_layout

\begin_layout LyX-Code

\size small
NSString *string = stringObject;            // OK
\end_layout

\begin_layout LyX-Code

\size small
NSNumber *number = stringObject;            // logischer Fehler
\end_layout

\begin_layout LyX-Code

\size small
char character = [number charValue];        // Laufzeitfehler
\end_layout

\begin_layout Standard
Instanzobjekte einer Klasse werden durch das Senden einer entsprechenden
 Nachricht an das zugehörige Klassenobjekt erzeugt.
 Für Gewöhnlich geschieht dies beim Programmstart, jedoch können im Gegensatz
 zu C++ bei Objective-C jederzeit auch während der Laufzeit noch neue Objekte
 erstellt werden.
 Überladene Methoden, wie man sie in C++/Java kennt, findet man so in Objective-
C nicht mehr, denn eine Nachricht an eine Methode besteht aus dem Selektor,
 der sich aus dem Methodennamen und den Parametern zusammensetzt.
 Das Laufzeitsystem sucht bei einer eingehenden Nachricht nach einer solchen
 Methode und führt diese im Erfolgsfall aus.
 Wird keine passende Methode lokalisiert, wird ein nil zurückgeliefert.
 Möchte man sich absichern, lässt sich das Objekt im Voraus fragen, ob es
 eine bestimmte Nachricht versteht.
 Diese Fähigkeit der Selbstkenntnis beinhaltet ebenfalls das Ermitteln der
 eigenen Klasse und das Wissen, ob seine Klasse eine Unterklasse einer bestimmte
n anderen Klasse ist.
 Der Begriff Reflexion sollte dem ein oder anderen ebenfalls aus der Java-/C++-W
elt bekannt sein.
\end_layout

\begin_layout LyX-Code

\size small
if([geometricFigure respondsToSelector:@selector(getShape)]) { ...
 }
\end_layout

\begin_layout Standard
Dem Smalltalk-Erweiterungsanteil verdankt Objective-C die verwendete Notation
 der eckigen Klammern, die ausdrückt, dass an dieser Stelle Nachrichten
 versendet werden.
 An erster Stelle wird das Empfängerobjekt genannt, anschließend folgt der
 Selektor und gegebenenfalls der Parameter.
 Sind Sender und Empfänger der Nachricht das gleiche Objekt, verwendet man
 den Bezeichner self.
\end_layout

\begin_layout LyX-Code

\size small
// somewhere lost in code:
\end_layout

\begin_layout LyX-Code

\size small
NSInteger age = [self computeAgeFromYear:1981 withMonth:5 andDay:23]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
// method declaration:
\end_layout

\begin_layout LyX-Code

\size small
- (NSInteger)computeAgeFromYear:(NSInteger)birthyear
\end_layout

\begin_layout LyX-Code

\size small
                      withMonth:(NSInteger)month
\end_layout

\begin_layout LyX-Code

\size small
                         andDay:(NSInteger)day { ...
 }
\end_layout

\begin_layout Standard
Diese Schreibweise ist für Neulinge äußerst gewöhnungsbedürftig, da hier
 jeder Parameter eine explizite Benennung erfordert.
 Methodennamen können in Objective-C durchaus sehr lang werden.
 Hat man sich jedoch einmal daran gewöhnt, mag man diese Notation jedoch
 nur ungern missen, denn sie fördert die Lesbarkeit und Verständlichkeit
 des Kodes ungemein.
 Die obige Methode bezeichnet man vollständig als: computeAgeFromYear:withMonth:
andDay, was auch gleichzeitig der Selektor dieser Methode ist.
\end_layout

\begin_layout Standard
Das Minus-Präfix zu Beginn der oben stehenden Methode gibt an, dass es sich
 hierbei um eine Instanzmethode handelt.
 Das entspricht dem Verständnis einer Methode in C++/Java.
 Da in Objective-C jedoch auch Klassen Objekte sind, können diese eigene
 Methoden haben.
 Solche Klassenmethoden werden durch ein vorangestelltes Plus gekennzeichnet.
 Ein gutes Beispiel ist der zum Initialisieren gebräuchliche verkettete
 Befehl [[NSObject alloc] init], der aus den folgenden Methoden besteht:
 +(id)alloc ist die Klassenmethode, die Speicher für das Objekt reserviert
 und einen Zeiger darauf zurückliefert.
 Anschließend initialisiert sich das erzeugte Objekt in dem allokierten
 Speicherbereich durch den Aufruf der Instanzmethode -(id)init.
 
\end_layout

\begin_layout Subsection
Protokolle: Data Sources und Delegates
\end_layout

\begin_layout Standard
Wer in Java mit Interfaces umgehen kann, sollte keine Schwierigkeiten haben,
 sich mit der Funktionsweise von Protokollen vertraut zu machen.
 Eine Protokolldeklaration beginnt mit dem Schlüsselwort @protocol, die
 enthaltenen Methoden befinden sich entweder unter dem Tag @required oder
 unter dem Tag @optional.
 Bei der Deklaration der Klasse wird das Protokoll in spitzen Klammern hinter
 der Oberklasse angegeben, mehrere Protokolle werden durch Kommata voneinander
 getrennt:
\end_layout

\begin_layout LyX-Code

\size small
@interface ViewController : UIViewController <UITextFieldDelegate, UITableViewDe
legate, UITableViewDataSource> {
\end_layout

\begin_layout LyX-Code

\size small
   ...
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Ein Konzept, welches so ebenfalls nicht bei Java oder C++ anzutreffen ist,
 sind die so genannten Delegates (vom englischen delegation: Abordnung,
 Übertragung) und die DataSources.
 Mit ihnen ist es möglich, Nachrichten an ein delegiertes Objekt weiterzuleiten,
 die in einen bestimmten Funktionalitätsbereich fallen.
 Ein UITextField sendet nach dem Betätigen der Eingabetaste die Nachricht
 textFieldShouldReturn:(UITextField *) an ihre Delegate.
 Diese Delegate kann die eigene Instanz sein oder aber ein beliebiges anderes
 Objekt, welches das Protokoll (BOOL)UITextFieldDelegate implementiert.
 Der Methode textFieldShouldReturn spezifiziert, was beim Betätigen der
 Eingabetaste passieren soll.
 An dieser Stelle bietet es sich beispielsweise an, mittels [textField resignFir
stResponder] das On-Screen-Keyboard wieder zurückzuziehen und eine weitere
 Methode aufzurufen, welche auf den im Textfeld enthaltenen Text zugreift.
 Die ordnungsgemäße Durchführung wird mit einem zurückgegebenen YES bestätigt.
 Ein Objekt kann nicht nur als Empfänger von Nachrichten dienen, er kann
 andersrum auch als Datenquelle fungieren.
 Implementiert es das einer Programmstruktur zugehörige DataSource-Protokoll,
 lässt es sich von dieser nutzen, um bei Laufzeit von dieser benötigte Daten
 abzufragen.
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
Properties werden in der Headerdatei deklariert und stellen einen einfachen
 Weg dar, Accessoren zu implementieren.
 War in früheren Xcode-Versionen noch das manuelle Synthetisieren mittels
 @synthesize notwendig, werden diese durch die Deklaration eines Property
 automatisch generiert.
 ein @property (UITextField*)name erzeugt per default den Setter setName
 sowie den Getter name.
 Möchte man die Variable name nun setzen, werden zwei Möglichkeiten angeboten:
 den C-Weg oder die nachrichtenbasierte Objective-C-Notation.
 Ein _name.text = string wird intern in ein [_name setText:NSString] umgewandelt.
 In der Umsetzung dieser Arbeit wurde konsequent die Objective-C-Notation
 verwendet.
 Wenn man es ganz genau nimmt, führt Objective-C intern den folgenden Befehl
 aus: [[self name] setText:NSString].
 Der Unterstrich zeigt, dass es sich um eine Instanzvariable handelt.
 Da Apple vorangestellte Unterstriche für eigene Zwecke einsetzt, sollte
 zur Vermeidung von Verwechslungen auf die eigene Verwendung bei der Namensgebun
g verzichtet werden.
\end_layout

\begin_layout Section
API: Cocoa Touch
\end_layout

\begin_layout Standard
Apples mobiles Betriebssystem iOS lässt sich in vier grundlegende Schichten
 einteilen: Während das Core OS den Mach-Kernel sowie die grundlegenden
 Funktionen beinhaltet, stellen die Core Services die Frameworks bereit,
 welche die Grundlage aller Anwendungen und Dienste sind, die auf dem Gerät
 laufen.
 Die darüber liegende Media-Schicht bündelt die Multimediafunktionen, schlussend
lich folgt an der Spitze die Programmierschnittstelle Cocoa Touch.
 Diese stellt die Schnittstellen zu sämtlichen darunter liegenden Schichten
 bereit.
 Gegenüber Cocoa, der Schnittstelle für OS X-Desktop-Maschinen, greift die
 Touch-Variante der API auf eine angepasste Benutzerschnittstelle zurück.
 Hier bieten spezielle Unterstützung für Bewegungssensoren, Multitouch-Gestenerk
ennung und Animationen, die speziell auf iOS abgestimmt sind, dem Programmierer
 darauf abgestimmte Eingabeelemente und Events an.
 Die Basis von Cocoa Touch bildet zum einen das Foundation Framework.
 Dieses stellt alle Basisklassen zur Verfügung, die für die grundlegende
 Programmierung mit Objective-C unverzichtbar sind.
 Weiter werden in diesem Werkzeuge wie Collections und Dateihandling bereitgeste
llt, ohne die eine moderne Programmierung heute nicht mehr auskommt.
 Seit iOS-Version 2 befindet sich darin bereits XML-Unterstützung, in iOS
 5 wurde diese um Unterstützung für das JSON-Format ergänzt.
 Dies machte es im Rahmen dieser Arbeit sehr einfach, auf externe Frameworks
 zu verzichten.
 Das UIKit als weiterer integraler Bestandteil von Cocoa Touch beinhaltet
 Klassen, die speziell auf die Entwicklung der grafischen Oberfläche ausgerichte
t sind.
 So enthält diese die Infrastruktur für grafische Anwendungen verschiedene
 Ansichten, so genannte Views, und deren Fenster, Menüs und Schaltflächen,
 sowie ein passendes Ereignissystem mit Sprachanbindung und Textsystem.
 Ereignisse durchlaufen eine so genannte “Responder-Chain”, die aus unterschiedl
ichen Klassen besteht.
 Nacheinander werden dieser eingetroffene Ereignisse entnommen und verarbeitet.
 Seit OS X 10.4/iOS 3 wurde diese Sammlung um das Core Data Framework ergänzt,
 einem schemabasierten Ansatz für die Umsetzung des MVC-Entwurfmusters.
 Der Model-View-Controller ist in Cocoa Touch strikt umgesetzt; Klassen
 lassen sich in der Regel eindeutig zuordnen.
\end_layout

\begin_layout Standard
Bei den Klassennamen selbst ist auffallend, dass die meisten mit NS beginnen,
 wie zum Beispiel NSObject, NSString oder NSArray.
 Dies hat seinen Ursprung darin, dass Apple im Jahre 1996 das OpenStep-Framework
 NeXTStep aufkaufte und als Basis für Mac OS X verwendete.
 Durch die Verwendung von “Klassen-Clustern” werden viele sichtbare Klassen
 nie instanziiert, sondern es werden statt dessen direkt zur Laufzeit Instanzen
 von passenden Subklassen erzeugt, von denen der Programmierer keine Kenntnis
 hat.
 Beispielsweise verlangt ein Anwendungsprogrammierer nach einer Instanz
 von NSArray, erzeugt wird jedoch in Abhängigkeit der Elemente eine Instanz
 einer Klasse, die er nicht kennt.
 
\end_layout

\begin_layout Section
IDE: Xcode
\end_layout

\begin_layout Standard
Xcode ist Apples integrierte Entwicklungsumgebung und steht aktuell in der
 Version 4.5.2 zur Verfügung.
 Seit der Version 4.1 lässt sich Xcode frei zugänglich im App Store herunterladen.
 In der Version 4.4 sind die SDKs für OS X 10.8 sowie für iOS 5.1 enthalten,
 Xcode 4.5 bringt die SDK für das neue iOS 6 mit.
 Beide benötigen mindestens OS X in der Version 10.7.4 Lion oder 10.8 Mountain
 Lion.
 Mit Xcode lassen sich OS X- oder iOS-Anwendungen entwickeln, wobei OS X-Anwendu
ngen auf der Cocoa-API basieren; möchte man eine Anwendung für das mobile
 iOS entwickeln, so nutzt man hierfür das im vorherigen Kapitel vorgestellte
 Cocoa Touch-Framework.
 Xcode kommt mit einer Reihe von Werkzeugen - den Xcode Tools - welche die
 alltägliche Arbeit des Objective-C-Programmierers erleichtern sollen.
 Apples LLVM Compiler bietet eine Echtzeitüberprüfung des eingegebenen Codes
 und meldet auffallende Syntax- oder Schreibfehler umgehend.
 Oft bietet die eingeblendete Fix-it-Funktion gleich eine adäquate Lösung,
 die sich mit einem Klick übernehmen lässt.
 Natürlich darf man hier keine Wunder erwarten, im Rahmen dieser Arbeit
 hat sich deren Vorhandensein jedoch als sehr angenehm erwiesen.
 Mit dem Analysetool Instruments lassen sich diverse Messinstrumente mit
 einem Prozess verbinden und deren Laufzeitverhalten akribisch genau analysieren.
 Um ein Programmverhalten auf einem bestimmten iOS-Gerät zu testen, lässt
 sich auf den integrierten iPhone- und iPad-Simulator zurückgreifen, für
 den verschiedene iOS-Versionen bereitgestellt werden.
 Diese lassen sich aus Xcode heraus mit einem Klick installieren.
 Auf dem Simulator lässt sich die App testen, ohne dass man ein physisches
 Gerät zur Hand haben muss.
 Es lassen sich verschiedene Hardware-Events simulieren, vom Schwenk des
 Orientation-Modus über die Betätigung der Home-Taste bis hin zu einer Speicherw
arnung, mit welcher man die eigene Software testen kann.
 Möchte man jedoch Implementationen von spezielleren Sensoren überprüfen,
 wie sie in den aktuellen Geräten eingesetzt werden, kommt man an einem
 physikalischen Gerät nicht vorbei.
\end_layout

\begin_layout Standard
Das Interface von Xcode besteht zum einen aus dem Source Editor, welcher
 Komfortmerkmale wie Code Completion, Syntax Highlighting und Code Folding
 bereitstellt, sowie die äußerst angenehme Echtzeitsuche nach Fehlern, Warnungen
 und anderer kontextsensitiven Informationen.
 Diese werden in Nachrichtenblasen am Fehlerort eingeblendet.
 Daneben ermöglicht der Assistant Editor über ein zweigeteiltes Fenster
 den Schnellzugriff auf Dateien, die für gewöhnlich eine hilfreiche Kombination
 mit der geöffneten Datei darstellen, zum Beispiel wird neben dem Interface
 gleich deren Implementation geöffnet.
 Der Interface Builder, welcher mit Version 4.0 von den externen Xcode Tools
 in die IDE integriert wurde, ermöglicht es, äußerst komfortabel und ohne
 eine Zeile Code, die GUI der App zu designen und die einzelnen Interfacekompone
nten untereinander zu verknüpfen und in den Programmcode einzubinden.
 Der Organizer als weiteres Element ist die zentrale Verwaltung für die
 der Entwicklerlizenz hinzugefügten Geräte, die Versionsverwaltung über
 lokale sowie entfernte Repositorien, Projekte und deren Snapshots und für
 ein App Archiv, von dem aus man seine entwickelten Apps verwaltet und zum
 App Store sendet.
 Am Rand lassen sich weitere Leisten einblenden: Auf der linken Seite wäre
 dies der Navigator, der durch Dateien, Fehler und Logs navigiert; rechts
 lässt uns die Utility Bar einige Einstellungen vornehmen.
 Darüber hinaus befindet sich dort auch eine File Templates- und eine Code
 Snippets-Library im unteren Bereich für Dinge, die man immer mal wieder
 benötigt.
 Im unteren mittleren Bereich lässt sich selbstverständlich die für das
 Debugging unentbehrliche obligatorische Konsole einblenden.
 Da es vor allem auf mobilen Geräten eher zu Ressourcenknappheit kommt als
 auf Desktop-Systemen, sollte man hier einen entsprechend ökonomischen Programmi
erstil pflegen und Ressourcen, die nicht mehr benötigt werden nach der Verwendun
g wieder freigeben.
 In Xcode 4.2 wurde das Automatic Reference Counting eingeführt, um den Entwickle
r dabei zu unterstützen.
 Die bislang verwendeten retain und release-Nachrichten, mit denen Speicher
 freizugeben war oder diese Freigabe verhindert werden sollte, wurden obsolet,
 wenn das Projekt mit ARC genutzt wird.
 Statt dessen übernimmt nun der Compiler die Referenzzählung und fügt dem
 Code beim Übersetzen die entsprechenden retain und release-Nachrichten
 hinzu.
 
\end_layout

\begin_layout Section
Interface Builder: Storyboards
\end_layout

\begin_layout Standard
Ebenfalls neu hinzugekommen seit Xcode 4.2 bilden Storyboards die Grundlage
 des Interface Builders und lösen die vorhergehenden NIBs ab, bei denen
 man darauf beschränkt war, zu jedem Zeitpunkt mit je einer View zu arbeiten.
 Storyboards zeigen im Gegensatz dazu die komplette Szene an, bestehend
 aus einzelnen Views und deren Übergänge untereinander.
 Verbindungen zu anderen Views wie die Möglichkeit, diese als Delegates
 oder als DataSource zu nutzen, lassen sich realisieren, indem man ein Objekt
 bei gedrückter Steuerungs-Taste auf die gewünschte View zieht.
 Zieht man diese statt dessen in den Interfaceteil des Programmcodes, werden
 die entsprechenden Codefragmente erstellt, in denen man sofort mit der
 Implementation beginnen kann, ohne sich mit programmatischen Details zum
 Setzen der einzelnen GUI-Elemente beschäftigen zu müssen.
 Übergänge lassen sich mit ID-Strings versehen, auf die man programmatisch
 zugreifen.
 So wird im Falle eines Überganges auf eine andere View die Methode prepareForSe
gue mit dem entsprechenden String für diesen Übergang aufgerufen.
 In dieser lassen sich Vorbereitungen für die neue Ansicht treffen - wie
 z.
 B.
 Daten und Referenzen übergeben - bevor diese dann geladen wird.
 Im Utility-Bereich kann praktisch jede Eigenschaft bearbeitet werden, mit
 der das Erscheinungsbild beeinflusst werden kann.
 So lässt sich ein Objekt inaktiv darstellen bzw.
 komplett verstecken oder man ändert die Schriftart eines Textfeldes.
 Um ein Objekt einem Container unterzuordnen lässt sich das unkompliziert
 per Drag and Drop realisieren.
 Zieht man beispielsweise eine Text View in einen Scroll View-Container
 erhält man Text, welcher sich mit einer Wischbewegung scrollen lässt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Storyboard.png
	lyxscale 45
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GUI im Storyboard
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Entwicklerlizenz: Testen auf echter Hardware
\end_layout

\begin_layout Standard
Grundsätzlich lässt sich eine App auch ohne Lizenz entwickeln und auf dem
 eingebauten iOS Simulator des seit der Version 4.1 für jedermann verfügbaren
 Xcode testen.
 Möchte man jedoch die App auf einem “echten” Gerät zur Ausführung bringen
 oder sie später einmal in den App Store stellen, so benötigt man eine Entwickle
rlizenz von Apple.
 Diese kostet derzeit 99 USD bzw.
 80 EUR und ist für exakt ein Jahr gültig.
 Mit einem Entwickleraccount hat man Zugriff auf iTunes Connect, mit dem
 sich der eigene Account, die verfügbaren iOS-Geräte sowie die eingestellten
 Apps verwalten lassen.
\end_layout

\begin_layout Standard
In einem ersten Schritt werden dort die User angelegt, welche an der Entwicklung
 und Distribution der Software beteiligt sind.
 Es stehen die vordefinierten Rollen Admin, Technical, Finance sowie Sales
 zur Verfügung.
 Während der Technical ausschließlich Rechte für die Verwaltung der Apps
 bekommt, stehen dem Finance weitergehend verschiedene Rechte im Bereich
 Finanzwesen, Analyse und Vertrieb bereit, die der Technican in der Regel
 nicht benötigt.
 Auf die Verwaltung der Apps hat er hingegen nur lesenden Zugriff, so kommen
 sich die Beiden nicht in die Quere.
 Der Rolle Sales stehen lediglich Verkauf und Verkaufsanalyse offen.
\end_layout

\begin_layout Standard
Abhängig vom Vertriebsmodell müssen in iTunes Connect weitere Angaben gemacht
 werden.
 Für unentgeltliche Apps ist es weder notwendig, einen Vertrag zu akzeptieren,
 noch müssen Bankdaten hinterlegt werden.
 Für weniger selbstlose Anwendungen stehen die Vertragstypen iOS Paid Applicatio
ns sowie das auf in-App-Werbung spezialisierte iAd Network zur Verfügung.
 Hier sind entsprechend Vertragsbedingungen zu akzeptieren, Kontaktinformationen
 anzugeben, Landesangaben zur Versteuerung zu machen und die Bankdaten für
 den erwarteten Zahlungsverkehr zu hinterlegen.
 Um eine App direkt auf dem Gerät ausführen zu können, wird ein Development
 Certificate benötigt.
 Das hinzuzufügende Gerät wird an den Mac angeschlossen und im Organizer
 der Entwicklerlizenz zugeordnet.
 Beim ersten Mal meldet Xcode, dass kein iOS Development Certificate vorhanden
 ist und bietet an, einen solchen von Apple anzufordern.
 Anschließend fügt er diesen automatisch der Schlüsselverwaltung hinzu und
 bietet an, das Entwicklerprofil für den Einsatz auf anderen Macs zu exportieren.
 In den Build Settings unserer App stellen wir nun die Code Signing Identity
 auf das neu erzeugte Zertifikat um und sind nun in der Lage, das angeschlossene
 iOS-Gerät anstelle des Simulators für die Entwicklung zu nutzen.
 
\end_layout

\begin_layout Section
Distributionsalternative: Der Cydia Store
\end_layout

\begin_layout Standard
Zum offiziellen Vertriebsweg über den Apple App Store gibt es eine Alternative,
 über die man jedoch nur freigeschaltete “gejailbreakte” Geräte Zugriff
 haben: Der Cydia Store, der in der Regel bei einem Jailbreak gleich mitinstalli
ert wird.
 Mit diesem kann man sich, wie unter Linux-Systemen bekannt, mit APT-kompatiblen
 Repositorien verbinden und auf deren Angebot zugreifen.
 Wenngleich es auch illegale Repositorien gibt, die urheberrechtlich geschütztes
 Material verteilen, ist der Cydia Store nicht als Distributionssystem für
 raubkopierte Software zu verstehen.
 Auch der Cydia Store verfügt über ein Bezahlsystem, mit dem Entwickler
 ihre Anwendungen entgeltlich anbieten.
 Interessant wird diese Vertriebsmethode, wenn man eine App entwickeln möchte,
 welche die Rechte überschreitet, die Apple seinen Anwendungen einräumt.
 Ein Beispiel für eine solche Anwendung ist der Fenstermanager Quasar, der
 eine Alternative zu Apples Einzelanwendungsmodus eröffnet.
 Vor allem auf iPads mit Retina-Auflösung kann es durchaus eine wünschenswerte
 Option sein, zwei oder mehr Fenster nebeneinander betreiben zu können.
 So könnte man beispielsweise auf der einen Seite ein Textverarbeitungsprogramm
 geöffnet haben, während auf der anderen Bildschirmhälfte ein Internetbrowser
 geöffnet ist.
 Um kompilierte Apps in ein DEB-Paket umzuwandeln – wofür nach wie vor eine
 Entwicklerlizenz benötigt wird – benötigt man das Paket dpkg.
 Dieses kann man sich beispielsweise mit dem Programm MacPorts
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.macports.org/
\end_layout

\end_inset

 installieren, welches ähnlich Fink eine Paketverwaltung für freie und quelloffe
ne Software für OS X ist.
\end_layout

\begin_layout Description
Quelle: http://www.macports.org/
\end_layout

\begin_layout Standard
Da sich dieses Programm nach /opt/local/bin installiert, fügen wir dieses
 Verzeichnis unserem Pfad hinzu:
\end_layout

\begin_layout LyX-Code

\size small
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
\end_layout

\begin_layout Standard
Nun folgt ein Update dessen Paketquellen und die Installation des gewünschten
 Paketes dpkg:
\end_layout

\begin_layout LyX-Code

\size small
sudo port selfupdate && sudo port install dpkg
\end_layout

\begin_layout Standard
Mit diesem sind wir nun in der Lage, aus den fertigen Apps Cydia-Repository-konf
orme DEB-Pakete zu erstellen.
\end_layout

\begin_layout Standard
Zum Konvertieren in ein DEB-Paket besteht dpkg-deb jedoch auf eine Struktur,
 welche sich wie folgt aufbaut:
\end_layout

\begin_layout LyX-Code

\size small
+- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   +- Applications
\end_layout

\begin_layout LyX-Code

\size small
   |  +- MyProgram.app
\end_layout

\begin_layout LyX-Code

\size small
   |     +- Info.plist
\end_layout

\begin_layout LyX-Code

\size small
   |     +- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   |     +- icon.png
\end_layout

\begin_layout LyX-Code

\size small
   +- DEBIAN
\end_layout

\begin_layout LyX-Code

\size small
   |  +- control
\end_layout

\begin_layout LyX-Code

\size small
   +- System
\end_layout

\begin_layout LyX-Code

\size small
      +- Library
\end_layout

\begin_layout LyX-Code

\size small
         +- LaunchDaemons
\end_layout

\begin_layout LyX-Code

\size small
            +- com.identifier.MyProgram.plist
\end_layout

\begin_layout Standard
Das Verzeichnis System ist hierbei optional.
\end_layout

\begin_layout Standard
Die Datei control kann folgende Einträge beinhalten: Package, Name, Version,
 Architecture, Description, Homepage, Depiction, Maintainer, Author, Sponsor,
 Section.
 Zwingend vorgeschrieben sind davon jedoch nur Package und Version.
\end_layout

\begin_layout Standard
Darüber hinaus erstellt OS X, wenn TAR-Dateien erzeugt werden – die ein
 Teil der internen Struktur eines Debian-Paketes darstellen – einige Dateien
 mit der Endung _*, welche zusätzliche Informationen enthalten.
 Diese zusätzlichen Dateien würden zusammen mit dem erzeugten Paket installiert
 werden.
 Davon abgesehen, dass diese Dateien sowieso nicht zum Paket gehören, könnten
 Sie auf dem Zielsystem Konflikte mit anderen Paketen erzeugen.
 Um dieses Feature zu deaktivieren werden folgende Umgebungsvariablen exportiert
:
\end_layout

\begin_layout LyX-Code

\size small
export COPYFILE_DISABLE
\end_layout

\begin_layout LyX-Code

\size small
export COPY_EXTENDED_ATTRIBUTES_DISABLE
\end_layout

\begin_layout Standard
Sind wir nun soweit wechseln im Terminal ins Verzeichnis 
\begin_inset Quotes eld
\end_inset

MyProgramm
\begin_inset Quotes erd
\end_inset

 und erzeugen das DEB-Paket mittels:
\end_layout

\begin_layout LyX-Code

\size small
dpkg-deb -b MyProgram
\end_layout

\begin_layout Description
Quelle: http://www.saurik.com/id/7
\end_layout

\begin_layout Subsubsection
Vom DEB-Paket aufs Device
\end_layout

\begin_layout Standard
Um die nun fertige DEB-Datei auf das iPad zu bekommen, wird ein Cydia-kompatible
s Repositorium benötigt.
 Hierfür kann zum Beispiel auf das kostenlose Angebot von MyRepoSpace zurückgegr
iffen werden.
 Über ein Webinterface können die Pakete hochgeladen werden und sind im
 Cydia Store zugreifbar über:
\end_layout

\begin_layout LyX-Code

\size small
http://cydia.myrepospace.com/Username/
\end_layout

\begin_layout Chapter
Schnittstelle mit der REST-Welt
\end_layout

\begin_layout Section
RESTful Webservices
\end_layout

\begin_layout Subsection
Begriffseinführung
\end_layout

\begin_layout Standard
Wikipedia definiert den Begriff 
\shape italic
Webservice
\shape default
 als 
\begin_inset Quotes eld
\end_inset

eine Methode der Kommunikation zwischen zwei elektronischen Geräten über
 das Internet
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Wikipedia - Webservice"

\end_inset

.
 Man verbindet mit diesem Begriff primär Akronyme wie SOAP (Simple Object
 Access Protocol) - ein Netzwerkprotokoll für den Transfer von Daten und
 RPCs (Remote Procedure Calls) - oder den einfacheren XML-RPC.
 Diese Webservices arbeiten, wie der Name bereits ausdrückt, mit HTTP POST-Reque
sts, um auf einem meist entfernten Computer eine Methode aufzurufen.
 Die Kommunikationssprache ist die XML-basierte Webservices Description
 Language oder kurz WSDL.
\end_layout

\begin_layout Standard
Im Jahr 2000 führte Roy Fielding, einer der Autoren der HTTP-Spezifikationen
 1.0 und 1.1 und Mitbegründer des Apache HTTP Projektes, in seiner Dissertation
 “Architectural Styles and the Design of Network-based Software Architectures”
 den Begriff REpresentational State Transfer ein und definierte ihn als
 einen “Architekturstil für verteilte hypermediale Systeme, der die Richtlinien
 für die Softwareentwicklung spezifiziert, welche sowohl REST selbst leiten
 als auch die Interaktionsvoraussetzungen, die so gewählt werden, dass sie
 diesen Richtlinien entsprechen
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Dissertation Fielding"

\end_inset

.
 Die REST-Architektur ist also ein Modell, das spezifiziert, wie das Internet
 - das im Grunde bereits eine riesige REST-Anwendung darstellt - eigentlich
 funktionieren sollte.
 Fielding bezeichnet REST als eine hybride Architektur, die von vielen verschied
enen Netzwerk basierten Architekturstilen abgeleitet ist und bezeichnet
 Seiten, die mit der Architektur REST kompatibel ist, als RESTful.
\end_layout

\begin_layout Standard
Den Kern dieses Architekturmodells bilden so genannte Ressourcen, weswegen
 es auch gerne als Ressource-oriented Architecture bezeichnet wird.
 Alles, was sich eindeutig identifizieren lässt, ist eine Ressource und
 sollte über eine statische Adresse zugreifbar gemacht werden.
 Neben Dateien und Verzeichnissen sind auch ausführbare Methoden, die Datenbanka
nfragen auslösen, gebräuchliche Ressourcen.
 Hervorragende Kandidaten stellen auch die Entitäten in einem Datenmodell:
 Für einen Onlineshop bieten sich die Entitäten Artikel, Kunde und Bestellung
 an, aber auch “Bestellungen des Kunden mit der ID 42 aus Jahr 2010“ kann
 eine valide Ressource sein und sollte ebenfalls eine möglichst langlebige
 und stabile URL erhalten.
 Ist man sich bei der Wahl der Ressourcen nicht ganz sicher so gilt: Im
 Zweifel besser zu viele Ressourcen als zu wenige.
 
\end_layout

\begin_layout Subsection
Richtlinien
\end_layout

\begin_layout Standard
HTTP bringt bereits ressourcenbezogenes Caching mit sich, wodurch man das
 Gefühl bekommt, mit einer REST-Anwendung im Internet bereits irgendwie
 “zu Hause zu sein”.
 Viele Onlineshops, Suchmaschinen oder Buchungssysteme sind, auch ohne,
 dass sie gezielt darauf abzielen, bereits RESTful.
 Damit eine Anwendung das HTTP jedoch auch tatsächlich REST-konform nutzt,
 hat sie sich an die Richtlinien zu halten, wie sie Fielding in seiner Arbeit
 beschreibt.
 Diese Richtlinien lassen sich wie folgt untergliedern, wobei es den einzelnen
 Diensten obliegt, wie diese implementiert werden.
\end_layout

\begin_layout Subsubsection
Adressierbarkeit
\end_layout

\begin_layout Standard
SOAP Webservices wie auch viele HTML-Seiten bilden ihre Funktionalität auf
 eine einzelne URL ab.
 Das sieht zwar in der Adresszeile “sauber” aus, bringt jedoch Nachteile
 mit sich.
 Weder lassen sich gezielt Inhalte als Lesezeichen ablegen, noch kann man
 mal eben dem Freund/Kommilitonen einen Link auf ein Produkt zusenden und
 auch Suchmaschinen haben es hier schwer, denn auch diese benötigen zum
 direkten Zugriff auf Unterbereiche einen konkreten Zugriffspfad.
 RESTful gestaltete Anwendungen bieten diese geforderte Adressierbarkeit,
 ohne dass Einschränkungen in Kauf genommen werden müssen.
 Durch die Verwendung einer Firewall beispielsweise ist es ohne Weiteres
 möglich, gezielten Zugriff auf eine Ressource zu unterbinden.
 Natürlich ließe sich das URL-Prinzip ebenfalls auf SOAP anwenden, aber
 sobald diese dereferenziert werden, bewegen wir uns wieder in der REST-Welt.
\end_layout

\begin_layout Subsubsection
Unterschiedliche Repräsentationen
\end_layout

\begin_layout Standard
Von den hinter einer URL bereitgestellten Diensten lassen sich unterschiedliche
 Darstellungen anfordern.
 Diese bezeichnet man als die Repräsentation dieser Ressource.
 Über die im HTTP-Protokoll enthaltenen Accept- und Content-Type-Header
 unterstützt das Internet ebenfalls bereits “von Haus aus” die Content Negotiati
on, mit der sich unterschiedliche Repräsentationen ein- und derselben Ressource
 anzeigen lassen.
 Hierbei dürfen sich die Clients das Format anfordern, welches am ehesten
 ihren Bedürfnissen entspricht: Ein Browser zeigt sich meist mit einer HTML-Repr
äsentation zufrieden, während andere Client - wie der in dieser Arbeit vorgestel
lte - ist eher an der XML- oder an der JSON-Repräsentation interessiert.
 Darüber hinaus lassen sich sogar Versionswünsche über die Content Negotiation
 realisieren und beispielsweise der gewünschte Content nach Belieben in
 XML 1.1 oder in XML 1.2 geliefert werden.
\end_layout

\begin_layout Subsubsection
Zustandslosigkeit
\end_layout

\begin_layout Standard
REST ist konzeptuell ein zustandsloses Protokoll, somit ist auch jeder RESTful
 Webservice zustandslos.
 Weder Server noch der Webservice behalten sich den aktuellen Stand ihres
 Dialoges.
 Jede Nachricht muss stets alle Informationen beinhalten, die erforderlich
 sind, diese Nachricht korrekt zu interpretieren und die Anfrage ordnungsgemäß
 verarbeiten zu können.
 Da sich weder Server noch Client einen Zustand behalten, bezeichnet man
 das Kommunikationsprotokoll einer REST-konformen Architektur als zustandslos.
 Durch die Abgeschlossenheit der einzelnen Nachrichten lassen sich darüber
 hinaus Lasten sehr leicht auf mehrere Maschinen verteilen, was sich positiv
 auf die Skalierbarkeit des Webservice auswirkt.
 In der Praxis wird jedoch auch gerne auf Cookies und andere Techniken zurückgeg
riffen, um über den Request hinaus an Zustandsinformationen gelangen.
\end_layout

\begin_layout Subsubsection
Operationen
\end_layout

\begin_layout Standard
Damit RESTful gestaltete Webservices miteinander kommunizieren können muss
 eine gemeinsame Sprache gesprochen werden.
 Das HTTP-Protokoll kennt unter anderem die Optionen GET, POST, PUT, DELETE,
 HEAD und OPTIONS.
 Da auf jede REST-Ressource stets die gleichen Operationen angewandt werden
 sollen, definiert dieser Methodensatz gleichzeitig die vom REST-Architekturstil
 geforderten wohldefinierten Operationen.
 Durch die Verwendung dieser elementaren Webtechniken wird die Integration
 und Interaktion der beteiligten Softwarekomponenten deutlich vereinfacht.
\end_layout

\begin_layout Standard
Die GET-Methode hat hierbei “sicher” zu sein: Es darf nur gelesen werden,
 so dass der Client jederzeit bedenkenlos ein GET auf eine Ressource anwenden
 darf.
 Weiterhin diktiert die HTTP-Spezifikation die idempotente Implementation
 von GET, PUT und DELETE.
 Wird eine dieser Operationen mehrfach ausgeführt, wird stets das gleiche
 Ergebnis erwartet.
 Ist sich der Client unsicher, ob sein Request erfolgreich abgearbeitet
 wurde, sollte er ihn wiederholen dürfen, ohne dass Seiteneffekte erwartet
 werden.
 HEAD und OPTIONS finden in REST eher selten Verwendung.
 Die REST-konforme Verwendung der Methoden in einem kurzen Überblick:
\end_layout

\begin_layout Description
GET: Mit GET wird die Repräsentation der Ressource vom Server angefordert.
\end_layout

\begin_layout Description
POST: POST fügt eine neue Unterressource zur angegebenen Ressource ein.
 Da die Unterressource vorher noch nicht existierte, wird die URL zu dieser
 vom Server erzeugt und dem Clienten in der Response zurückgeliefert.
 Über diese Verwendung hinaus kann POST auch für Operationen verwendet werden,
 die sonst von keiner anderen Methode abgedeckt werden.
\end_layout

\begin_layout Description
PUT: Die in PUT enthaltene Ressource wird angelegt.
 Existiert sie bereits wird sie wie im Body angegeben abgeändert.
\end_layout

\begin_layout Description
DELETE: DELETE veranlasst das Entfernen der Ressource.
\end_layout

\begin_layout Description
HEAD: Die Metadaten einer Ressource lassen sich mit HEAD abfragen.
\end_layout

\begin_layout Description
OPTIONS: Weiß man nicht, welche Methoden auf einer Ressource angewendet
 werden dürfen, lässt sich das mit OPTIONS in Erfahrung bringen.
\end_layout

\begin_layout Standard
Clientseitig sollte demnach das folgende Protokoll anwendbar sein:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@protocol Resource
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Resource(URI u)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response get()
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response post(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response put(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response delete()
\end_layout

\begin_layout LyX-Code

\size footnotesize
@end
\end_layout

\begin_layout Standard
Die (vereinfachte) Implementation der Anlage eines Kundenkontos im Server
 kann wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
class Customers : Resource {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
   Response post(Request r){
\end_layout

\begin_layout LyX-Code

\size footnotesize
      id = createCustomer(r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      return new Response(201, r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   }
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Subsubsection
Hypermedia
\end_layout

\begin_layout Standard
Das Kofferwort Hypermedia ist eine Zusammensetzung aus den Begriffen “Hypertext”
 und “Multimedia” und weist auf die Verwendung von Hypertext mit explizitem
 Akzent auf den multimedialen Gesichtspunkt hin.
 Repräsentationen enthalten in der Regel neben Informationen selbst wieder
 Links zu anderen Ressourcen.
 Das macht das Internet zu dem, was es ist: Eine stark vernetzte Verbindungsstru
ktur von identifizierbaren Ressourcen über hypermediale Links auf andere
 identifizierbare Ressourcen.
 Die standardisierte Adressierung sorgt dafür, dass sich die verlinkte Ressource
 in einem anderen Prozess im gleichen System oder auf einem anderen Rechner
 befinden kann, ganz gleich ob sich dieser im lokalen Netzwerk befindet,
 an einem beliebigen anderen Ort dieses Planeten oder auf einer Raumstation.
 Hierfür wird auch gerne der Ausdruck Verbindungshaftigkeit verwendet.
 Im Optimalfall werden dem Clienten in der angeforderten Repräsentation
 gleich die nächsten möglichen Übergänge als hypermediale Links mitgeteilt.
 Der Wert einer Anwendung ist proportional zur Anzahl der Ressourcen, auf
 die sie verlinkt.
 Mit einem Link auf einen REST-konform konzipierten Webservice eines Telekommuni
kationsunternehmens würden mit wenigen Klicks Millionen von Kundendaten
 zugreifbar gemacht werden.
 Diese könnten von der Anwendung selbst ausgewertet oder dem Endanwender
 zur Weiterverarbeitung überlassen werden.
\end_layout

\begin_layout Subsection
Beispiel
\end_layout

\begin_layout Standard
Wie so oft lässt sich das Prinzip von REST am Besten an einem Bespiel zeigen.
 Wir betrachten die Schnittstelle für den fiktiven Onlineshop smartphoneseppel.de.
 Ein Neukunde möchte sich ein Smartphone bestellen und legt sich zu diesem
 Zweck ein Kundenkonto an.
 Er wechselt auf die Seite des Onlineshops (GET http://www.smartphoneseppel.de)
 und teilt dem Server des Onlineshops mit einem POST /customer seine Registrieru
ngsabsicht mit.
 Im Requestbody stehen seine Daten, die er für die Registrierung angegeben
 hat.
 Der Server bestätigt mit der Response
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 201 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml;
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Length: 44
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
http://www.smartphoneseppel.de/customer/1337
\end_layout

\begin_layout Standard
die erfolgreiche Anlage des Kundenkontos und teilt die vergebene Kundennummer
 mit.
 Die Bestandteile einer HTTP-Response sind stets der Statuscode - an dieser
 Stelle weist der Statuscode 201 CREATED darauf hin, dass eine neue Ressource
 angelegt wurde -, die Art des zurückgelieferten Contents sowie der Content
 selbst.
 Nun kann sich der Kunde mit GET /customer/1337 sein Kundenkonto anzeigen
 lassen.
 Eine Änderung ist mit einem PUT /customer/1337 möglich.
 Möchte er sich den Artikel Samsung Galaxy S3 anzeigen lassen kann er das
 per GET /article/galaxy_s3.
 Angenommen es gefällt ihm, so packt er es sich mit einem PUT /shoppingcart/1337
&article=galaxy_s3 in seinen Warenkorb.
 Zur Sicherheit überprüft er nun dessen Inhalt mit GET /shoppingcart/1337.
 Die Antwort des Onlineshops könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 200 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0"?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<shoppingcart xmlns:xlink="http://www.w3.org/1999/xlink">
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <customer xlink:href="http://www.smartphoneseppel.de/customer/1337">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1337
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </customer>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <position pos="1" amount="1">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    <article xlink:href="http://www.smartphoneseppel.de/article="galaxy_s3"
\end_layout

\begin_layout LyX-Code

\size footnotesize
       article="galaxy_s3">
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Samsung Galaxy S3</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
    </article>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </position>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</shoppingcart>
\end_layout

\begin_layout Standard
Kunde 1337 ist mit dem Ergebnis einverstanden und sendet mit POST /shoppingcart/
1337 seine Bestellung ab.
 Der Server quittiert ihm dies mit einem /shoppingcart/1337/open, was auf
 den offenen Bestellstatus hinweist.
 Nun erscheint jedoch unerwartet das iPhone 5 und der Kunde überlegt es
 sich anders.
 Er überprüft, mit einem GET /customer/1337/orders seinen Bestellstatus
 und hat Glück, die Bestellung wurde noch nicht versendet.
 Er storniert die offene Bestellung mit DELETE /customer/1337/orders/open/2012-0
9-11_001 und legt sich statt dessen mit PUT /shoppingcart/1337&article=iphone_5
 den neuen Artikel in seinen Korb.
\end_layout

\begin_layout Standard
Der Onlineshop seinerseits entfernt nach dem Release des iPhone 5 mit DELETE
 /article/iphone_4s das iPhone 4S aus deinem System und legt mit PUT /article
 das neue Modell an.
 Der Body könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<articles>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <name>iPhone 5</name>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <description>Das beste iPhone, das es je gab.</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <size>64</size>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <weight>140</weight>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <price>849</price>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</articles>
\end_layout

\begin_layout Standard
Er sendet Kunde 1337 das gewünschte iPhone 5 und verschiebt seine Bestellung
 vom Status offen nach versendet mit 
\shape italic
DELETE /customer/1337/orders/open/2012-09-12_001
\shape default
 und 
\shape italic
POST /customer/1337/orders/shipped/2012-09-12_001
\shape default
.
\end_layout

\begin_layout Section
XML
\end_layout

\begin_layout Standard
Die Codebeispiele im vorhergehenden Kapitel zeigen bereits, dass sich hier
 zur Kommunikation eines Austauschformates bedient wird, welches sowohl
 von Menschen gelesen als auch von Maschinen unabhängig von Plattform und
 Implementation geparst werden kann.
 XML steht für Extensible Markup Language (zu Deutsch: erweiterbare Auszeichnung
ssprache) und verwendet das - im einfachsten Fall im ASCII-Format kodierte
 - Textformat, um über eine Metasprache strukturiert Informationen verfügbar
 zu machen.
 Diese vom World Wide Web Consortium (W3C) herausgegebene Spezifikation
 ist aktuell in der 5ten Ausgabe verfügbar und ein Derivat des älteren SGML.
 In vielen Punkten ist XML sehr verwandt mit HTML, jedoch folgt XML einer
 konsequenteren Syntax.
 Das führt dazu, dass valide XML-Dokumente zuverlässig von verschiedenen
 Anwendungen gelesen werden können.
 Um die zur Formatierung verwendeten Zeichen <, >, &, " und ' in Texten
 einzubetten, greift man auf die Entitäten &lt;, &gt;, &amp;, &quot; sowie
 &apos; zurück.
 Weitere feste Entitäten gibt es nicht, jedoch lassen sich beliebig weitere
 Entitäten definieren.
\end_layout

\begin_layout Standard
Die Struktur von XML bietet einige Vorteile gegenüber anderen Austauschformaten:
 Die redundante vollständige Wiederholung des Tagnamens beim Schließen erschwert
 Fehler bei der Verschachtelung und die vergleichsweise einfache Syntax
 von XML mit seinen Element- und Attributbezeichnungen macht es Einsteigern
 leicht, gleich zu Beginn ein gutes Gefühl zu bekommen, wie man mit XML
 umzugehen hat.
 Da die volle XML-Spezifikation allerdings über einen Umfang von gut 30
 Seiten verfügt, soll an dieser Stelle nur ein kleiner Überblick über das
 Basiswissen im Umgang mit XML vermittelt werden.
\end_layout

\begin_layout Standard
Ein einfaches, wohlgeformtes XML-Dokument könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<content>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

1
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Einleitung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

2
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Die Entwicklungsumgebung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

3
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>REST</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <!-- at least chapter IMPLEMENTATION still missing -->
\end_layout

\begin_layout LyX-Code

\size footnotesize
</content>
\end_layout

\begin_layout Standard
“Wohlgeformt” bedeutet im Kontext eines XML-Dokumentes, dass exakt ein Wurzelele
ment vorhanden ist.
 Elemente sind Informationsträger, ganz gleich welcher Art, sie können Texte
 oder weitere Elemente enthalten oder eine Kombination aus beiden.
 Die Elementbezeichnung ist frei wählbar.
 Verfügt ein Element über einen Inhalt, so wird dieser mit einem Start-
 sowie mit einem Endelement versehen: <tag>content</tag>.
 Steht ein Element ohne Inhalt, so kann das Element den Ein- und den Auszeichner
 in sich vereinen: <no_content/>.
 In einem Einzeichner oder einem leeren Tag können Attribute enthalten sein,
 die aus einem Schlüssel/Wert-Paar bestehen.
 Mehrere gleichlautende Elemente nebeneinander sind kein Problem, mehrere
 gleichlautende Attribute in einem Element sind jedoch nicht zulässig.
 Die Verschachtelung erfolgt ebenentreu, ein Element muss also geschlossen
 werden, bevor ein Geschwisterelement beginnt oder ein Elternelement geschlossen
 wird.
 Über die Wohldefiniertheit hinaus besteht die Möglichkeit, weitere Anforderunge
n an unser Dokument zu stellen, welches sich mit einer Grammatik wie einer
 DTD (Document Type Definition) oder einem XML-Schema realisieren lässt.
 Ein Dokument, welches einen Verweis auf eine solche Grammatik enthält,
 diese auch einhält und darüber hinaus noch wohlgeformt ist, bezeichnet
 man als valid.
\end_layout

\begin_layout Section
JSON
\end_layout

\begin_layout Standard
XML ist nicht immer der ideale Weg seine Daten zu strukturieren.
 Das Tag-System bläht kleine Datenbestände schnell auf und das Ansprechen
 einzelner XML-Nodes ist nicht immer leicht.
 JSON - die Kurzform für Java Script Object Notation - ist XML sehr ähnlich
 und bietet eine leichtgewichtige Alternative.
 JSON ist ein auch vom Menschen gut lesbares Austauschformat, welches so
 konzipiert ist, dass es sich leicht erstellen und leicht parsen lässt.
 Für ein sprachenübergreifendes Austauschformat ist es natürlich sinnig,
 dass man für den Aufbau auf Strukturen zurückgreift, die gängigen Sprachen
 geläufig sind.
 Somit kommen in JSON Key/Value-Records und Arrays zum Tragen - Strukturen,
 von denen es undenkbar ist, dass man sie in einer halbwegs modernen Programmier
sprache nicht in irgendeiner Form wiederfindet.
 Ein Objekt folgt in JSON der Syntax { String : Value }.
 Mehrere solcher Paare werden durch Kommata voneinander getrennt: { String1
 : Value1, String2 : Value2, ...
 }.
 Leerzeichen können zwischen den einzelnen JSON-Elementen der Übersichtlichkeit
 wegen beliebig gesetzt werden.
 Wie aus den meisten Programmiersprachen bekannt, kennzeichnet die eckige
 Klammer ein Array: [ Value1, Value2, Value3, ...
 ].
 Ein Wert kann hierbei ein oben genanntes String/Value-Objekt sein, aber
 auch Strings, Zahlen oder die boolschen Werte true und false sind möglich.
 Darüber hinaus sind auch null und weitere Arrays zulässige Werte.
 Zeichenketten, bestehend aus 0 bis n Unicode kompatiblen Zeichen, beginnen
 und enden je mit einem Anführungszeichen und können, ebenfalls wie aus
 C und Java bekannt, Escape-Sequenzen beinhalten, beginnend mit einem Backslash.
 Diese sind im Folgenden: 
\backslash
”, 
\backslash

\backslash
 sowie 
\backslash
/ geben jeweils den Wert hinter dem 
\backslash
 aus, also “, 
\backslash
 und /.
 Hingegen steht 
\backslash
b für ein Backspace, 
\backslash
f für einen Seitenumbruch, 
\backslash
n kennzeichnet eine neue Zeile, 
\backslash
r den Zeilenrücklauf und 
\backslash
u einen horizontalen Tabulator.
 Schließlich kann man noch, beginnend mit 
\backslash
u, einen vierstelligen Zahlencode eingeben, an dessen Stelle wird dann der
 Wert an der entsprechenden Stelle der Unicodetabelle eingefügt.
 Die Zahlensyntax ist ebenfalls aus C und Java bekannt mit der Ausnahme,
 dass JSON weder die Oktal- noch die Hexadezimaldarstellung beherrscht.
 42 ist ebenso zulässig wie 1.35e-4 oder auch -3.7589E+20.
\end_layout

\begin_layout Standard
Ein Beispiel für eine JSON-Datei: 
\end_layout

\begin_layout LyX-Code

\size footnotesize
{
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1337,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

John Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: [
\end_layout

\begin_layout LyX-Code

\size footnotesize
       [ 3456,
\end_layout

\begin_layout LyX-Code

\size footnotesize
         
\begin_inset Quotes eld
\end_inset

123-4567
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
       ], 
\begin_inset Quotes eld
\end_inset

john.doe@example.com
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
     ],
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: true
\end_layout

\begin_layout LyX-Code

\size footnotesize
  },
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1338,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

Jane Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: null,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: false
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Section
Ein erster Überblick
\end_layout

\begin_layout Standard
Da es sich um eine iOS-App handelt und als solche intuitiv sein und nicht
 mit Optionsvielfalt erschlagen sollte, habe ich mich für ein einfaches
 Single View Application-Template und gegen einen NavigationController entschied
en.
 Erzeugt man ein Projekt, liefert Xcode bereits einige Template-Dateien,
 in denen man sofort losprogrammieren darf, dazu gehören der ViewController
 und das MainStoryboard.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Diagram.png
	lyxscale 45
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Verwendete Klassen in UML-Notation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der ViewController ist hierbei die Initialisierungs-View und das zentrale
 Bedieninstrument dieser App.
 Die Implementation jeder View gehört in eine eigene Datei, was den Klassen
 HeaderKeysViewController, ResourcesTableViewController sowie LogOutputViewContr
oller ihre Existenzberechtigung verleiht.
 Keine eigene View besitzt der XMLParser, dessen Funktionalität sich jedoch
 hervorragend als autonome Klasse ausgliedern lies.
 HistoryElement ist die Implementation einer URL-History in Form einer doppelt
 verketteten linearen Liste.
\end_layout

\begin_layout Section
Hauptklasse: ViewController
\end_layout

\begin_layout Standard
Der ViewController als unsere Basisklasse erbt vom Typ UIViewController,
 welche das fundamentelle View-Management-Modell für alle iOS Applikationen
 stellt.
 Seine Oberklasse UIResponder definiert das Interface zum Umgang mit Events
 und erbt selbst direkt von NSObject, der Wurzelklasse aller Objective-C-Klassen.
 Er wird uns von Xcode zu Projektbeginn bereitgestellt und fügt die Methoden
 viewDidLoad, viewDidUnload mit je einer kurzen Beschreibung ein sowie die
 Methode shouldAutorotateToInterfaceOrientation, mit der sich der Landscape
 Orientation-Modus ein- und ausschalten lässt.
 Letztere sorgt dafür, dass sich der Bildschirminhalt mitdreht, wenn die
 Lagesensoren des iPads ein Kippen des Gerätes erkennen.
 Aufgrund des fehlenden NavigationControllers muss jede weitere View ihr
 aus erreichbar sein.
 Die View beinhaltet mehrere Textfelder und implementiert demnach das UITextFiel
dDelegate-Protokoll.
 Dieses Protokoll definiert die darin möglichen Nachrichten, die ein Textfeld
 an seine Delegate-Klasse sendet, als Teil der Textverarbeitung.
 In der ViewController wird beispielsweise die im Protokoll enthaltene Methode
 textFieldShouldReturn so implementiert, dass nach dem Druck der Eingabetaste
 auf der On Screen-Tastatur das Keyboard wieder vom Bildschirm ausgeblendet
 wird.
 Sofern das URL-Feld das gerade aktive Textfeld war wird anschließend die
 Methode go aufgerufen, was den gleichen Effekt hat wie das Berühren des
 Go-Buttons oben rechts am Bildschirm.
 Für das Textfeld, welches diese Methode aufrufen möchte, muss zwingend
 eine Delegate spezifiziert werden.
 Dazu wird im Storyboard bei gedrückter Strg-Taste eine Verbindung vom Textfeld
 (hier: dem UITextField *url) zum Controller gezogen und das Outlet delegate
 ausgewählt.
 Das Interface des entsprechenden Controllers wird automatisch um die entspreche
nde Deklaration des Protokolls erweitert.
 Der programmatische Weg wäre das manuelle Setzen der Delegate mittels [_url
 setDelegate:self];.
 Noch einmal zur Erinnerung: url wird als property im Interface angegeben
 und es werden standardmäßig die Accessoren generiert.
 Der Zugriff auf url über den Getter erfolgt über die Instanzvariable _url.
\end_layout

\begin_layout Standard
Beispielhafte Implementation der Methode textFieldShouldReturn im ViewController
:
\end_layout

\begin_layout LyX-Code

\size small
- (BOOL)textFieldShouldReturn:(UITextField *)textField {
\end_layout

\begin_layout LyX-Code

\size small
   [textField resignFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   if (textField == _url)
\end_layout

\begin_layout LyX-Code

\size small
      [self go:nil];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _username)
\end_layout

\begin_layout LyX-Code

\size small
      [_password becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _keyTextField)
\end_layout

\begin_layout LyX-Code

\size small
      [_valueTextField becomeFirstResponder];
\end_layout

\begin_layout LyX-Code

\size small
   else if (textField == _valueTextField)
\end_layout

\begin_layout LyX-Code

\size small
      [self addKeyValue:nil];
\end_layout

\begin_layout LyX-Code

\size small
   return YES;
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Weitere Elemente in dieser View, die eine Delegate benötigen, sind zum einen
 die UIPickerView links oben, in der die zu verwendende HTTP-Methode ausgewählt
 wird sowie die UITableView auf der rechten Seite, in der sich Schlüssel/Wert-Tu
pel aufnehmen lassen.
 Diese werden bei einem PUT oder einem POST automatisch als Header hinzugefügt.
 Diese beiden Komponenten benötigen nicht nur ein Objekt, dem sie Nachrichten
 übermitteln können, die im weiteren Programmverlauf etwas anstoßen.
 Beide benötigen darüber hinaus ebenfalls ein Objekt, bei dem sie Daten
 abfragen dürfen, die sie für ihre eigene Funktion benötigen.
 Das DataSource-Objekt liefert als Antwort auf die im Protokoll deklarierten
 Nachrichten, die es von der UIPickerView oder der UITableView empfängt,
 die benötigten Daten zurück.
 Oft handelt es sich dabei bei der Delegate und der DataSource um ein- und
 dasselbe Objekt, daher implementiert der ViewController sowohl die Delegate-Pro
tokolle UIPickerViewDelegate und UITableViewDelegate als auch die DataSource-Pro
tokolle UIPickerViewDataSource und UITableViewDataSource.
\end_layout

\begin_layout Standard
Auf die Anfrage der PickerView nach der Anzahl der Spalten reagiert das
 ViewController-Objekt mit der folgenden Methode:
\end_layout

\begin_layout LyX-Code

\size small
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {
\end_layout

\begin_layout LyX-Code

\size small
     return 1;
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ViewController1.tiff
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController nach geparster XML-Response.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ViewController2.tiff
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ViewController im Landscape-Modus.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Senden einer Request
\end_layout

\begin_layout Standard
Beim Senden eines Request passiert Folgendes: Im URL-Textfeld ist die Adresse
 einzugeben, zu welcher die Request gesendet werden soll; im linken oberen
 Picker wird die HTTP-Methode ausgewählt.
 Das Textfeld direkt unter dem Picker bietet die Möglichkeit, zusätzliche
 Methoden in den Picker aufzunehmen, beispielsweise ein OPTIONS.
 Soll ein PUT- oder ein POST-Request versendet werden, so wird der im Body-Berei
ch angezeigte Text des aktuell aktiven Tabs im Output-Fenster (Request/Response/
Parsed) dem Request als Body hinzugefügt.
 Dieser Textbereich ist aus diesem Grund bearbeitbar.
 Es sollte natürlich niemals der Parsed-Tab aktiv sein, da dieser aufbereitete
 Daten enthält und keinen gültigen JSON- oder XML-Code.
 Der angefragte Server wird diesen Text wahrscheinlich nicht interpretieren
 können.
 Nach einem PUT- oder einem POST-Request befindet sich eine Kopie des gesendeten
 Bodys im Body/Request-Tab zur eventuellen weiteren Bearbeitung und auch
 die gesendeten Request-Header sind im Bereich Header/Request ersichtlich.
 Der Header Content-Length wurde automatisch mit der Länge der angehangenen
 Body-Nachricht gesetzt.
 Wurde ein beliebiger Request durchgeführt und die Response erfolgreich
 auf JSON oder XML getestet und ist das Request-Fenster bislang noch leer,
 so wird dem Anwender an dieser Stelle ein einfaches JSON- bzw.
 ein XML-Template generiert, welches er anpassen kann.
 Der Anwender hat darüber hinaus im rechten Bereich die Möglichkeit, diesen
 um weitere Header zu erweitern.
 An dieser Stelle kann man aus der angebotenen Liste einen gebräuchlichen
 General- oder einen Request-Header auswählen, man darf jedoch auch einen
 beliebiges Header/Werte-Paar eingeben.
 Zwei gleichnamige Header sind hier verständlicherweise ebenso wenig erlaubt,
 wie ein leeres Schlüssel- oder Wertefeld.
 Wird eine Headerzeile markiert, so wird der neue Header direkt darüber
 eingefügt und die Markierung entfernt.
 Ist keine Headerzeile markiert, so wird das neue Tupel am Ende der Liste
 eingefügt.
 Die an dieser Stelle verwendete Datenstruktur sind die beiden Arrays headerKeys
Array sowie headerValuesArray, an deren Indexwert x sich der Eintrag der
 x-ten Reihe der Headertabelle befindet.
 Zwar wären die Zellen der UITableView theoretisch ebenfalls in der Lage,
 Daten zu speichern, jedoch kommt es dann zu folgendem anormalen Programmverhalt
en: Als Container dient eine UIScrollView, darin befindet sich eine UITableView.
 Das hat den Vorteil, dass es möglich ist, mehr Daten darzustellen, als
 sichtbar sind, da sich die Tabelle einfach mit dem Finger aus dem sichtbaren
 Bereich wischen lässt.
 Bewegt man nun jedoch eine Zelle aus dem sichtbaren Bereich, existiert
 aktuell keine sichtbare Referenz mehr darauf und das System setzt den Inhalt
 auf seine Reusable-Liste.
 Die Daten, die in der Zelle enthalten sind, werden entfernt.
 Kommt die Zelle wieder in den sichtbaren Bereich, so werden nicht die alten
 Daten wiederhergestellt, sondern an die DataSource der UITableViews - ein
 instanziiertes Objekt der Klasse HeaderKeysViewController - wird die Nachricht
 tableView:cellForRowAtIndexPath gesendet, woraufhin dieser eine neue Zelle
 erzeugt.
 Diese würde sich den Zelleninhalt jedoch aus den aktuellen Inhalten der
 Textfelder für den HTTP Header-Input besorgen, was nicht das ist, was an
 dieser Stelle passieren sollte.
 Da gemäß MVC allerdings unterhalb der GUI die Daten in Arrays abgelegt
 sind, deren Index mit der Zellennummer identisch ist, kann die Wiederherstellun
g des Zelleninhaltes auf die entsprechenden Einträge der Arrays zugreifen.
\end_layout

\begin_layout Standard
Implementation der tableView:cellforRowAtIndexPath:
\end_layout

\begin_layout LyX-Code

\size small
- (UITableViewCell *)tableView:(UITableView *)tableView
\end_layout

\begin_layout LyX-Code

\size small
  cellForRowAtIndexPath:(NSIndexPath *)indexPath {
\end_layout

\begin_layout LyX-Code

\size small
      static NSString *CellIdentifier = @"Cell";
\end_layout

\begin_layout LyX-Code

\size small
      UITableViewCell *cell =
\end_layout

\begin_layout LyX-Code

\size small
      [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size small
      if (cell == nil)
\end_layout

\begin_layout LyX-Code

\size small
          cell = [[UITableViewCell alloc]
\end_layout

\begin_layout LyX-Code

\size small
            initWithStyle:UITableViewCellStyleValue1
\end_layout

\begin_layout LyX-Code

\size small
          reuseIdentifier:CellIdentifier];
\end_layout

\begin_layout LyX-Code

\size small
      NSString *cellText; if ([indexPath section] == 0) cellText =
\end_layout

\begin_layout LyX-Code

\size small
      [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size small
      [_generalHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size small
      else cellText = [[NSString alloc] initWithFormat:@"%@",
\end_layout

\begin_layout LyX-Code

\size small
      [_requestHeaders objectAtIndex:[indexPath row]]];
\end_layout

\begin_layout LyX-Code

\size small
      [[cell textLabel] setText:cellText];
\end_layout

\begin_layout LyX-Code

\size small
      return cell;
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout Standard
Befindet sich der hinzugefügte Header in der Liste der bekannten General
 Headers, so wird er mit grüner Schrift angezeigt, ist er ein bekannter
 Request Header, erscheint seine Schrift in Blaugrün.
 Befindet sich der hinzugefügte Header weder in der General- noch in der
 Request-Header-Liste, so wird dessen Name rot gefärbt.
 Dies soll der Vermeidung von Tippfehlern dienen.
\end_layout

\begin_layout Standard
Benötigt die Seite eine HTTP Basic- oder eine HTTP Digest-Authentifizierung,
 erhält das View-Objekt eine Authentication Challenge.
 Die API stellt hierfür den Methodenaufruf connection:didReceiveAuthenticationCh
allenge bereit, in welcher sich dieser Aufforderung angenommen werden sollte.
 Sind Authentifizierungsinformationen gegeben, so werden diese nun ausgelesen
 und dem angefragten Server übermittelt.
 Die Implementation dieser Methode sieht wie folgt aus:
\end_layout

\begin_layout LyX-Code

\size small
- (void)connection:(NSURLConnection *)connection
\end_layout

\begin_layout LyX-Code

\size small
  didReceiveAuthenticationChallenge:
\end_layout

\begin_layout LyX-Code

\size small
  (NSURLAuthenticationChallenge *)challenge {
\end_layout

\begin_layout LyX-Code

\size small
      if ([challenge previousFailureCount] == 0) {
\end_layout

\begin_layout LyX-Code

\size small
          NSURLCredential *credential =
\end_layout

\begin_layout LyX-Code

\size small
          [NSURLCredential credentialWithUser:[_username text]
\end_layout

\begin_layout LyX-Code

\size small
                                     password:[_password text]
\end_layout

\begin_layout LyX-Code

\size small
                           persistence:NSURLCredentialPersistenceNone];
\end_layout

\begin_layout LyX-Code

\size small
          [[challenge sender] useCredential:credential
\end_layout

\begin_layout LyX-Code

\size small
                 forAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size small
      } else {
\end_layout

\begin_layout LyX-Code

\size small
          [[challenge sender] cancelAuthenticationChallenge:challenge];
\end_layout

\begin_layout LyX-Code

\size small
          UIAlertView *alert =
\end_layout

\begin_layout LyX-Code

\size small
          [[UIAlertView alloc] initWithTitle:@"Error"
\end_layout

\begin_layout LyX-Code

\size small
                             message:@"Authentication incorrect."
\end_layout

\begin_layout LyX-Code

\size small
                            delegate:self
\end_layout

\begin_layout LyX-Code

\size small
                   cancelButtonTitle:@"Close"
\end_layout

\begin_layout LyX-Code

\size small
                   otherButtonTitles:nil];
\end_layout

\begin_layout LyX-Code

\size small
          [alert show];
\end_layout

\begin_layout LyX-Code

\size small
          [challenge description]);
\end_layout

\begin_layout LyX-Code

\size small
      }
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename Flowchart Request.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Senden einer Request
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Empfangen einer Response
\end_layout

\begin_layout Standard
Jede eingehende Response ruft die Methode connection:didReceiveResponse
 auf.
 Hier werden die Informationstextfelder im oberen Bereich der View gesetzt,
 die Header in den entsprechenden Bereich im Output-Feld übertragen und
 überprüft, ob der Inhaltstyp als JSON oder XML angegeben wird.
 Liegt der vom Server zurückgelieferte Statuscode unter 400 deutet das auf
 eine positive Antwort auf unseren Request hin.
 Es wird nun ein neues Historyelement erzeugt, mit der erfolgreich bearbeiteten
 URL gefüllt und der History-Queue angehangen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Flowchart Response.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eintreffen einer Response
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Trifft eine Response ein, die neben dem Header einen Body enthält, wird
 mit diesem die Methode connection:didReceiveData aufgerufen.
 Für jede Teilresponse werden die Daten mittels [responseBodyData appendData:_bo
dyData] der statischen Variable responseBodyData hinzugefügt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Flowchart BodyData.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eingehende Packages
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Mit den willkürlich eingehenden Paketen hatte ich einiges an Problemen,
 denn für jedes Paket mit einem Body wurde stets gleich der Parser angeschmissen.
 Mein erster Ansatz war es, die ContentLength mit der Länge des eingetroffenen
 Bodys zu vergleichen und so lange die Daten in einem statischen String
 zu sammeln, bis die Nachricht vollständig ist.
 Leider gibt nicht jede Nachricht Auskunft über ihre vollständige Größe,
 weswegen ich einen Timer von 3 Sekunden einführte, welcher sich mit jeder
 eingehenden Nachricht wieder zurücksetzte.
 Lief dieser ab, so wurde das vollständige Empfangen der Nachricht angenommen
 und die Analyse der Bodydaten begonnen.
 Hier zeigte sich, dass ein tiefergehender Blick ins Referenzhandbuch mit
 einiges an Arbeit erspart hätte, denn wie für so vieles stellt Apple sehr
 einfache Hilfsmethoden bereit und einige Zeit später stieß ich durch Zufall
 auf die Methode 
\shape italic
connectionDidFinishLoading
\shape default
.
 Da dies natürlich ein wesentlich feinerer Ansatz ist, als ein Timer, wird
 nun auf diese Methode zurückgegriffen, sobald der der Body vollständig
 empfangen wurde.
 Hier erfolgt auch das Abarbeiten der nun vollständigen Bodys.
 Anhand des ersten Bytes wird überprüft, ob es sich um ein Bild handelt.
 Ist das der Fall, so wird eine 
\shape italic
ImageView
\shape default
 in die 
\shape italic
ScrollView
\shape default
 eingebettet und das Bild darin angezeigt.
 Ist dies nicht der Fall und es wurde bereits vorher anhand des 
\shape italic
Content Type
\shape default
 erkannt, dass es sich um JSON- oder um XML-Code handelt, wird der Body
 an den entsprechenden Parser übergeben.
 Im Apple Foundation-Framework findet sich schon seit OS X-Version 10.3 der
 
\shape italic
NSXMLParser
\shape default
, seit iOS 5 wurde es nun auch um 
\shape italic
NSJSONSerialization
\shape default
 erweitert, welches ein 
\shape italic
NSData
\shape default
-Objekt parst und ein 
\shape italic
NSDictionary
\shape default
 zurückliefert.
 In beiden Fällen werden sowohl die Keys als auch die Values in je ein 
\shape italic
MutableArray
\shape default
 geschrieben.
 Mutable deswegen, weil es nötig sein wird, an verschiedenen Stellen Felder
 zu löschen und hinzuzufügen.
 Wurde das Parsen erfolgreich abgeschlossen, wird die rekursive Methode
 
\shape italic
processKeys
\shape default
 aufgerufen.
 
\begin_inset Quotes eld
\end_inset

Erfolgreich
\begin_inset Quotes erd
\end_inset

 bereutet im Falle des XML-Parsers dass er nach erfolgter Durchführung ein
 YES zurückliefert, im Falle des NSJSONSerializers befindet sich ein Inhalt
 im Array.
 Die einzelnen Schlüssel/Wert-Paare werden nun daraufhin überprüft, ob es
 sich bei den Werten um eine Ressource handelt.
 Da es nun durchaus sein kann, dass ein komplettes Array mit weiteren Schlüssel/
Wert-Paaren einen solchen Wert darstellt, ist ein rekursiver Aufruf von
 
\shape italic
processKeys
\shape default
 äußerst bequem.
 Da hier durchaus Schlüssel/Wert-Paare eingefügt oder gelöscht werden, ist
 das Mitführen eines statischen Indexes staticIndex erforderlich.
 Eingefügt werden Schlüssel/Werte-Paare, wenn ein Array gefunden wird und
 deren Inhalt dem eigenen Array am aktuellen Index eingefügt wird.
 Das Schlüssel/Wert-Paar, welches das Array enthielt, hat nach dem rekursiven
 Abarbeiten keine weitere Funktion mehr und es wird entfernt, denn die darin
 enthaltenen Schlüssel/Wert-Paare befinden sich nun bereits in dessen 
\begin_inset Quotes eld
\end_inset

Ober-Array
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Zum Vorbereiten des Tests auf eine valide URL wird der String in einem ersten
 Schritt in eine Variable des Typs 
\shape italic
NSURL
\shape default
 umgewandelt.
 Hier wird intern getestet, ob die Zeichen für eine URL valid sind.
 Ist dem nicht der Fall, wird ein 
\family typewriter
\size small
nil
\family default
\size default
 zurückgegeben.
 Wird kein 
\family typewriter
\size small
nil
\family default
\size default
 zurückgegeben, wird der Anfang des Strings überprüft.
 Beginnt dieser mit 
\shape italic
http
\shape default
, wird er unverändert als URL interpretiert.
 Beginnt er statt dessen mit einem Schrägstrich, wird er an die Basis-URL
 des zuletzt aufgerufenen Requests angehangen und zur Überprüfung auf eine
 valide URL weitergegeben.
 Treffen beide Fälle nicht zu, so wird die höchste Verzeichnisebene, welche
 sich im letzten Request finden lässt, um diesen String erweitert und ebenfalls
 getestet, ob es sich um eine valide URL handelt.
\end_layout

\begin_layout Standard
Um den Test anschließend durchzuführen, wechselt die App mittels 
\family typewriter
\size small
[self setValidatingState:YES]
\family default
\size default
 in einen Zustand, der der Validierung von Ressourcen dient.
 Es wird für jeden Ressourcenkandidaten einen asynchronen HEAD-Request abgesende
t, deren Responses different betrachtet werden.
 Ein nebenbei laufender Counter führt hierbei Buch über den aktuellen Fortschrit
t und wird inkrementiert, sobald eine Resource aus irgendeinem Grund invalid
 ist oder sie als valid befunden wird.
 Die endgültige Entscheidung über die Validität wird erst in der Methode
 
\shape italic
didReceiveResponse
\shape default
 getroffen, welche die Antwort des Servers auswerten darf.
 Da die asynchronen Requests die Responses in willkürlicher Reihenfolge
 eintreffen lassen, kann leider nicht ohne Weiteres zugeordnet werden, für
 welchen Wert gerade eine Antwort empfangen wurde.
 Die ID der abgesendeten 
\shape italic
NSURLConnection
\shape default
 wird daher zusammen mit dem Index des zu überprüfenden Wertes in ein
\shape italic
 NSDictionary
\shape default
 gepackt.
 In der empfangenden Methode kann anhand dieser ID der Indexwert aus dem
 Wörterbuch abgefragt werden und es ist wieder klar, welchem Schlüssel/Wert-Paar
 der empfangene Statuscode zuzuordnen ist.
 Ein Statuscode kleiner 400 ist auch positiv zu interpretieren und weist
 auf die Existenz der angefragten Resource hin.
 Der angefragte Wert wird in die 
\shape italic
MutableArrays
\shape default
 
\shape italic
foundResourceKeys
\shape default
 sowie 
\shape italic
foundResourceValues
\shape default
 geschrieben.
 Da ein asynchroner Request den Nachteil hat, dass die überprüften Resourcen
 in beliebiger Reihenfolge im Zielarray landen würden, eine synchrone Überprüfun
g jedoch zu viel Zeit in Anspruch nehmen würde, wird sich hier mit einem
 kleinen Trick beholfen: Die Arrays 
\shape italic
foundResourceKeys
\shape default
 und 
\shape italic
foundResourceValues
\shape default
 werden mit der Größe der Resourcenkandidaten angelegt und die Felder mit
 einem leeren 
\shape italic
NSString
\shape default
 initialisiert.
 Eine überprüfte Resource, die sich im Quellarray an einem Feld mit dem
 Index y befindet, wird in das Zielarray ebenfalls an das Feld mit dem Index
 y geschrieben.
 Alle Felder der beiden Arrays, an die keine Einträge geschrieben wurden,
 enthalten weiterhin leere Strings.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Flowchart FinishReceive.png
	lyxscale 65
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Response wurde vollständig empfangen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Nachdem keine Ressourcenkandidaten mehr auf ihre Validierung warten, lassen
 sie die 
\shape italic
MutableArrays
\shape default
 bereinigen, in dem man die Felder mit den leeren Strings kurzerhand aus
 dem Array entfernt.
 Zurück bleiben je ein Array mit den Schlüsseln und eines mit den Werten,
 welche beim Berühren der Ressourcenschaltfläche - der Lupe - an die Klasse
 
\shape italic
ResourceTableViewController
\shape default
 übergeben lassen.
 Was sich so fast beiläufig in einem Nebensatz erwähnen lässt war, zumindest
 Zeittechnisch - alles andere als beiläufig, da die sich öffnende TableView
 nach ihrer Instantiierung und Überreichung der Daten stets ihrer leeren
 Seite zeigte.
 Wie sich herausstellte, erzeugt bereits das Storyboard eine Instanz einer
 View nach der Betätigung der Schaltfläche, jede programmatisch erzeugte
 Instanz ist eine weitere, die irgendwo anders abläuft, aber nicht für den
 Anwender im Vordergrund ersichtlich ist.
 Das Ziel ist das Folgende: Nachdem der Button betätigt wurde, welcher das
 Storyboard veranlasst, einen Übergang in neue View einzuleiten, soll diese
 View mit Daten gefüllt werden.
 Dies muss allerdings geschehen, bevor die View auf dem Bildschirm erscheint,
 was ja scheinbar zeitgleich ist.
 Um dieses Kunststück zu bewerkstelligen, lassen sich auf diese Übergänge,
 so genannte 
\shape italic
Segues
\shape default
, programmatisch zugreifen.
 Falls vorhanden wird bei einem Übergang die Methode 
\shape italic
prepareForSegue:sender
\shape default
 aufgerufen.
 Um gezielt Übergänge ansprechen zu können lassen sich hierfür im Storyboard
 Identifier vergeben; der Identifier des gerade aktiven Überganges kann
 in der Implementation mit [segue identifier] abgefragt werden.
\end_layout

\begin_layout LyX-Code

\size small
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
\end_layout

\begin_layout LyX-Code

\size small
if ([[segue identifier] isEqualToString:@"resourcesTableViewPopover"]) {
\end_layout

\begin_layout LyX-Code

\size small
ResourcesTableViewController *resourceTableViewController =
\end_layout

\begin_layout LyX-Code

\size small
[segue destinationViewController]; 
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setKeys:foundResourceKeys];
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setValues:foundResourceValues];
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setReferenceToUrl:_url];
\end_layout

\begin_layout LyX-Code

\size small
UIStoryboardPopoverSegue* popoverSegue = (UIStoryboardPopoverSegue*)segue;
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setReferenceToPopoverController:
\end_layout

\begin_layout LyX-Code

\size small
[popoverSegue popoverController]];
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setReferenceToBaseUrl:[self urlPart:
\end_layout

\begin_layout LyX-Code

\size small
[_url text] definePart:@"baseUrl"]];
\end_layout

\begin_layout LyX-Code

\size small
[resourceTableViewController setReferenceToHighestDir:
\end_layout

\begin_layout LyX-Code

\size small
[self urlPart:[_url text] definePart:@"highestDir"]];
\end_layout

\begin_layout LyX-Code

\size small
} else if ([[segue identifier] isEqualToString:@"logOutputViewPopover"])
 {
\end_layout

\begin_layout LyX-Code

\size small
LogOutputViewController *logOutputViewController =
\end_layout

\begin_layout LyX-Code

\size small
[segue destinationViewController];
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout Standard
Ein wenig Kopfzerbrechen bereitete mir der Umstand, dass offensichtlich
 zwischen iOS 5.1 und 6 zwischen dem Laden der View ein zeitlicher Unterschied
 besteht.
 Unter iOS 6 ist es vollkommen in Ordnung, wenn die Initialisierung des
 übergebenen Arrays in der Startmethode 
\shape italic
viewDidLoad
\shape default
 erfolgt.
 Doch während iOS 6 bei einem 
\shape italic
prepareForSegue
\shape default
 den Aufbau der View verzögert, bis die Methode abgearbeitet wurde, ist
 dies bei iOS 5.1 nicht der Fall.
 Die Initialisierung des übergebenen Arrays darf erst in der Initialisierungsmet
hode 
\shape italic
viewDidAppear
\shape default
 erfolgen, sonst werden alle Zellen mit 
\shape italic
nil
\shape default
 gefüllt.
\end_layout

\begin_layout Section
Hilfsklassen
\end_layout

\begin_layout Subsection
ResourceTableViewController
\end_layout

\begin_layout Standard
Die erste Hilfsklasse ist eine View vom Typ 
\shape italic
UITableViewController
\shape default
, einer Unterklasse des 
\shape italic
UIViewController
\shape default
.
 Der 
\shape italic
TableViewController
\shape default
 bietet eine View bestehend aus einer einzigen Tabelle, deren 
\shape italic
Delegate
\shape default
 und 
\shape italic
DataSource
\shape default
 er selbst ist.
 Ihm stehen die 
\shape italic
NSArrays
\shape default
 
\shape italic
keys
\shape default
 und 
\shape italic
values
\shape default
 zur Verfügung, welche die validierten Resourcen darstellen, die er von
 der Hauptview unmittelbar vor dem Erscheinen erhalten hat und die er in
 die Zellen seiner Tabelle einfüllt.
 Da eine Berührung einer Zelle veranlassen soll zur Hauptview zurückzukehren
 und dort die Ressource in das URL-Feld zu füllen, benötigt er für seine
 Funktion ein paar Referenzen: Zum einen benötigt er selbstverständlich
 die Referenz des URL-Feldes, auf deren Text er schreibend zugreift.
 Referenzen zu den 
\shape italic
NSStrings
\shape default
 
\shape italic
highestDir
\shape default
 und 
\shape italic
baseUrl
\shape default
 benötigt er, um die URLs vollständig erzustellen.
 Eine Resource 
\shape italic
1337
\shape default
, welche auf 
\shape italic
http://www.smartphoneseppel.de/customer/
\shape default
 gefunden wurde, sollte auf 
\shape italic
http://www.smartphoneseppel.de/customer/1337
\shape default
 verweisen, dafür wird die Ressource an den höchsten Verzeichnispfad der
 Abfrage gehangen, welche die Ressource 
\shape italic
1337
\shape default
 enthielt.
 Lautet eine Ressource 
\shape italic
/article/galaxy_s3
\shape default
 wird das als einen absoluten Pfad interpretiert und direkt an die Base-URL
 angehangen.
 Die Resultierende URL wäre somit 
\shape italic
http://www.smartphoneseppel.de/article/galaxy_s3
\shape default
.
\end_layout

\begin_layout Standard
Eine View kann sich nicht ohne weiteres selbst wieder schließen.
 Um dies zu realisieren wurde darüber hinaus noch die Referenz des PopoverContro
llers hierher übergeben.
 Der Zugriff auf diesen ermöglicht es, die View durch 
\family typewriter
\size small
[_referenceToPopoverController dismissPopoverAnimated:YES]
\family default
\size default
 wieder 
\begin_inset Quotes eld
\end_inset

von unten
\begin_inset Quotes erd
\end_inset

 zu beenden.
\end_layout

\begin_layout Subsection
HeaderKeysViewController
\end_layout

\begin_layout Standard
Wie auch bei der 
\shape italic
ResourceTableViewController
\shape default
 handelt es sich hier um eine Klasse des Typs 
\shape italic
UITableViewController
\shape default
.
 Er beinhaltet eine Auflistung der für eine Request gebräuchlichen 
\shape italic
Request Header
\shape default
 und der 
\shape italic
General Headers
\shape default
 und soll dem Anwender eine einfache Möglichkeit bieten, seine Anfrage um
 valide Header zu erweitern.
 Wie die zuvor genannte Klasse werden hier die Daten der durch Berührung
 selektierten Zelle in das Headers-Feld der Hauptview geschrieben und die
 View mittels Referenzzugriff auf den darunter liegenden 
\shape italic
PopoverController
\shape default
 beendet.
 Als kleines 
\begin_inset Quotes eld
\end_inset

Extra
\begin_inset Quotes erd
\end_inset

 wird die Referenz für das dem Header zugehörige Wertefeld übergeben, mit
 dessen Hilfe dieses zum 
\shape italic
FirstResponder
\shape default
 wird - nach dem Verwerfen der View hat dieses also den Tastaturfokus und
 es kann sofort nach dem Selektieren des headers mit der Eingabe des Wertes
 begonnen werden.
 
\end_layout

\begin_layout Subsection
XMLParser
\end_layout

\begin_layout Standard
Er ist nicht wirklich umfangreich, eignet sich jedoch perfekt, dessen Funktionsu
mfang in eine eigene Klasse auszugliedern.
 Er wird initialisiert mit zwei leeren 
\shape italic
MutableArrays
\shape default
, an die sowohl Attribute als auch Elemente der geparsten XML angefügt werden.
 Ein Attributname wird in Klammern gesetzt und erhält den Elementnamen,
 dem es zugehörig ist, vorangestellt.
 Die Bezeichnung der Keys setzt demnach sich wie Folgt zusammen:
\end_layout

\begin_layout LyX-Code

\size small
for (int i = 0; i < elementsToParse; i++) do
\end_layout

\begin_layout LyX-Code

\size small
   if actualObjectType = attribut then
\end_layout

\begin_layout LyX-Code

\size small
      keyArray[i] ← elementName + 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Quotes eld
\end_inset

 + attributName + 
\begin_inset Quotes eld
\end_inset

)
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout LyX-Code

\size small
      valueArray[i] ← AttributValue;
\end_layout

\begin_layout LyX-Code

\size small
   else if actualObjectType = element then
\end_layout

\begin_layout LyX-Code

\size small
      keyArray[i] ← elementName;
\end_layout

\begin_layout LyX-Code

\size small
      valueArray[i] ← elementValue;
\end_layout

\begin_layout LyX-Code

\size small
   fi;
\end_layout

\begin_layout LyX-Code

\size small
od;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
LogOutputViewController
\end_layout

\begin_layout Standard
Da es sich um ein Entwicklertool handelt, wäre es für den ein oder anderen
 sicherlich interessant zu sehen, was das Programm in der Kommandozeile
 an Output erzeugen würde wird.
 Da viele Informatiker ein Faible für schwarze Fenster mit durchlaufendem
 Text haben, soll eine 
\shape italic
PopoverView
\shape default
 ihnen diesen Wunsch erfüllen.
 Um nicht in jeder Zeile mit dem Datum, der Uhrzeit und dem Programmnamen
 beginnen zu lassen, wurden diese zu Beginn der Hauptklasse aus der Ausgabe
 von 
\shape italic
NSLog
\shape default
 herausgeschnitten, indem der reine Ausgabeteil als String in UTF8-Codierung
 mittels fprintf ausgegeben wird:
\end_layout

\begin_layout LyX-Code

\size small
#ifdef DEBUG
\end_layout

\begin_layout LyX-Code

\size small
#define NSLog(FORMAT, ...) fprintf(stderr,"%s
\backslash
n",
\end_layout

\begin_layout LyX-Code

\size small
[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);
\end_layout

\begin_layout LyX-Code

\size small
#endif
\end_layout

\begin_layout Standard
Weiterhin wird geich zu Beginn in der Methode 
\shape italic
viewDidLoad
\shape default
 die Ausgabe in eine Datei umgeleitet.
 Hierbei wird zuerst geschaut, ob bereits eine Ausgabedatei existiert.
 Ist das der Fall, so wird die Logging-Funktion automatisch eingeschaltet;
 ist sie nicht vorhanden, bleibt sie deaktiviert.
 Deaktiviert man sie im laufenden Programmbetrieb, so wird die Datei ebenso
 entfernt, somit findet man den Logging-Schalter bei einem App-Restart stets
 so vor, wie man ihn verlassen hat.
\end_layout

\begin_layout LyX-Code

\size small
NSArray *paths = NSSearchPathForDirectoriesInDomains
\end_layout

\begin_layout LyX-Code

\size small
(NSDocumentDirectory, NSUserDomainMask, YES);
\end_layout

\begin_layout LyX-Code

\size small
NSString *documentsDirectory = [paths objectAtIndex:0];
\end_layout

\begin_layout LyX-Code

\size small
logPath = [documentsDirectory stringByAppendingPathComponent:@"console.log"];
\end_layout

\begin_layout LyX-Code

\size small
NSFileManager *filemgr;
\end_layout

\begin_layout LyX-Code

\size small
filemgr = [NSFileManager defaultManager];
\end_layout

\begin_layout LyX-Code

\size small
if ([filemgr fileExistsAtPath:logPath]) {
\end_layout

\begin_layout LyX-Code

\size small
   NSLog (@"Existing log file found at %@ - logging to file enabled.", logPath);
\end_layout

\begin_layout LyX-Code

\size small
   freopen([logPath cStringUsingEncoding:NSASCIIStringEncoding],"a+",stderr);
\end_layout

\begin_layout LyX-Code

\size small
   [_logToFileSwitch setOn:YES];
\end_layout

\begin_layout LyX-Code

\size small
   [_logFileButton setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size small
   [_verboseLogLabel setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size small
   [_verboseLogSwitch setEnabled:YES];
\end_layout

\begin_layout LyX-Code

\size small
} else
\end_layout

\begin_layout LyX-Code

\size small
   NSLog (@"No existing log file found, logging disabled.");
\end_layout

\begin_layout Standard
Möchte man das Gesehene nach dem Sichten löschen, das Logging jedoch eingeschalt
et lassen, lässt sich der Usability wegen der Mülleimer unter dem Ausgabe-Fenste
r antippen.
 An diesem Icon habe ich keine Bildunterschrift angebracht, denn es sollte
 selbsterklärend sein, was hier passiert.
 Möchte man noch mehr Mitschnitte, lässt sich ein Verbose-Modus einschalten,
 in dem noch eine Reihe mehr Informationen über das Programmverhalten mitgeschni
tten werden.
 Auch hier bin ich über ein unerwartetes Problem gestolpert: Da die View
 sehr wenig Code und nichts beinhaltet, was eine Delegate oder DataSource
 benötigt, wollte ich diese recht codezeilenarme Funktionalität in der Hauptview
 unterbringen.
 Jedoch war nach dem Öffnen der View das Ausgabefeld stets leer und ich
 musste einige Zeit lang erst einen Refresh-Button betätigen, der die Datei
 neu in das Textfeld gelagen hat.
 Abhilfe brachte das Auslagern in eine eigene Klasse mit der Initialisierungsmet
hode viewDidAppear, welche nun das Laden der Datei übernimmt.
\end_layout

\begin_layout Subsection
HistoryElement
\end_layout

\begin_layout Standard
Hierbei handelt es sich im ein Element einer doppelt verketteten Liste.
 Es kennt seinen Vorgänger, seinen Nachfolger als auch die an ihn gebundene
 Ressource.
 
\shape italic
HistoryElement
\shape default
 verfügt über eine Methode 
\shape italic
getPart
\shape default
, die auf Wunsch die Basis-URL - bestehend aus Protokoll und Domain -, den
 höchsten Verzeichnispfad oder den vorherigen zurückliefert.
 Der Unterschied zwischen vorherigem und höchstem Verzeichnis ist der Folgende:
 Endet eine URL mit einem Schrägstrich, so wird er als Verzeichnis angenommen
 und ist somit gleichzeitig auch das höchste.
 Endet er nicht mit einem Schrägstrich, wird eine Datei in einem Verzeichnis
 vermutet und statt dessen das letzte Verzeichnis zurückgegeben, das mit
 einem Schrägstrich endet.
 Wird das vorherige Verzeichnis angefragt, wird immer das vorherige Verzeichnis
 angegeben, egal ob das aktuelle mit einem Schrägstrich endet oder nicht.
\end_layout

\begin_layout Standard
Beispiel 1: @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de/customer/1337
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
highestDir = previousDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de/customer/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Beispiel 2: @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/1337/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
highestDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/1337/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
previousDir = @
\begin_inset Quotes eld
\end_inset

http://www.smartphoneseppel.de
\shape italic
/
\shape default
shoppingcart/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
...
 und die AppDelegate?
\end_layout

\begin_layout Standard
Erstellt man ein neues Projekt, befindet sich im Projektordner neben dem
 oder den Controllern stets eine weitere Klasse: die 
\shape italic
AppDelegate
\shape default
.
 Konzeptuell sollte der 
\shape italic
ViewController
\shape default
 alles beinhalten, womit sich die aktuelle 
\shape italic
View
\shape default
 beschäftigt.
 Die 
\shape italic
AppDelegate
\shape default
 bleibt dabei erschreckend leer und hinterlässt das Gefühl, dass man doch
 etwas Wichtiges vergessen hat.
 Die einzige Methode, die überhaupt etwas macht ist die application 
\shape italic
didFinishLaunchingWithOptions:launchOptions
\shape default
.
 Sie gibt ein YES zurück.
 Immerhin.
\end_layout

\begin_layout Standard
Auch hier läuft wieder alles über das Storyboard.
 Wirft man einen Blick auf die Datei 
\shape italic
REST Analyzer-Info.plist
\shape default
 findet sich ein Schlüssel mit der Bezeichnung 
\shape italic
Main storyboard file base name
\shape default
 und dem Wert 
\shape italic
MainStoryboard
\shape default
.
 Die Bedeutung hinter diesem Eintrag ist Folgende: Ist diese Einstellung
 gesetzt, lädt UIApplication die Datei mit der Bezeichnung MainStoryboard.storybo
ard, instantiiert den ersten ViewController und packt dessen View in ein
 neues Objekt des Typs UIWindow.
 Kein Programmieraufwand nötig.
\end_layout

\begin_layout Chapter
Schlusswort und Ausblick
\end_layout

\begin_layout Standard
Es ist vollbracht - die erste eigene Anwendung, geschrieben in der auf den
 ersten Blick exotisch anmutenden Programmiersprache mit den vielen eckigen
 Klammern, läuft auf dem marktbeherrschenden Tablet-Computer der Firma Apple
 Inc.
 In einem abschließenden Fazit werde ich die einzelnen Schritte auf dem
 Weg hierher als auch den persönlichen Nutzen dieser Arbeit für mich reflektiv
 umreißen und auf die sich für mich ergebende Bereitschaft eingehen, weiterhin
 in dieser Umgebung zu entwickeln.
\end_layout

\begin_layout Standard
Objective-C ist anders.
 Allerdings nicht so anders, dass man sich nicht mit ein wenig Zeit daran
 gewöhnen kann.
 Und möchte.
 Die Namenskonvention bei Objective-C ist gewöhnungsbedürftig, die Verwendung
 von scheinbar möglichst langen Variablennamen oder einer redundanten zusätzlich
en Beschreibung für jeden Parameter in einer Methode ist zu Beginn äußerst
 gewöhnungsbedürftig, steigert aber die Lesbarkeit des Codes ungemein.
 Auch an die Notation mit den eckigen Klammern gewöhnt man sich ziemlich
 schnell - wenngleich das auch nicht wirklich nötig ist, denn die Klammern
 lassen sich in den meisten Fällen mit der alternativ angebotenen Punkt-Schreibw
eise umgehen, die für die meisten Umsteiger sehr vertraut wirkt.
 Ich selbst habe mich nach einiger Eingewöhnungszeit recht schnell schon
 während meines ersten Programmes auf diese Notation umgestellt; sie führte
 mir automatisch das Konzept der Nachrichtenkommunikation vor Augen.
 Die Cocoa-API erleichtert viele programmatische Handgriffe und es lohnt
 sich stets, einen Blick in die Referenz zu werfen.
 Beispielsweise habe ich zuerst anhand der Content-Länge überprüft, wann
 eine Response vollständig eingegangen ist.
 Ein sehr einfacher Weg, leider setzt er voraus, dass die Content-Länge
 in der Response angegeben ist.
 Da dies jedoch nicht immer der Fall ist, implementierte ich einen Workaround,
 der eine eingehende Response einen NSTimer starten lies, welcher sich bei
 jedem eingehenden Package wieder zurücksetzte.
 So sollte der Client herausfinden, ab wann eine Nachricht unbekannter Länge
 als “vollständig empfangen” anzusehen ist.
 Ein sorgfältiger Blick in die Referenz hätte mir diesen Umstand abgenommen,
 denn dort wäre ich auf die Methode connectionDidFinishLoading gestoßen,
 welche eine elegantere Lösung zu genau dieser Problematik bietet, denn
 deren Implementation wird nach dem Erhalt des finalisierenden Packages
 aufgerufen.
\end_layout

\begin_layout Standard
Auch meine Erfahrungen mit Xcode waren fast durchgängig von sehr angenehmer
 Natur.
 Unter Apples Entwicklungsumgebung lässt es sich sehr angenehm arbeiten.
 Die Live-Prüfung, die eine Autokorrektur für syntaktische Fehler und Vertipper
 anbietet und auch der Assistenzcontroller, der zur geöffneten Datei immer
 gleich passende Sekundärdateien anbietet, sind Dinge, die ich in künftigen
 Entwicklungsumgebungen nur ungern missen werde.
 Ein kleiner Wermutstropfen ist, dass Xcode nach einiger Zeit kontinuierlich
 immer langsamer wird.
 Das geht so weit, dass es eine Qual ist, den aktiven Quellcode-Tab zu wechseln,
 da man im schlimmsten Fall eine gefühlte Ewigkeit auf das drehendes Rad
 schaut, in welchen sich der Mauszeiger verwandelt, um den ausgelasteten
 Zustand der Anwendung zu signalisieren.
 Ein wenig Foren-Recherche ergibt schnell, dass der Schuldige die sich ansammeln
den Workspace-Einstellungen sind.
 Lässt man sich die Inhalte des Packages Projectname.xcodeproj anzeigen,
 so findet man dort eine Datei mit der Bezeichnung project.xcworkspace.
 In dieser Datei speichert Xcode die Einstellungen ab.
 Nach einem Löschen dieser Datei und Neustart von Xcode sind zwar alle Workspace
-Einstellungen verschwunden, Xcode im Gegenzug aber um ein Vielfaches performant
er.
 Ein Opfer, dass man an dieser Stelle gerne zu zahlen bereit ist.
 Es könnte natürlich sein, dass es sich um einen versionsspezifischen Bug
 handelt.
 In der aktuellen Version 4.5.2 habe ich dieses Verhalten noch nicht festgestellt,
 allerdings war beim Update auf diese Version die Implementation des Clienten
 nahezu vollständig.
\end_layout

\begin_layout Standard
Das Storyboard ist eine ungemeine Arbeitserleichterung, wenn es an die Gestaltun
g der GUI geht.
 Hier findet der erste Kontakt mit Xcode statt, die ersten Zeilen Code,
 die bereits ein vollständiges GUI-Grundgerüst bilden, werden hier generiert.
 Es fühlt es unglaublich einfach an und schafft es, Berührungsängste schnell
 zu nehmen.
 Mit wenig Zeitaufwand sind Views und Übergänge erstellt, GUI-Elemente eingefügt
, gegebenenfalls deren Delegates und DataSources zugewiesen und in der Seitenlei
ste die Eigenschaften gesetzt, welche die Elemente bei Anwendungsstart besitzen
 sollten.
 Automatisch werden die Bereiche im Code eingefügt und mit den Storyboard-Elemen
ten verbunden und man beginnt kurze Zeit später bereits mit der eigentlichen
 Implementation der Funktionalitäten, ohne das Gefühl zu haben, sich vorher
 an notwendigen Nebensächlichkeiten aufhalten zu müssen.
 Selbstverständlich lässt sich auch alles ohne Storyboards entwerfen.
 Durch das Storyboard bereit gestellte Funktionalität sollte man jedoch
 nach Möglichkeit nicht mit dem programmatischen Weg vermischen.
 Es hat mich viel Zeit und Recherche gekostet, festzustellen, dass eine
 im Storyboard erstellte View nicht ohne Weiteres programmatisch zugreifbar
 ist.
 Der Weg, einem Übergang eine eindeutige Bezeichnung zu verpassen und auf
 diese über die in einem solchen Fall automatisch aufgerufene Methode prepareFor
Segue zuzugreifen, wirkte auf mich ein wenig wie ein Workaround, ist aber
 wohl der Weg, der in einem solchen Fall zu gehen ist.
 Um der Übersichtlichkeit zu genügen bietet das Storyboard 4 Zoomstufen
 an: 12,5 %, 25 %, 50 % und 100 %.
 Warum an dieser Stelle keine manuelle Eingabe der Zoomstufe gegeben ist
 oder zumindest ein Schieberegler angeboten wird, der sich etwas feingranularer
 einstellen lässt, ist mir nicht ganz ersichtlich.
 Bei meiner durchaus gängigen FullHD-Auflösung wäre oft 75 % die Zoomstufe
 meiner Wahl gewesen.
\end_layout

\begin_layout Standard
In der Wahl der Implementationsthematik fand ich mit den RESTful Webservices
 ein interessantes Umsetzungsgebiet.
 Die Umsetzung eines generischen Client, der auf verschiedene Webservices
 zugreift, deren Schnittstelle die Methoden bilden, die das HTTP-Protokoll
 schon selbst mitbringt, war interessant und erweiterte meine Kenntnisse
 der Webservices.
 Die diesem Standard zugrunde liegende Idee ist einfach und leicht zu implementi
eren und das Arbeiten mit HTTP-Verben fühlt sich “irgendwie nach Internet”
 an.
 In einem ersten Implementationsansatz verwendete ich das externes Framework
 RestKit, welches ich dafür andachte, mir die Arbeit mit REST-konformen
 Seiten zu erleichtern.
 Es stellte sich jedoch sehr schnell heraus, dass einige der Funktionen
 meine Erwartungen nicht erfüllen konnten, so bot mir RestKit das Mappen
 einer JSON-Ressource in ein NSDictionary an, welches jedoch bereits über
 die Schlüssel verfügen musste, zu welchen anschließend die Werte hinzugefügt
 werden.
 Für einen generischen Clienten, der jedoch noch nicht weiß, welche Schlüssel
 die Zielressource liefern wird, ist das leider nur von eingeschränktem
 Nutzen und die Zuhilfenahme eines Parsers ist unvermeidlich.
 Apple bietet in seinem hauseigenen Framework sowohl einen Parser für XML
 als auch einen Parser für JSON an, welcher bei vergleichbarer Funktionalität
 bereits wegen der offiziellen Unterstützung durch Apple bevorzugt eingesetzt
 werden sollte.
 Auch andere Teile, die das externe Framework mir bereitstellen würde, waren
 ohne größere Schwierigkeiten durch ein breites Arsenal hilfreicher Funktionen
 zu realisieren, die Cocoa Touch ohnehin bereitstellt.
 Letztendlich erlaubte dies mir die Umsetzung dieser Arbeit, ohne dass ich
 auf externe Frameworks zurückgreifen musste.
\end_layout

\begin_layout Standard
Abschließend kann ich über die vergangenen Wochen, in denen ich mich mit
 dieser Arbeit beschäftigt habe, Folgendes sagen: Mein “Blick über den Tellerran
d“ in Richtung Objective-C ab fühlt sich befriedigend an.
 Der Exkurs wird hier noch nicht enden, denn ich möchte noch einige weitere
 Anwendungen für Apple-Hardware entwickeln.
 Die Arbeit auf und mit Apples Plattform hat sich für mich als sehr angenehm
 erwiesen und meinen Programmierstil positiv beeinflusst.
 Kurze und unverständliche Variablennamen werde ich zugunsten der Lesbarkeit
 künftig vermeiden, ebenso werde ich beim Entwickeln fernab Objective-C
 die zusätzlichen Parameter-Bezeichner in den Methoden vermissen.
 Einen ersten Kundenauftrag für eine iPhone-App habe ich bereits schon vor
 dem Abschluss dieser Arbeit angenommen.
 Xcode wird also schon sehr bald wieder geöffnet werden und meinen Ausflug
 in die Objective-C-Welt werde ich dort weiterführen, wo ich ihn mit dem
 Abschluss dieser Arbeit unterbrochen habe.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Dissertation Fielding"

\end_inset

Fielding, Roy (2000) Dissertation: Architectural Styles and the Design of
 Network-based Software Architectures
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bayer - REST Einführung"

\end_inset

Bayer, Thomas (2002): REST Webservices: Eine Einführung
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JAXenter"

\end_inset

Tilkov, Stefan (2009): REST - Der bessere Webservice? In: JAXenter, URL:
 http://it-republik.de/jaxenter/artikel/REST---Der-bessere-Web-Service-2158.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - Webservice"

\end_inset

Wikipedia: Web service, URL: http://en.wikipedia.org/wiki/Web_service (letzter
 Aufruf am 5.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - REST"

\end_inset

http://de.wikipedia.org/wiki/Representational_State_Transfer
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JSON.org - Einführung in JSON"

\end_inset

Introducing JSON, URL: http://json.org/index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "W3C - XML Essentials"

\end_inset

XML ESSENTIALS, URL: http://www.w3.org/standards/xml/core
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "The Objective-C Programming Language"

\end_inset

https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjectiveC
/Introduction/introObjectiveC.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Learning Objective-C"

\end_inset

http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/Learning_O
bjective-C_A_Primer/_index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Galileo Computing"

\end_inset

Rodewig, Klaus M.
 / Wagner, Clemens: Apps entwickeln für iPhone und iPad - Das Praxisbuch,
 Galileo Computing, 2012, URL: http://openbook.galileocomputing.de/apps_entwickeln
_fuer_iphone_und_ipad/index.html
\end_layout

\end_body
\end_document
