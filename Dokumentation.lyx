#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass ucthesisLyx
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Einleitung (2 - 3 Seiten)
\end_layout

\begin_layout Standard
Hier könnte ihr Text stehen...
 :-)
\end_layout

\begin_layout Chapter
Die Werkzeugkiste (10 - 12 Seiten)
\end_layout

\begin_layout Section
Basissprache: Objective-C (2 - 3 Seiten)
\end_layout

\begin_layout Standard
Möchte man seine erste App für ein Apple-Gerät entwickeln, steht man zuallererst
 vor einer kleinen Herausforderung: So wie Microsoft für sein .NET-Framework
 die C#-Sprache entwickelte, welche Grundkonzepte der objektorientierten
 Hochsprachen C++, Java und Delphi in sich vereint, wird für Apple-Hardware
 grundsätzlich die Sprache Objective-C verwendet.
 Anders als C# greift das in den frühen 80ern entwickelte ObjC auf das prozedual
e ANSI-C zurück, die objektorientierte Erweiterung ist an Smalltalk angelehnt
 und von der C-Syntax strikt getrennt.
 Die syntaktisch wichtigsten Neuerungen sind Klassen und Methodenaufrufe.
 Das gleiche Erweiterungskonzept findet auch auf andere prozeduale Sprachen
 Anwendung, so werden zum Beispiel aus Pascal und JavaScript, welche über
 kein Klassenkonzept verfügen, die um Objektorientiertheit ergänzten Sprachen
 Objective-Pascal und Objective-J.
\end_layout

\begin_layout Standard
Wie aus der C-Welt bekannt verwendet man Header (.h) sowie deren Implementierunge
n in Quellcodedateien (.m), welche ObjC- bzw.
 C-Code enthalten können.
 Aus Kompatibilitätsgründen kann man auch Implementierungen als mit der
 Erweiterung mm anlegen, welcher auch explizit C++-Code enthalten darf.
 Auf diese Art kann man C++-Bibliotheken weiterverwenden.
 Statt #include sollte man hier auf #import zurückgreifen, weil es sicher
 stellt, dass die angegebene Datei nie mehr als einmal eingebunden wird.
 Da das ein äußerst sinnvolles Feature ist, wird es auch von allen gängigen
 ObjC-Compilern unterstützt.
\end_layout

\begin_layout Standard
Die größte Umstellung zum Denken in Objective C ist, dass es keine Funktionen
 mehr gibt, die mit Parametern aufgerufen werden.
 Hier verwendet man Objekte, die sich untereinander Nachrichten an Methoden
 senden und so miteinander kommunizieren.
 Dieses Paradigma nennt sich 
\shape italic
Message Passings
\shape default
 und unterscheidet sich stark von der Art der Aufrufe, die C++ nutzt.
 Grundsätzlich darf jedes Objekt jede Nachricht an jedes Objekt senden -
 oder an sich selbst - ganz gleich ob die Zielklasse (oder eine deren Oberklasse
n) die passende Methode zu dieser Nachricht implementiert.
 Da die Methoden immer erst zur Laufzeit (und nicht bereits beim Kompilieren)
 ermittelt werden, entscheidet sich erst beim Aufruf, wie ein Objekt auf
 eine Nachricht reagieren wird.
 Dieses Verfahren bezeichnet man daher auch als 
\shape italic
dynamisches Binden
\shape default
 - im Gegensatz zu verwendeten C-Funktionen, die bei der Kompilierung bereits
 statisch gebunden werden.
 Es lässt sich sogar eine Klassenmethode implementieren, welche auf Nachrichten
 reagiert, für die die Klasse keine eigene Implementierung bereitstellt.
 Abstrakte Methoden kennt ObjC übrigens nicht - jede Klasse muss immer vollständ
ig implementiert werden, damit stets Objekte dieser Klasse erzeugt werden
 können.
\end_layout

\begin_layout Standard
Ebenso wie in C++ lassen sich aus einer Klasse Objekte erzeugen.
 Darüber hinaus ist aber jede Klasse selbst als Objekt ansprechbar.
 Diese anthalten jedoch keine Member-Variablen und sind stets Singletons
 - eine Art Erzeugungsmuster, die sicher stellen, dass von einer Klasse
 genau ein Objekt existiert, welches global verfügbar ist.
 So wie ein solches Klassenobjekt in der Lage ist, Nachrichten zu empfangen,
 erfolgt das Binden der entsprechenden Methoden ebenfalls erst zur Laufzeit.
 Strings werden in ObjC in der Notation @
\begin_inset Quotes erd
\end_inset

…
\begin_inset Quotes erd
\end_inset

 erzeugt.
 Dieser String ist ein Objekt vom Typ NSString und als solcher ebenfalls
 in der Lage, Nachrichten zu empfangen.
 Wird das @ weggelassen, wird ein Nullterminierter C-String erzeugt.
 Per Vorgabe besitzen die Datentypen in ObjC die gleiche Typisierung wie
 in C: Sie sind statisch, schwach und explizit.
 Für das Konzept der dynamischen Typisierung existiert der typlose Datentyp
 id, welcher einen Zeiger auf ein Objekt beliebiger Klasse repräsentiert
 und an den jede beliebige Nachricht gesendet werden kann.
 Falls der Typ des Objektes diese Methode jedoch nicht unterstützt, kommt
 es selbstverständlich zu einem Laufzeitfehler.
 Möchte man eine solche typlose Variable einer Variable mit einem Typ zuweisen,
 so müssen diese Typen natürlich übereinstimmen, sonst kommt es zu einem
 Laufzeitfehler.
\end_layout

\begin_layout LyX-Code

\size small
id typelessObject = @"I'm a string."; // OK     NSString *string = typelessObject
;    // OK     NSNumber *integer = typelessObject;   // logischer Fehler
     char character = [integer charValue]; // Laufzeitfehler     NSLog(@"%i",int
eger);
\end_layout

\begin_layout Standard
Ein Instanzobjekt einer Klasse wird erzeugt, indem eine Nachricht an das
 zugehörige Klassenobjekt gesendet wird.
 Für gewöhnlich passiert dies beim Programmstart, im Gegensatz zu C++ können
 bei ObjC jedoch auch während der Laufzeit noch neue Objekte erstellt werden.
 Aus C++/Java bekannte überladene Methoden findet man so in ObjC nicht mehr;
 eine Nachricht an eine Methode besteht aus einem 
\shape italic
Selektor
\shape default
 - dem Methodennamen - und den Parametern.
 Das Laufzeitsystem sucht bei einer eingehenden Nachricht nach einer solchen
 Methode und führt diese im Erfolgsfall aus.
 Wird keine entsprechende Methode gefunden, wird ein 
\shape italic
nil
\shape default
 zurückgegeben.
 Es besteht natürlich auch die Möglichkeit, ein Objekt vorher zu fragen,
 ob eine bestimmte Nachricht verstanden wird.
 Diese Fähigeit der Selbstkenntnis beinhaltet ebenfalls das Ermitteln der
 eigenen Klasse oder das Wissen, ob seine Klasse eine Unterklasse einer
 bestimmten anderen Klasse ist und nennt sich Reflexion und sollte dem ein
 oder anderen ebenfalls aus der C++/Java-Welt bekannt sein.
\end_layout

\begin_layout LyX-Code

\size small
if([geometricFigure respondsToSelector:@selector(getShape)]) { … }
\end_layout

\begin_layout Standard
Dem Smalltalk-Erweiterungsanteil verdankt ObjC die verwendete Notation mit
 eckigen Klammern, um Nachrichten zu versenden.
 Zuerst wird das Empfängerobjekt genannt, anschließend der Selektor und
 ggfls.
 der Parameter.
 Sind Sender und Empfänger der Nachricht das gleiche Objekt, verwendet man
 den Bezeichner 
\family typewriter
\size small
self
\family default
\size default
.
\end_layout

\begin_layout LyX-Code

\size small
// somewhere lost in code:
\end_layout

\begin_layout LyX-Code

\size small
NSInteger age = [self computeAgeFromYear:1981 withMonth:5 andDay:23]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
// method declaration:
\end_layout

\begin_layout LyX-Code

\size small
- (NSInteger)computeAgeFromYear:(NSInteger)birthyear
\end_layout

\begin_layout LyX-Code

\size small
                      withMonth:(NSInteger)month
\end_layout

\begin_layout LyX-Code

\size small
                         andDay:(NSInteger)day { … }
\end_layout

\begin_layout Standard
Diese Schreibweise ist für jemanden, der aus der C++/Java-Welt kommt äußerst
 gewöhnungsbedürftig, da hier jeder Parameter eine explizite Benennung erfordert
 und Methodennamen können in ObjC durchaus sehr lang werden.
 Hat man sich jedoch einmal daran gewöhnt, möchte man dies jedoch nur schwer
 wieder missen wollen, fördert es die Lesbarkeit und Verständlichkeit des
 Codes ungemein.
 Die angegebene Methode bezeichnet man vollständig in der Form: 
\family typewriter
\size small
computeAgeFromYear:withMonth:andDay
\family default
\size default
.
\end_layout

\begin_layout Standard
Das Minus-Präfix zu Beginn der oben stehenden Methode zeigt auf, dass es
 sich hierbei um eine Instanzmethode handelt.
 Das entspricht unserem Verständnis einer Methode in C++/Java.
 Da jedoch auch Klassen Objekte sind, können diese eigene Methoden haben.
 Solche Klassenmethoden werden durch ein vorangestelltes Plus gekennzeichnet.
 Ein gutes Beispiel ist der zum Initialisieren gebräuchliche verkettete
 Befehl 
\family typewriter
\size small
[[NSObject alloc] init]
\family default
\size default
, der aus den folgenden Methoden besteht: 
\family typewriter
\size small
+(id)alloc
\family default
\size default
 ist die Klassenmethode, welche Speicher für das Objekt reserviert, anschließend
 initialisiert sich das erzeugte Objekt durch den Aufruf von 
\family typewriter
\size small
-(id)init
\family default
\size default
.
\end_layout

\begin_layout Subsection*
Delegate
\end_layout

\begin_layout Section
API: Cocoa Touch (2 - 3 Seiten)
\end_layout

\begin_layout Standard
iOS lässt sich in vier grundlegende Schichten einteilen: Während sich auf
 dem Core OS der Mach-Kernel sowie die grundlegenden Funktionen beinhaltet,
 stellen die Core Services die Frameworks bereit, die Grundlage aller Anwendunge
n und Dienste sind, die auf dem Gerät laufen.
 Der darüber liegende Media-Layer beinhaltet sämtliche Multimediafunktionen,
 schlussendlich folgt die Programmierschnittstelle Cocoa Touch, welche Schnittst
ellen zu sämtlichen darunter liegenden Schichten bereitstellt.
 Gegenüber Cocoa, der Schnittstelle für OS X-Maschinen, greift die Touch-Variant
e der API auf eine passende Benutzerschnittstelle zurück und beinhaltet
 Dinge wie Unterstützung der Bewegungssensoren, Multitouch-Gestenerkennung
 sowie Animationen, welche speziell auf iOS abgestimmt sind und dem Programmiere
r darauf abgestimmte Eingabeelemente und Events anbietet.
 Die Basis von Cocoa Touch bilden mehrere Frameworks: das Foundation Framework
 liefert alle Basisklassen, die die Grundlage zur Programmierung mit Objective-C
 bilden und Werkzeuge wie Collections und Dateihandling bereitstellen, ohne
 die eine moderne Programmierung heute nicht mehr auskommt.
 Seit der iOS-Version 2 befindet sich darin bereits XML-Unterstützung, welche
 in iOS 5 um die JSON-Unterstützung ergänzt wurde, was es im Rahmen dieser
 Arbeit sehr einfach macht, auf dritte Frameworks zu verzichten.
 Das UIKit beinhaltet Klassen, welche speziell auf die Entwicklung der grafische
n Oberfläche ausgerichtet sind.
 So enthält die Infrastruktur für grafische Anwendungen verschiedene Ansichten,
 so genannte Views, und deren Fenster, Menüs und Schaltflächen, sowie einen
 Ereignisbetrieb mit Sprachanbindung und Textsystem.
 Eeignisse durchlaufen eine so genannte 
\begin_inset Quotes eld
\end_inset

Responder-Chain
\begin_inset Quotes erd
\end_inset

, die aus unterschiedlichen Klassen besteht und ein eingetroffenes Ereignis
 entnehmen und verarbeiten.
 Seit OS X 10.4/iOS 3 wurde diese Sammlung um das Core Data Framework ergänzt,
 welches für die Erstellung von Objektgraphen kümmert und dem schnellen
 Entwurf von Modellen im Model-View-Controller-System dienlich ist.
 Das MVC-Muster ist in Cocoa strikt umgesetzt; Klassen lassen sich in der
 Regel eindeutig zuordnen.
 Bei den Klassennamen selbst ist auffallend, dass die meisten mit NS beginnen,
 wie z.
 B.
 NSObject, NSString oder NSArray.
 Dies hat seinen Ursprung darin, dass Apple im Jahre 1996 das OpenStep-Framework
 NeXTStep aufkaufte und als Basis für Mac OS X verwendete.
 Durch die Verwendung von 
\begin_inset Quotes eld
\end_inset

Klassen-Clustern
\begin_inset Quotes erd
\end_inset

 werden viele sichtbare Klassen nie instanziert, sondern es werden direkt
 zur Laufzeit statt dessen Instanzen von passenden Subklassen erzeugt, von
 denen der Programmierer keine Kenntnis hat.
 Beispielsweise verlangt ein Anwendungsprogrammierer nach einer Instanz
 von NSArray, erzeugt wird jedoch in Abhängigkeit der Elemente eine Instanz
 eine Klasse, die er nicht kennt.
\end_layout

\begin_layout Section
IDE: XCode (2 - 3 Seiten)
\end_layout

\begin_layout Standard
XCode ist Apples integrierte Entwicklungsumgebung und steht aktuell in der
 Version 4.5 zur Verfügung.
 Seit der Version 4.1 lässt sich XCode für jedermann zugänglich kostenlos
 im App Store herunterladen.
 In der Version 4.4 sind die SDKs für OS X 10.8 sowie für iOS 5.1 enthalten,
 Xcode 4.5 bringt die SDK für das neue iOS 6 mit.
 Beide benötigen mindestens OS X in der Version 10.7.4 Lion oder 10.8 Mountain
 Lion.
 Mit Hilfe von XCode lassen sich OS X- oder iOS-Anwendungen entwickeln,
 wobei OS X-Anwendungen auf der 
\shape italic
Cocoa
\shape default
-API basieren; möchte man eine iOS-Anwendung entwickeln, stellt Apple hierfür
 die API Cocoa Touch bereit.
\end_layout

\begin_layout Standard
Da es vor allem auf mobilen Geräten eher zu Resourcenknappheit kommt als
 auf Desktop-Systemen, sollte man hier einen entsprechend resourcensparenden
 Programierstil pflegen und Resourcen, die nicht mehr benötigt werden, nach
 der Verwendung wieder freigeben.
 In XCode 4.2 wurde das Automatic Reference Counting eingeführt, um sich
 dieses Problemes anzunehmen.
 Die bislang verwendeten 
\family typewriter
\size small
retain
\family default
\size default
 und 
\family typewriter
\size small
release
\family default
\size default
-Nachrichten, die bisher vom Programmierer verwendet wurden um Speicher
 freizugeben oder eben diese Freigabe zu verhindern, sind somit obsolet.
 Statt dessen übernimmt nun der Compiler die Referenzzählung und fügt dem
 Code beim Übersetzen die entsprechenden 
\family typewriter
\size small
retain
\family default
\size default
 und 
\family typewriter
\size small
release
\family default
\size default
-Nachrichten hinzu.
\end_layout

\begin_layout Standard
- Hilfe bei der Suche nach eckigen Klammern
\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

IDE light
\begin_inset Quotes erd
\end_inset

: Storyboard (2 - 3 Seiten)
\end_layout

\begin_layout Standard
Neu eingeführt in XCode 4.2.
\end_layout

\begin_layout Section
Entwicklerlizenz (1 Seite)
\end_layout

\begin_layout Standard
Grundsätzlich lässt sich eine App auch ohne Lizenz entwickeln und auf dem
 eingebauten 
\shape italic
iOS Simulator
\shape default
 des seit der Version 4.1 für jedermann verfügbaren XCode testen.
 Möchte man jedoch die App auf einem 
\begin_inset Quotes eld
\end_inset

echten
\begin_inset Quotes erd
\end_inset

 Gerät zur Ausführung bringen und später einmal in den App Store stellen,
 benötigt man eine Entwicklerlizenz von Apple.
 Diese kostet derzeit 99 USD bzw.
 80 EUR und ist für genau ein Jahr gültig.
 Mit einem Entwickleraccount hat man Zugriff auf 
\shape italic
itunes Connect
\shape default
, mit dem sich der eigene Account, die verfügbaren iOS-Geräte sowie die
 eingestellten Apps verwalten lassen.
\end_layout

\begin_layout Standard
Der erste Schritt ist es, die User anzulegen, welche an der Entwicklung
 und Distribution der Software beteiligt sind.
 Hier stehen die vordefinierten Rollen 
\shape italic
Admin
\shape default
, 
\shape italic
Technical
\shape default
, 
\shape italic
Finance
\shape default
 sowie 
\shape italic
Sales
\shape default
 zur Verfügung.
 Während der 
\shape italic
Technical
\shape default
 Rechte für die Verwaltung der Apps bekommt, stehen dem 
\shape italic
Finance
\shape default
 weitergehend verschiedene Rechte im Bereich Finanzwesen, Analyse und Vertrieb
 bereit, die der 
\shape italic
Technican
\shape default
 eher nicht benötigt.
 Auf die Verwaltung der Apps hat er nur lesenden Zugriff, so kommen sich
 die Beiden nicht in die Quere.
 Der Rolle 
\shape italic
Sales
\shape default
 letztendlich steht nur der Verkaufs und die Verkaufsanalyse offen.
\end_layout

\begin_layout Standard
Abhängig vom Vertriebsmodell müssen wir in 
\shape italic
iTunes Connect
\shape default
 nun weitere Angaben machen.
 Für unentgeltliche Apps ist es weder notwendig, einen Vertrag zu akzeptieren,
 noch müssen wir Bankdaten hinterlegen.
 Mochten wir jedoch mit unseren Apps Geld verdienen, stehen uns die Vertragstype
n 
\shape italic
iOS Paid Applications
\shape default
 sowie für in-App-Werbung 
\shape italic
iAd Network
\shape default
 zur Verfügung.
 Hier sind die ensprechenden Vertragsbedingungen zu akzeptieren, Kontaktinformat
ionen anzugeben, Landesangaben zur Versteuerung zu machen und natürlich
 die Bankdaten für den zu erwartenden, eingehenden Zahlungsverkehr zu hinterlege
n.
\end_layout

\begin_layout Standard
Um eine App direkt auf unserem Gerät ausführen zu können, benötigen wir
 ein Development Certificate.
 Hierzu schließen wir das Gerät, das wir hinzufügen möchten, an den Mac
 an und wechseln in XCode in den Organizer.
 Hier können wir das angeschlossene Gerät unserem Entwickleraccount zuordnen.
 Beim ersten Mal wird uns XCode mitteilen, dass kein 
\shape italic
iOS Development Certificate
\shape default
 vorhanden ist und bietet an, einen solchen von Apple anzufordern.
 Anschließend fügt er diesen automatisch der Schlüsselverwaltung hinzu und
 bietet an, das Entwicklerprofil für den Einsatz auf anderen Macs zu exportieren.
 In den 
\shape italic
Build Settings
\shape default
 unserer App stellen wir nun die 
\shape italic
Code Signing Identity
\shape default
 auf das neu erzeugte Zertifikat um und sind nun in der Lage, das angeschlossene
 iOS-Gerät statt des Simulators für die Entwicklung zu benutzen.
\end_layout

\begin_layout Section
Repository (zu wenig - > irgendwo integrieren)
\end_layout

\begin_layout Itemize
Einrichten eines github-Accounts git@github.com:MarioStief/RemoteRepository.git
\end_layout

\begin_layout Description
Adresse: https://github.com/MarioStief/RemoteRepository
\end_layout

\begin_layout Itemize
SSH-Schlüssel erstellen, auf github eintragen, Verbindung testen
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ssh-keygen -t rsa -C "mario.stief@gmail.com"
\end_layout

\begin_layout Plain Layout

pbcopy < ~/.ssh/id_rsa.pub
\end_layout

\begin_layout Plain Layout

ssh -T git@github.com
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Hinzufügen im Project-Organizer als Remote Directory
\end_layout

\begin_layout Itemize
Initial Commit.
\end_layout

\begin_layout Chapter
Schnittstelle mit der REST-Welt (8 Seiten)
\end_layout

\begin_layout Section
RESTful Webservices (5,5 Seiten)
\end_layout

\begin_layout Subsection
Begriffseinführung
\end_layout

\begin_layout Standard
Wikipedia definiert den Begriff 
\shape italic
Webservice
\shape default
 als 
\begin_inset Quotes eld
\end_inset

eine Methode der Kommunikation zwischen zwei elektronischen Geräten über
 das Internet
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Wikipedia - Webservice"

\end_inset

.
 Man verbindet damit primär Akronyme wie SOAP (Simple Object Access Protocol)
 - ein Netzwerkprotokoll für den Transfer von Daten und RPCs (Remote Procedure
 Calls) - oder den einfacheren XML-RPC.
 Diese Webservices arbeiten, wie der Name bereits ausdrückt, mit HTTP POST-Reque
sts, um auf einem meist entfernten Computer eine Methode aufzurufen.
 Unterhalten wird sich hierbei in der XML-basierten Webservices Description
 Language (WSDL).
\end_layout

\begin_layout Standard
Im Jahr 2000 führte Roy Fielding, einer der Authoren der HTTP-Spezifikationen
 1.0 und 1.1 und Mitbegründer des Apache HTTP Projektes, in seiner Dissertation
 
\begin_inset Quotes eld
\end_inset

Architectural Styles and the Design of Network-based Software Architectures
\begin_inset Quotes erd
\end_inset

 den Begriff 
\shape italic
REpresentational State Transfer
\shape default
 ein und definiert ihn als einen 
\begin_inset Quotes eld
\end_inset

Architekturstil für verteilte hypermediale Systeme, der die Richtlinien
 für die Softwareentwicklung spezifiziert, welche sowohl REST selbst leiten
 als auch die Interaktionsvoraussetzungen, die so gewählt werden, dass sie
 diesen Richtlinien entsprechen
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Dissertation Fielding"

\end_inset

.
 Die REST-Architektur ist also ein Modell, das spezifiziert, wie das Internet
 - das im Grunde bereits eine riesige REST-Anwendung darstellt - eigentlich
 funktionieren sollte.
 Er nennt REST eine hybride Architektur, die von vielen verschiedenen Netzwerk
 basierten Architekturstilen abgeleitet ist und bezeichnet Seiten, die mit
 der Architektur REST kompatibel ist, als RESTful.
\end_layout

\begin_layout Standard
Den Kern dieses Architekturmodells bilden so genannte Ressourcen, weswegen
 es auch gerne als Ressource-oriented Architecture - oder kurz ROA - bezeichnet
 wird.
 Alles, was sich eindeutig identifizieren lässt, ist eine Ressource und
 bekommt eine Adresse zugewiesen.
 Jede Datei oder jedes Verzeihnis kann eine Ressource sein, aber auch eine
 ausführbare Methode, die beispielsweise eine Anfrage in einer Datenbank
 auslöst, ist eine denkbare Ressource.
 Hervorragende Kanditaten stellen die Entitäten in einem Datenmodell: 
\shape italic
Artikel
\shape default
, 
\shape italic
Kunde
\shape default
, 
\shape italic
Bestellung
\shape default
 bieten sich hier an, aber auch 
\shape italic
Bestellungen von Kunde X aus Jahr Y
\shape default
 kann eine valide Ressource sein und dann ebenfalls eine möglichst langlebige
 und stabile URL erhalten.
 Bei der Wahl der Ressourcen gilt: Im Zweifel sind eher zu viele Ressourcen
 zu identifizieren als zu wenige.
\end_layout

\begin_layout Subsection
Richtlinien
\end_layout

\begin_layout Standard
Die Tatsache, dass HTTP bereits ein ressourenbezogenes Caching mit sich
 bringt, gibt einem das Gefühl, mit einer REST-Anwendung im Internet bereits
 
\begin_inset Quotes eld
\end_inset

zu Hause zu sein
\begin_inset Quotes erd
\end_inset

.
 Viele Onlineshops, Suchmaschinen oder Buchungssysteme auch ohne, dass sie
 gezielt darauf abzielen, bereits RESTful.
 Damit eine Anwendung das HTTP jedoch auch tatsächlich REST-konform nutzt,
 muss sie sich an die von Fielding diktierten Richtlinien halten.
 Diese Richtlinien lassen sich wie folgt untergliedern, wobei es den einzelnen
 Diensten obliegt, wie diese implementiert werden:
\end_layout

\begin_layout Subsubsection
Adressierbarkeit
\end_layout

\begin_layout Standard
SOAP Webservices, aber auch viele HTML-Seiten, bilden ihre Funktionalität
 auf eine einzelne URL ab.
 Das sieht zwar in der Adresszeile durchaus 
\begin_inset Quotes eld
\end_inset

sauber
\begin_inset Quotes erd
\end_inset

 aus, bringt jedoch Nachteile mit sich: sie lassen sich weder als Lesezeichen
 ablegen, noch kann man mal eben dem Freund/Kommilitonen einen Link auf
 ein Produkt zusenden und auch Suchmaschinen haben es hier schwerer, denn
 auch diese benötiogen zum direkten Zugriff auch Unterbereiche einen konkreten
 Zugriffspfad.
 RESTful gestaltete Anwendungen bieten diese geforderte Addressierbarkeit,
 und zwar genau in dem Maße, in dem die Anwendung es möchte.
 Es ist ohne Weiteres möglich, gezielten Zugriff auf eine Ressource zu unterbind
en, zum Beispiel durch die Verwendung einer Firewall.
 Natürlich ließe sich das URL-Prinzip ebenfalls auf SOAP anwenden, aber
 sobald diese dereferenziert werden, bewegen wir uns wieder in der REST-Welt.
\end_layout

\begin_layout Subsubsection
Unterschiedliche Repräsentationen
\end_layout

\begin_layout Standard
Von den hinter einer URL bereitgestellten Diensten lassen sich unterschiedliche
 Darstellungen anfordern, diese bezeichnet man als Repräsentation dieser
 Ressource.
 Über die im HTTP-Protokoll enthaltenen Accept- und Content-Type-Header
 unterstützt das Internet ebenfalls bereits 
\begin_inset Quotes eld
\end_inset

von Haus aus
\begin_inset Quotes erd
\end_inset

 die Content Negotiation, mit der sich unterschiedliche Repräsentationen
 ein- und derselben Ressource anzeigen lassen.
 Hierbei dürfen sich die Clients das Format anfordern, welches am ehesten
 ihren Bedürfnissen entspricht: Ein Browser zeigt sich meist mit einer HTML-Repr
äsentation zufrieden, während andere Client - wie der in dieser Arbeit vorgestel
lte - ist eher an der XML- oder an der JSON-Repräsentation interessiert.
 Darüber hinaus lassen sich sogar Versionswünsche über die Content Negotiation
 realisieren und beispielsweise der gewünschte Content nach Belieben in
 XML 1.1 oder in XML 1.2 geliefert werden.
\end_layout

\begin_layout Subsubsection
Zustandslosigkeit
\end_layout

\begin_layout Standard
REST ist konzeptual ein zustandsloses Protokoll, somit ist auch jeder RESTful
 Webservice zustandslos.
 Weder Server noch der Webservice behalten sich den aktuellen Stand ihres
 Dialoges, demnach muss jede Nachricht stets alle Informationen beinhalten,
 die erforderlich sind, diese Nachricht korrekt zu interpretieren und die
 Anfrage ordnungsgemäß verarbeiten zu können.
 Da sich weder Server noch Client einen Zustand behalten muss, bezeichnet
 man das Kommunikationsprotokoll einer REST-konformen Architektur als 
\shape italic
zustandslos
\shape default
.
 Durch die Abgeschlossenheit der einzelnen Nachrichten lassen darüber hinaus
 Lasten sehr leicht auf mehrere Maschinen verteilen, was sich positiv auf
 die Skalierbarkeit des Webservice auswirkt.
 In der Praxis wird jedoch auch gerne auf Cookies und andere Techniken zurückgeg
riffen, um über den Request hinaus an Zustandsinformationen gelangen.
\end_layout

\begin_layout Subsubsection
Operationen
\end_layout

\begin_layout Standard
Damit die RESTful gestaltete Webservices untereinander kommunizieren können,
 muss eine gemeinsame Sprache gesprochen werden.
 Das HTTP-Protokoll kennt unter anderem die Optionen GET, POST, PUT, DELETE,
 HEAD und OPTIONS.
 Da jede REST-Ressource die gleichen Operationen nutzen muss, definiert
 dieser Methodensatz die vom REST-Architekturstil geforderten 
\shape italic
wohldefinierten Operationen
\shape default
.
 Durch die Verwendung dieser elementarer Webtechniken wird die Integration
 und Interaktion der beteiligten Softwarekomponenten deutlich vereinfacht.
\end_layout

\begin_layout Standard
Die GET-Methode hat hierbei 
\begin_inset Quotes eld
\end_inset

sicher
\begin_inset Quotes erd
\end_inset

 zu sein, das bedeutet, in diesem Fall wird nur etwas gelesen, der Client
 darf jederzeit bedenkenlos ein GET auf eine Ressource anwenden.
 Weiterhin diktiert die HTTP-Spezifikation die idempotente Implementation
 von GET, PUT und DELETE.
 Wird eine dieser Operationen mehrfach ausgeführt, wird stets das gleiche
 Ergebnis erwartet.
 Ist sich der Client unsicher, ob sein Request erfolgreich abgearbeitet
 wurde, sollte er ihn ohne Seiteneffekte wiederholen dürfen.
 HEAD und OPTIONS finden in REST eher selten Verwendung.
 Die REST-konforme Verwendung der Methoden in einem kurzen Überblick:
\end_layout

\begin_layout Description
GET: Mit GET wird die Repräsentation der Ressource vom Server angefordert.
\end_layout

\begin_layout Description
POST: POST fügt eine neue Unterressource zur angegebenen Ressource ein.
 Da die Unterressource vorher noch nicht existierte, wird die URL zu dieser
 nun vom Server erzeugt und dem Clienten in der Response zurückgegeben.
 Über diese Verwendung hinaus kann POST auch für Operationen verwendet werden,
 die sonst von keiner anderen Methode abgedeckt werden.
\end_layout

\begin_layout Description
PUT: Die in PUT enthaltene Ressource wird angelegt.
 Existiert sie bereits, wird sie, wie im Body angegeben, abgeändert.
\end_layout

\begin_layout Description
DELETE: DELETE entfernt die Ressource komplett.
\end_layout

\begin_layout Description
HEAD: Die Metadaten einer Ressoure lassen sich mit HEAD abfragen.
\end_layout

\begin_layout Description
OPTIONS: Weiß man nicht, welche Methoden auf einer Ressource angewendet
 werden dürfen, lässt sich dies mit OPTIONS in Erfahrung bringen.
\end_layout

\begin_layout Standard
Clientseitig sollte demnach das folgende Protokoll anwendbar sein:
\end_layout

\begin_layout LyX-Code

\size footnotesize
@protocol Resource
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Resource(URI u)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response get()
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response post(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response put(Request r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
- Response delete()
\end_layout

\begin_layout LyX-Code

\size footnotesize
@end
\end_layout

\begin_layout Standard
Die (vereinfachte) Implementation der Anlage eines Kundenkontis im Server
 kann wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
class Customers : Resource {
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
   Response post(Request r){
\end_layout

\begin_layout LyX-Code

\size footnotesize
      id = createCustomer(r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
      return new Response(201, r)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   }
\end_layout

\begin_layout LyX-Code

\size footnotesize
   ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Subsubsection
Hypermedia
\end_layout

\begin_layout Standard
Das Kofferwort Hypermedia ist eine Zusammensetzung aus den Begriffen 
\begin_inset Quotes eld
\end_inset

Hypertext
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

Multimedia
\begin_inset Quotes erd
\end_inset

 und weist auf die Verwendung von Hypertext mit explizitem Akzent auf den
 multimedialen Gesichtspunkt hin.
 Repräsentationen enthalten in der Regel neben Informationen selbst wieder
 Links zu anderen Ressourcen.
 Das macht das Internet zu dem, was es ist: Eine stark vernetzte Verbindungsstru
ktur von identifizierbaren Ressourcen über hypermediale Links auf andere
 identifizierbare Ressourcen.
 Die standartisierte Adressierung sorgt hierbei dafür, dass sich die verlinkte
 Ressource in einem anderen Prozess im gleichen System oder auf einem anderen
 Rechner befinden kann, ganz gleich ob sich dieser im lokalen Netzwerk befindet,
 an einem beliebigen anderen Ort dieses Planeten oder seit Januar 2010 sogar
 auf der Raumstation ISS.
 Hierfür wird auch gerne der Ausdruck 
\shape italic
Verbindungshaftigkeit
\shape default
 verwendet.
 Im Optimalfall wird dem Clienten in der angeforderten Repräsentation gleich
 die nächsten möglichen Übergänge als hypermediale Links mitteilen.
 Der Wert einer Anwendung ist proportional zur Anzahl der Ressourcen, auf
 die sie verlinkt.
 Mit einem Link auf einen REST-konform konzipierten Webservice eines Telekommuni
kationsunternehmen würden mit wenigen Klicks Millionen von Kundendaten zugreifba
r gemacht werden.
 Diese könnten von der Anwendung selbst ausgewertet oder dem Endanwender
 zur Weiterverarbeitung überlassen werden.
\end_layout

\begin_layout Subsection
Beispiel
\end_layout

\begin_layout Standard
Wie so oft lässt sich das Prinzip von REST am Besten an einem Bespiel zeigen.
 Wir betrachten die Schnittstelle für den fiktiven Onlineshop smartphoneseppel.de.
 Ein Neukunde möchte sich ein Smartphone bestellen und legt sich zu diesem
 Zweck ein Kundenkonto an.
 Er wechselt auf die Seite des Onlineshops (
\shape italic
GET http://www.smartphoneseppel.de
\shape default
) und teilt dem Server des Onlineshops mit einem 
\shape italic
POST /customer
\shape default
, in dessen Body die Daten stehen, die er für die Registrierung angegeben
 hat, seine Registrierungsabsicht mit.
 Der Server bestätigt der Response
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 201 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml;
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Length: 44
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
http://www.smartphoneseppel.de/customer/1337
\end_layout

\begin_layout Standard
die erfolgreiche Anlage des des Kundenkontos mit der Kundennummer.
 Die Bestandteile einer HTTP-Resonse sind stets der Statuscode - an dieser
 Stelle weist der Statuscode 201 
\shape italic
CREATED
\shape default
 darauf hin, dass eine neue Ressource angelegt wurde - , die Art des zurückgelie
ferten Contents sowie natürlich den Content selbst.
 Nun kann er mit 
\shape italic
GET /customer/1337
\shape default
 sein Kundenkonto anzeigen lassen.
 Eine Änderung ist mit einem 
\shape italic
PUT /customer/1337
\shape default
 möglich.
 Möchte er sich nun den Artikel 
\shape italic
Samsung Galaxy S3
\shape default
 anzeigen lassen kann er das per 
\shape italic
GET /article/galaxy_s3
\shape default
.
 Es gefällt ihm und so packt er es sich mit einem 
\shape italic
PUT /shoppingcart/1337&article=galaxy_s3
\shape default
 in seinen Warenkorb.
 Zur Sicherheit überprüft er nun dessen Inhalt mit 
\shape italic
GET /shoppingcart/1337
\shape default
.
 Die Antwort des Onlineshops könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
HTTP/1.1 200 OK
\end_layout

\begin_layout LyX-Code

\size footnotesize
Content-Type: text/xml
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0"?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<shoppingcart xmlns:xlink="http://www.w3.org/1999/xlink">
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <customer xlink:href="http://www.smartphoneseppel.de/customer/1337">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1337
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </customer>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <position pos="1" amount="1">
\end_layout

\begin_layout LyX-Code

\size footnotesize
    <article xlink:href="http://www.smartphoneseppel.de/article="galaxy_s3"
\end_layout

\begin_layout LyX-Code

\size footnotesize
       article="galaxy_s3">
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Samsung Galaxy S3</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
    </article>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  </position>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</shoppingcart>
\end_layout

\begin_layout Standard
Kunde 1337 ist mit dem Ergebnis einverstanden und sendet mit 
\shape italic
POST /shoppingcart/1337
\shape default
 seine Bestellung ab, der Server quittiert ihm dies mit einem 
\shape italic
/shoppingcart/1337/open
\shape default
.
 Nun erscheint jedoch unerwartet das iPhone 5 und der Kunde überlegt es
 sich anders.
 Er überprüft, mit einem
\shape italic
 GET /customer/1337/orders
\shape default
 seinen Bestellstatus und hat Glück, die Bestellung wurde noch nicht versendet.
 Er storniert die offene Bestellung mit 
\shape italic
DELETE /customer/1337/orders/open/2012-09-11_001
\shape default
 und legt sich statt dessen mit 
\shape italic
PUT /shoppingcart/1337&article=iphone_5
\shape default
 den neuen Artikel in seinen Korb.
\end_layout

\begin_layout Standard
Der Onlineshop seinerseite entfernt nach dem Release des iPhone 5 mit 
\shape italic
DELETE /article/iphone_4s
\shape default
 das iPhone 4S aus deinem System und legt mit 
\shape italic
PUT /article
\shape default
 das neue Modell an.
 Der Body könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<articles>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <name>iPhone 5</name>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <description>Das beste iPhone, das es je gab.</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <size>64</size>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <weight>140</weight>
\end_layout

\begin_layout LyX-Code

\size footnotesize
  <price>849</price>
\end_layout

\begin_layout LyX-Code

\size footnotesize
</articles>
\end_layout

\begin_layout Standard
Er sendet Kunde 1337 das gewünschte iPhone 5 und verschiebt seine Bestellung
 vom Status offen nach versendet mit: 
\shape italic
DELETE /customer/1337/orders/open/2012-09-12_001
\shape default
 und 
\shape italic
POST /customer/1337/orders/shipped/2012-09-12_001
\shape default
.
\end_layout

\begin_layout Section
XML (1,5 Seiten)
\end_layout

\begin_layout Standard
Die Codebeispiele im vorhergehenden Kapitel zeigen bereits, dass sich hier
 zur Kommunikation eines Austauschformates bedient wird, welches sowohl
 von Menschen gelesen als auch von Maschinen unabhängig von Plattform und
 Implementation geparst werden kann.
 XML steht für Extensible Markup Language (zu Deutsch: erweiterbare Auszeichnung
ssprache) und verwendet das - im einfachsten Fall im ASCII-Format kodierte
 - Textformat, um über eine Metasprache strukuriert Informationen verfügbar
 zu machen.
 Diese vom World Wide Web Consortium (W3C) herausgegebene Spezifikation
 ist aktuell in der 5ten Ausgabe verfügbar und ein Derivat des älteren SGML.
 In vielen Punkten ist XML sehr verwandt mit HTML, jedoch folgt XML einer
 konsequenteren Syntax.
 Dies führt dazu, dass valide XML-Dokumente zuverlässig von verschiedenster
 Software gelesen werden kann.
 Um die zur Formatierung verwenden Zeichen <, >, &, " und ' in Texten zu
 verwenden, greift man auf die Entitäten &lt;, &gt;, &amp;, &quot; sowie
 &apos zurück.
 Weitere feste Entitäten gibt es nicht, jedoch lassen sich beliebig weitere
 Entitäten definieren.
\end_layout

\begin_layout Standard
Die Struktur von XML bietet einige Vorteile gegenüber anderen Austauschformaten:
 Die redundante vollständige Wiederholung des Tagnamens beim Schließen erschwert
 Fehler bei der Verschachtelung und die einfache Syntax von XML, inklusive
 der Element- und Attributbezeichnungen, erleichtern es ungemein, gleich
 zu Beginn ein gutes Gefühl zu bekommen, wie man mit XML umzugehen hat.
 Da die volle XML-Spezifikation allerdings über einen Umfang von gut 30
 Seiten verfügt, soll hier nur ein kleiner Überblick über das Basiswissen
 im Umgang mit XML vermittelt werden.
\end_layout

\begin_layout Standard
Ein einfaches, wohlgeformtes XML-Dokument könnte wie folgt aussehen:
\end_layout

\begin_layout LyX-Code

\size footnotesize
<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout LyX-Code

\size footnotesize
<content>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

1
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Einleitung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

2
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>Die Entwicklungsumgebung</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <chapter no=
\begin_inset Quotes erd
\end_inset

3
\begin_inset Quotes erd
\end_inset

>
\end_layout

\begin_layout LyX-Code

\size footnotesize
      <description>REST</description>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   </chapter>
\end_layout

\begin_layout LyX-Code

\size footnotesize
   <!-- at least chapter IMPLEMENTATION still missing -->
\end_layout

\begin_layout LyX-Code

\size footnotesize
</content>
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Wohlgeformt
\begin_inset Quotes erd
\end_inset

 bedeutet im Kontext eines XML-Dokumentes, dass exakt ein Wurzelelement
 vorhanden ist.
 Elemente sind Informationsträger gleich welcher Art, sie können Texte oder
 weitere Elemente enthalten, auch in Kombination; die Elementbezeichnung
 ist frei wählbar.
 Verfügt ein Element über Inhalt, so wird dieser mit einem Start- sowie
 mit einem Endelement versehen, beispielsweise <tag>content</tag>.
 Steht ein Element ohne Inhalt, so kann das Element den Ein- und den Auszeichner
 in sich vereinen: <no_content />.
 Ein einem Einzeichner oder einem leeren Tag können Attribute enthalten
 sein, die aus einem Name/Wert-Paar bestehen.
 Mehrere gleichlautende Elemente nebeneinander sind kein Problem, mehrere
 gleichlautende Attribute in einem Element sind jedoch nicht zulässig.
 Die Verschachtelung erfolgt 
\shape italic
ebenentreu
\shape default
, ein Element muss also geschlossen werden, bevor ein Geschwisterelement
 beginnt oder ein Elternelement geschlossen wird.
\end_layout

\begin_layout Standard
Über die Wohldefiniertheit hinaus besteht die Möglichkeit, weitere Anforderungen
 an unser Dokument zu stellen, welches sich mit einer Grammatik wie einer
 DTD (Document Type Definition) oder einem XML-Schema realisieren lässt.
 Ein Dokument, welches einen Verweis auf eine solche Grammatik enthält,
 diese auch einhält und darüber hinaus noch vohlgeformt ist, bezeichnet
 man als valid.
 Da das Programm, auf dem diese Arbeit beruht, keine solche Validität betrachtet
, soll an dieser Stelle auch nicht weiter darauf eingegangen werden.
\end_layout

\begin_layout Section
JSON (1 Seite)
\end_layout

\begin_layout Standard
XML ist nicht immer der ideale Weg, um seine Daten zu strukturieren.
 Das Tag-System bläht kleine Datenbestände schnell auf und das Ansprechen
 einzelner XML-Nodes ist nicht immer leicht.
 
\shape italic
JSON
\shape default
 - die Kurzform für 
\shape italic
Java Script Object Notation
\shape default
 - ist XML sehr ähnlich und bietet hier eine leichtgewichtige Alternative.
 Sie ist ein auch vom Menschen gut lesbares Austauschformat, welches darauf
 ausgelegt ist, von einer Anwendung leicht erstellt zu werden und sich anschließ
end - gegebenfalls von einer anderen - auch wieder leicht parsen zu lassen.
 Für ein sprachenübergreifendes Austauschformat ist es natürlich sinnig,
 dass man für den Aufbau auf Strukturen zurückgreift, die gängigen Sprachen
 geläufig sind.
 Somit kommen in JSON Key/Value-Records und Arrays zum Tragen, Strukturen,
 von denen es undenkbar ist, dass man sie in einer halbwegs modernen Programmier
sprache nicht in irgendeiner Form wiederfindet.
 Ein Objekt folgt in JSON 
\shape italic
der Syntax { String : Value }
\shape default
.
 Mehrerer Solcher Paare werden durch Kommata voneinander getrennt: 
\shape italic
{ String1 : Value1, String2 : Value2, ...
 }
\shape default
.
 Leerzeichen können zwischen den einzelnen JSON-Elementen der Übersichtlichkeit
 wegen beliebig gesetzt werden.
 Wie aus den meisten Programmiersprachen bekannt, kennzeichnet die eckige
 Klammer ein Array: 
\shape italic
[ Value1, Value2, Value3, ...
 ]
\shape default
.
 Ein Wert kann hierbei ein oben genanntes String/Value-Objekt sein, aber
 auch Strings, Zahlen oder die boolschen Werte 
\shape italic
true
\shape default
 und 
\shape italic
false
\shape default
 sind möglich.
 Darüber hinaus sind ist auch 
\shape italic
null
\shape default
 und auch weitere Arrays zulässige Werte.
 Zeichenketten, bestehend aus 0 bis n Unicode kompatiblen Zeichen, beginnen
 und enden je mit einem Anführungszeichen und können, ebenfalls wie aus
 C und Java bekannt, Escape-Sequenzen beinhalten, beginnend mit einem Backslash.
 Diese sind im Folgenden: 
\backslash

\shape italic

\begin_inset Quotes erd
\end_inset


\shape default
, 
\backslash

\backslash
 sowie 
\backslash

\shape italic
/
\shape default
 geben jeweils den Wert hinter 
\backslash
 wieder - also 
\shape italic

\begin_inset Quotes eld
\end_inset


\shape default
, 
\backslash
 und 
\shape italic
/
\shape default
 - hingegen steht 
\backslash

\shape italic
b
\shape default
 für ein Backspace, 
\backslash

\shape italic
f
\shape default
 für einen Seitenumbruch, 
\backslash

\shape italic
n
\shape default
 kennzeichnet eine neue Zeile, 
\backslash

\shape italic
r
\shape default
 den Zeilenrücklauf und 
\backslash

\shape italic
u
\shape default
 einen horizontalen Tabulator.
 Schließlich kann man noch, beginnend mit 
\backslash

\shape italic
u
\shape default
, einen vierstelligen Zahlencode eingeben, an dessen Stelle wird dann der
 Wert an der entsprechenden Stelle der Unicodetabelle zurückgegeben.
 Die Zahlensyntax ist ebenfalls aus der C-/Java-Welt bekannt mit der Ausnahme,
 dass JSON weder die Oktal- noch die Hexadezialdarstellung beherrscht.
 42 ist ebenso zulässig wie 1.35e-4 oder auch -3.7589E+20.
\end_layout

\begin_layout Standard
Ein Beispiel für eine JSON-Datei:
\end_layout

\begin_layout LyX-Code

\size footnotesize
{
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1337,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

John Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: [
\end_layout

\begin_layout LyX-Code

\size footnotesize
       [ 3456,
\end_layout

\begin_layout LyX-Code

\size footnotesize
         
\begin_inset Quotes eld
\end_inset

123-4567
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
       ], 
\begin_inset Quotes eld
\end_inset

john.doe@example.com
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
     ],
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: true
\end_layout

\begin_layout LyX-Code

\size footnotesize
  },
\end_layout

\begin_layout LyX-Code

\size footnotesize
  {
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

customer-id
\begin_inset Quotes erd
\end_inset

: 1338,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

Jane Doe
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

contact
\begin_inset Quotes erd
\end_inset

: null,
\end_layout

\begin_layout LyX-Code

\size footnotesize
    
\begin_inset Quotes eld
\end_inset

vip
\begin_inset Quotes erd
\end_inset

: false
\end_layout

\begin_layout LyX-Code

\size footnotesize
  }
\end_layout

\begin_layout LyX-Code

\size footnotesize
}
\end_layout

\begin_layout Chapter
Implementation (11 - 12 Seiten, vielleicht mehr)
\end_layout

\begin_layout Section
Daten (fällt weg)
\end_layout

\begin_layout Description
Template: Single View Application
\end_layout

\begin_layout Description
Name: REST Analyzer
\end_layout

\begin_layout Description
Company
\begin_inset space \thinspace{}
\end_inset

Identifier: Mario Stief
\end_layout

\begin_layout Description
Bundle
\begin_inset space \thinspace{}
\end_inset

Identifier: Mario-Stief.RESTful-Web-Analyzer
\end_layout

\begin_layout Section
Konzept?
\end_layout

\begin_layout Section
Datenmodell (5 - 6 Seiten)
\end_layout

\begin_layout Standard
…
\end_layout

\begin_layout Section
GUI (3 - 4 Seiten)
\end_layout

\begin_layout Standard
Verwendete Grafiken:
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34203/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34206/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34224/256/browser_earth_internet_world_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34211/128/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34212/128/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49232/256/arrow_left_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49243/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/49243/256/
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/34229/256/find_magnifier_search_zoom_icon
\end_layout

\begin_layout Standard
http://www.iconfinder.com/icondetails/54479/128/code_folder_icon
\end_layout

\begin_layout Section
Schwierigkeiten (ca.
 3 Seiten)
\end_layout

\begin_layout Description
Problem: Der RKObjectManager mappt die Werte zu den Keys, die er in seiner
 Delegierten angegeben hat.
 In einem generischen Clienten kann man die Schlüssel schlecht bereits vordefini
eren.
\end_layout

\begin_layout Description
Lösung: Selbst parsen und mappen.
 Parser aus dem Apple-Framework verwenden.
\end_layout

\begin_layout Description
Problem: RKClient kann kein HEAD.
\end_layout

\begin_layout Description
Lösung: Selbst eine Verbindung aufbauen.
 Framework obsolet.
\end_layout

\begin_layout Description
Problem: In Storyboard erzeugter Table View Controller erzeugt eigene Instanz
 der View, Inizialisierung programatisch im Code erzeugt wieder eine eigene.
\end_layout

\begin_layout Description
Lösung: Der Storyboard-Segue einen Identifier zuweisen und mit der Methode
 prepareForSegue der Zielinstanz die Variable übergeben.
\end_layout

\begin_layout Description
Problem: URL soll zur 
\begin_inset Quotes eld
\end_inset

darunterliegenden
\begin_inset Quotes erd
\end_inset

 View übergeben werden und die View geschlossen.
\end_layout

\begin_layout Description
Lösung: Referenzen weiterreichen.
 Zum Schließen der View die Referenz des PopoverControllers weiterleiten,
 dann kann die View 
\begin_inset Quotes eld
\end_inset

von oben
\begin_inset Quotes erd
\end_inset

 geschlossen werden.
\end_layout

\begin_layout Description
Problem: Nachdem das Programm auf iOS 6 problemlos läuft, stürzt es unter
 5.1.1 ab.
\end_layout

\begin_layout Description
Ursache: Unter iOS 6 wird, wenn ein 
\begin_inset Quotes eld
\end_inset

prepareForSegue
\begin_inset Quotes erd
\end_inset

 erkannt wird, der Aufbau der View verzögert, bis die Methode abgearbeitet
 wurde.
 Unter iOS 5.1.1 ist das nicht der Fall, die View wird sofort angelegt.
 Das Dictionary, das in der viewDidLoad in ein Array gefüllt wird, ist noch
 nicht vorhanden, alle Zellen werden (null).
 
\end_layout

\begin_layout Description
Lösung: die Initialisierung des Arrays verschieben von viewDidLoad nach
 viewDidAppear.
\end_layout

\begin_layout Description
Problem: Parsen von großen Inhalten schlägt fehl und die Anzeige im Body
 ist defekt.
\end_layout

\begin_layout Description
Ursache: Jeder Body wurde einzeln abgearbeitet und versucht, zu parsen.
 Fragmente, die demnach falsch anfingen, verursachten einen Fehler.
\end_layout

\begin_layout Description
Lösung: Auslesen der Content Length und abwarten, bis alle Responses eingetroffe
n sind.
 Erst dann parsen.
\end_layout

\begin_layout Description
Problem: Beim Öffnen der Logging View muss erst ein Refresh-Button betätigt
 werden, damit der Log angezeigt wird.
\end_layout

\begin_layout Description
Ursache: Nach dem Anzeigen der View muss das Textfeld aktualisiert werden,
 mit einer Segue lässt sich das so nicht realisieren, das Textfeld müsste
 in einer viewDidAppear ausgeführt werden.
\end_layout

\begin_layout Description
Lösung: Die Output View in eine eigene Klasse auslagern, die eine Methode
 ViewDidAppear besitzt.
\end_layout

\begin_layout Description
Problem: Füllt man ein Table View mit Zellen und packt diese in einen Scroll
 View-Container, so verschwinden die Zellen beim 
\begin_inset Quotes eld
\end_inset

Wischen
\begin_inset Quotes erd
\end_inset

 aus dem sichtbaren Bereich.
\end_layout

\begin_layout Description
Ursache: ARC greift an dieser Stelle und setzt nicht sichtbare Elemente
 auf die Reusable-List.
 Kommen die Zellen wieder in den sichtbaren Bereich, wird die Methode ...
 wieder durchlaufen und erzeugt neue Zellen.
\end_layout

\begin_layout Description
Lösung: Die Daten waren hier in der GUI angelegt, welches einen Verstoß
 gegen den Model View Controller (MVC) darstellt.
 Vor der Zellenerzeugung werden 2 MutableArrays angelegt, deren Inhalt sich
 stets am gleichen Indexwert befindet, wie es bei den Zellen der Fall ist.
 Die Zellenerzeugung greift dann auf den entsprechenden Index im Array zu,
 welcher nicht dereferenziert wird.
\end_layout

\begin_layout Chapter
Distribution (2 Seiten)
\end_layout

\begin_layout Section
Der offizielle Weg: Apple's App Store
\end_layout

\begin_layout Section
Die Alternative: Cydia Store
\end_layout

\begin_layout Standard
Zum offiziellen Vertriebsweg über den Apple App Store gibt es eine Alternative,
 über die man jedoch nur freigeschaltete 
\begin_inset Quotes eld
\end_inset

gejailbreakte
\begin_inset Quotes erd
\end_inset

 Geräte Zugriff haben: Mit dem 
\shape italic
Cydia Store
\shape default
, der standardmäßig bei jedem Jailbreak gleich mitinstalliert wird.
 Mit diesem kann man sich, wie unter Linuxsystemen bekannt, mit verschiedenen
 Repositories verbinden und auf deren Angebot zugreifen.
 Hierbei ist der 
\shape italic
Cydia Store
\shape default
 nicht als ein Distributionssystem für raubkopierte Software zu verstehen,
 denn er implementiert ebenfalls ein Bezahlsystem, mit dem Entwickler in
 der Lage sind, ihre Anwendungen entgeltlich anzubieten.
 Interessant wird diese Vertriebsmethode, wenn man eine App entwickeln möchte,
 die die Rechte, die Apple einer solchen Anwendung zugesteht, bei weitem
 überschreitet.
 Ein sehr schönes Beispiel für eine solche Anwendung ist der Windowmanager
 
\shape italic
Quasar
\shape default
, der eine Alternative bietet zu Apples Zwangvorschrift, jede Anwendung
 im Vollbild betreiben zu müssen.
 Vor allem auf dem iPad der dritten Generation kann es durchaus eine wünschenswe
rte Option sein, zwei oder mehr Fenster nebeneinander betreiben zu können.
 So könnte man beispielsweise auf der einen Seite ein Textverarbeitungsprogramm
 laufen haben, während auf der anderen Bildschirmhälfte ein Internetbrowser
 geöffnet ist.
\end_layout

\begin_layout Standard
Um unsere mittels unserer Entwicklerlizenz kompilierten Apps in ein DEB-Paket
 umzuwandeln, bedienen uns bequem des Programmes MacPorts, welches – ähnlich
 Fink – eine Paketverwaltung für freie und quelloffene Software für OS X
 ist.
\end_layout

\begin_layout Description
Quelle: http://www.macports.org/
\end_layout

\begin_layout Standard
Da sich dieses Programm nach /opt/local/bin installiert, fügen wir dieses
 Verzeichnis unserem Pfad hinzu:
\end_layout

\begin_layout LyX-Code

\size small
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
\end_layout

\begin_layout Standard
Nun folgt ein Update dessen Paketquellen:
\end_layout

\begin_layout LyX-Code

\size small
sudo port selfupdate
\end_layout

\begin_layout Standard
und die Installation des gewünschten Paketes dpkg:
\end_layout

\begin_layout LyX-Code

\size small
sudo port install dpkg
\end_layout

\begin_layout Standard
welche den gewünschten Befehl dkgp-deb bereitstellt.
 Mit diesem sind wir nun in der Lage, aus den fertigen Apps Cydia-Repo-konforme
 DEB-Pakete zu erstellen.
\end_layout

\begin_layout Standard
Zum Konvertieren in ein DEB-Paket besteht dpkg-deb jedoch auf eine Struktur,
 welche sich wie folgt aufbaut:
\end_layout

\begin_layout LyX-Code

\size small
+- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   +- Applications
\end_layout

\begin_layout LyX-Code

\size small
   |  +- MyProgram.app
\end_layout

\begin_layout LyX-Code

\size small
   |     +- Info.plist
\end_layout

\begin_layout LyX-Code

\size small
   |     +- MyProgram
\end_layout

\begin_layout LyX-Code

\size small
   |     +- icon.png
\end_layout

\begin_layout LyX-Code

\size small
   +- DEBIAN
\end_layout

\begin_layout LyX-Code

\size small
   |  +- control
\end_layout

\begin_layout LyX-Code

\size small
   +- System
\end_layout

\begin_layout LyX-Code

\size small
      +- Library
\end_layout

\begin_layout LyX-Code

\size small
         +- LaunchDaemons
\end_layout

\begin_layout LyX-Code

\size small
            +- com.identifier.MyProgram.plist
\end_layout

\begin_layout Standard
Das Verzeichnis System ist hierbei optional.
\end_layout

\begin_layout Standard
Die Datei control kann folgende Einträge beinhalten: Package, Name, Version,
 Architecture, Description, Homepage, Depiction, Maintainer, Author, Sponsor,
 Section.
 Zwingend vorgeschrieben sind davon jedoch nur Package und Version.
\end_layout

\begin_layout Standard
Darüber hinaus erstellt OS X, wenn TAR-Dateien erzeugt werden – die ein
 Teil der internen Struktur eines Debian-Paketes darstellen – einige ._*-Dateien,
 welche zusätzliche Informationen enthalten.
 Diese zusätzlichen Dateien würden zusammen mit dem Paket installiert werden
 und Konflikte mit anderen Paketen erzeugen (abgesehen davon, dass diese
 Dateien einfach nicht in unser Paket gehören).
 Um dieses Feature zu deaktivieren werden folgende Umgebungsvariablen exportiert
:
\end_layout

\begin_layout LyX-Code

\size small
export COPYFILE_DISABLE
\end_layout

\begin_layout LyX-Code

\size small
export COPY_EXTENDED_ATTRIBUTES_DISABLE
\end_layout

\begin_layout Standard
Sind wir nun soweit wechseln im Terminal ins Verzeichnis 
\begin_inset Quotes eld
\end_inset

MyProgramm
\begin_inset Quotes erd
\end_inset

 und erzeuen unser DEB-Paket mittels:
\end_layout

\begin_layout LyX-Code

\size small
dpkg-deb -b MyProgram
\end_layout

\begin_layout Description
Quelle: http://www.saURLk.com/id/7
\end_layout

\begin_layout Subsubsection
Vom DEB-Paket aufs Device
\end_layout

\begin_layout Standard
Um die nun fertige DEB-Datei auf das iPad zu bekommen, benötigen wir ein
 Cydia-kompatible Repository.
 Hierfür habe ich auf das kostenlose Angebot von MyRepoSpace zurückgegriffen,
 in dem man die fertigen Pakete komfortabel über ein Webinterface in die
 Source lädt.
 Die im Cydia Store eingebundene Paketquelle lautet:
\end_layout

\begin_layout LyX-Code

\size small
http://cydia.myrepospace.com/RaveAngel/
\end_layout

\begin_layout Chapter
Schlusswort (1 Seite?)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Dissertation Fielding"

\end_inset

Fielding, Roy (2000) Dissertation: Architectural Styles and the Design of
 Network-based Software Architectures
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bayer - REST Einführung"

\end_inset

Bayer, Thomas (2002): REST Webservices: Eine Einführung
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JAXenter"

\end_inset

Tilkov, Stefan (2009): REST - Der bessere Webservice? In: JAXenter, URL:
 http://it-republik.de/jaxenter/artikel/REST---Der-bessere-Web-Service-2158.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - Webservice"

\end_inset

Wikipedia: Web service, URL: http://en.wikipedia.org/wiki/Web_service (letzter
 Aufruf am 5.9.2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Wikipedia - REST"

\end_inset

http://de.wikipedia.org/wiki/Representational_State_Transfer
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Installing RestKit"

\end_inset

https://github.com/RestKit/RestKit/wiki/Installing-RestKit-in-Xcode-4.x
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Developing RESTful iOS Apps with RestKit"

\end_inset

Watters, Blake (2011); Developing RESTful iOS Apps with RestKit in: mobile
 tuts+, URL: http://mobile.tutsplus.com/tutorials/iphone/restkit_ios-sdk/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JSON.org - Einführung in JSON"

\end_inset

Introducing JSON, URL: http://json.org/index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "W3C - XML Essentials"

\end_inset

XML ESSENTIALS, URL: http://www.w3.org/standards/xml/core
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "The Objective-C Programming Language"

\end_inset

https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/ObjectiveC
/Introduction/introObjectiveC.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Learning Objective-C"

\end_inset

http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/Learning_O
bjective-C_A_Primer/_index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Galileo Computing"

\end_inset

Rodewig, Klaus M.
 / Wagner, Clemens: Apps entwickeln für iPhone und iPad - Das Praxisbuch,
 Galileo Computing, 2012, URL: http://openbook.galileocomputing.de/apps_entwickeln
_fuer_iphone_und_ipad/index.html
\end_layout

\end_body
\end_document
